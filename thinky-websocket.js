(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Thinky"] = factory();
	else
		root["Thinky"] = factory();
//exports.__esModule = true;
console.log(typeof exports, typeof module, typeof define)
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var rethinkdbdash = __webpack_require__(1);
	var Promise = __webpack_require__(29);
	var Model = __webpack_require__(64);
	var util = __webpack_require__(65);
	var type = __webpack_require__(68);
	var Query = __webpack_require__(81);
	var Errors = __webpack_require__(66);

	/**
	 * Main method, create the default database.
	 *
	 * @param {Object} options the options for the driver and the future models created.
	 *  - `max` {number} The maximum number of connections in the pool, default 1000
	 *  - `buffer` {number} The minimum number of connections available in the pool, default 50
	 *  - `timeoutError` {number} The wait time before reconnecting in case of an error (in ms), default 1000
	 *  - `timeoutGb` {number} How long the pool keep a connection that hasn't been used (in ms), default 60*60*1000
	 *  - `enforce_missing` {boolean}, default `false`
	 *  - `enforce_extra` {"strict"|"remove"|"none"}, default `"none"`
	 *  - `enforce_type` {"strict"|"loose"|"none"}, default `"loose"`
	 *  - `timeFormat` {"raw"|"native"}
	 */
	function Thinky(config) {
	  var self = this;

	  config = config || {};
	  config.db = config.db || 'test'; // We need the default db to create it.
	  self._config = config;

	  self._options = {};
	  // Option passed to each model we are going to create.
	  self._options.enforce_missing =
	    (config.enforce_missing != null) ? config.enforce_missing : false;
	  self._options.enforce_extra =
	    (config.enforce_extra != null) ? config.enforce_extra : "none";
	  self._options.enforce_type =
	    (config.enforce_type != null) ? config.enforce_type : 'loose';

	  // Format of time objects returned by the database, by default we convert
	  // them to JavaScript Dates.
	  self._options.timeFormat =
	    (config.timeFormat != null) ? config.timeFormat : 'native';
	  // Option passed to each model we are going to create.
	  self._options.validate =
	    (config.validate != null) ? config.validate : 'onsave';

	  self.r = rethinkdbdash(config);
	  self.type = type;
	  self.Query = Query;
	  self.models = {};

	  // Export errors
	  self.Errors = Errors;

	  // Initialize the database.
	  self.dbReady().then().error(function(error) {
	    throw error;
	  });
	}


	/**
	 * Initialize our database.
	 * @return {Promise=} Returns a promise which will resolve when the database is ready.
	 */
	Thinky.prototype.dbReady = function() {
	  var self = this;
	  if (this._dbReadyPromise) return this._dbReadyPromise;
	  var r = self.r;
	  this._dbReadyPromise = r.dbCreate(self._config.db)
	  .run()
	  .error(function(error) {
	    // The `do` is not atomic, we a concurrent query could create the database
	    // between the time `dbList` is ran and `dbCreate` is.
	    if (error.message.match(/^Database `.*` already exists in/)) {
	      return;
	    }

	    // In case something went wrong here, we do not recover and throw.
	    throw error;
	  });

	  return self._dbReadyPromise;
	};

	/**
	 * Return the current option used.
	 * @return {object} The global options of the library
	 */
	Thinky.prototype.getOptions = function() {
	  return this._options;
	}


	/**
	 * Create a model
	 *
	 * @param {string} name The name of the table used behind this model.
	 * @param {object|Type} schema The schema of this model.
	 * @param {object=} options Options for this model. The fields can be:
	 *  - `init` {boolean} Whether the table should be created or not. The value
	 *  `false` is used to speed up testing, and should probably be `true` in
	 *  other use cases.
	 *  - `timeFormat` {"raw"|"native"} Format of ReQL dates.
	 *  - `enforce_missing` {boolean}, default `false`.
	 *  - `enforce_extra` {"strict"|"remove"|"none"}, default `"none"`.
	 *  - `enforce_type` {"strict"|"loose"|"none"}, default `"loose"`.
	 *  - `validate` {"oncreate"|"onsave"}, default "onsave".
	 */
	Thinky.prototype.createModel = function(name, schema, options) {
	  var self = this;

	  // Make a deep copy of the options as the model may overwrite them.
	  var fullOptions = util.deepCopy(this._options);
	  options = options || {};
	  util.loopKeys(options, function(options, key) {
	    fullOptions[key] = options[key];
	  });

	  // Two models cannot share the same name.
	  if (self.models[name] !== undefined) {
	    throw new Error("Cannot redefine a Model");
	  }

	  // Create the constructor returned. This will also validate the schema.
	  var model = Model.new(name, schema, fullOptions, self);

	  // Keep a reference of this model.
	  self.models[name] = model;
	  return model;
	}


	/**
	 * Method to clean all the references to the models. This is used to speed up
	 * testing and should not be used in other use cases.
	 */
	Thinky.prototype._clean = function() {
	  this.models = {};
	}


	// Export the module.
	module.exports = function(config) {
	  return new Thinky(config);
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global, setImmediate, Buffer) {(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(8), __webpack_require__(9), __webpack_require__(12));
		else if(typeof define === 'function' && define.amd)
			define(["events", "util", "stream"], factory);
		else if(typeof exports === 'object')
			exports["RethinkdbWebsocketClient"] = factory(require("events"), require("util"), require("stream"));
		else
			root["RethinkdbWebsocketClient"] = factory(root["events"], root["util"], root["stream"]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_50__, __WEBPACK_EXTERNAL_MODULE_51__, __WEBPACK_EXTERNAL_MODULE_55__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(1);


	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		Object.defineProperty(exports, '__esModule', {
		  value: true
		});
		exports['default'] = main;

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var _rethinkdbdash = __webpack_require__(2);

		var _rethinkdbdash2 = _interopRequireDefault(_rethinkdbdash);

		var _TcpPolyfill = __webpack_require__(43);

		var _objectAssign = __webpack_require__(63);

		var _objectAssign2 = _interopRequireDefault(_objectAssign);

		function main(options) {
		  var opt = (0, _objectAssign2['default'])({
		    path: '/',
		    secure: false,
		    wsProtocols: ['binary']
		  }, options);
		  (0, _TcpPolyfill.configureTcpPolyfill)(opt);
		  return (0, _rethinkdbdash2['default'])(opt);
		}

		module.exports = exports['default'];

	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {

		var Promise = __webpack_require__(3);

		var helper = __webpack_require__(41);
		var Connection = __webpack_require__(48);
		var Term = __webpack_require__(57);
		var Error = __webpack_require__(52);
		var PoolMaster = __webpack_require__(60);
		var termTypes = __webpack_require__(42).Term.TermType;

		function r(options) {
		  var self = this;
		  var _r = function(x) {
		    return new Term(_r).expr(x);
		  }
		  helper.changeProto(_r, self);

		  Term.prototype._setNestingLevel(r.prototype.nestingLevel);
		  Term.prototype._setArrayLimit(r.prototype.arrayLimit);

		  _r.row = new Term(_r).row();

		  _r.monday = new Term(_r).monday();
		  _r.tuesday = new Term(_r).tuesday();
		  _r.wednesday = new Term(_r).wednesday();
		  _r.thursday = new Term(_r).thursday();
		  _r.friday = new Term(_r).friday();
		  _r.saturday = new Term(_r).saturday();
		  _r.sunday =  new Term(_r).sunday();

		  _r.january = new Term(_r).january();
		  _r.february = new Term(_r).february();
		  _r.march = new Term(_r).march();
		  _r.april = new Term(_r).april();
		  _r.may = new Term(_r).may();
		  _r.june = new Term(_r).june();
		  _r.july = new Term(_r).july();
		  _r.august = new Term(_r).august();
		  _r.september = new Term(_r).september();
		  _r.october = new Term(_r).october();
		  _r.november = new Term(_r).november();
		  _r.december = new Term(_r).december();
		  _r.minval = new Term(_r).minval();
		  _r.maxval = new Term(_r).maxval();

		  _r.nextVarId = 1;
		  _r._Term = Term;
		  return _r;
		};
		r.prototype._host = 'localhost';
		r.prototype._port = 28015;
		r.prototype._authKey = '';
		r.prototype._timeoutConnect = 20;

		r.prototype._nestingLevel = 100;
		r.prototype._arrayLimit = 100000;
		r.prototype._db = 'test';
		r.prototype._useOutdated = false;
		r.prototype._timeFormat = 'native';
		r.prototype._profile = false;


		r.prototype.setNestingLevel = function(nestingLevel) {
		  if (typeof nestingLevel !== 'number') throw new Error.ReqlDriverError('The first argument of `setNestingLevel` must be a number.')
		  this.nestingLevel = nestingLevel;
		}
		r.prototype.setArrayLimit = function(arrayLimit) {
		  if (typeof arrayLimit !== 'number') throw new Error.ReqlDriverError('The first argument of `setArrayLimit` must be a number.')
		  this.arrayLimit = arrayLimit;
		}

		r.prototype.connect = function(options, callback) {
		  if (typeof options === 'function') {
		    callback = options;
		    options = {};
		  }
		  var self = this;

		  var p = new Promise(function(resolve, reject) {
		    new Connection(self, options, resolve, reject);
		  }).nodeify(callback);
		  return p;
		};

		r.prototype.createPools = function(options) {
		  this._poolMaster = new PoolMaster(this, options);
		  return this;
		}

		r.prototype.getPoolMaster = function() {
		  return this._poolMaster;
		}
		r.prototype.getPool = function(i) {
		  if (i === undefined) {
		    if (this.getPoolMaster().getPools().length === 1) {
		      return this.getPoolMaster().getPools()[0];
		    }
		    else {
		      throw new Error('You have multiple pools. Use `getPool(index)` or `getPools()`');
		    }
		  }
		  else {
		    return this.getPoolMaster().getPools()[i];
		  }
		}

		r.prototype.expr = function(expression, nestingLevel) {
		  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arityRange(_args, 1, 2, 'expr', this);
		  }
		  var _nestingLevel = nestingLevel || this.nestingLevel;
		  return new Term(this).expr(expression, _nestingLevel);
		};
		r.prototype.db = function(db) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.db', this);
		  }
		  return new Term(this).db(db);
		};
		r.prototype.table = function(table, options) {
		  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arityRange(_args, 1, 2, 'table', this);
		  }
		  return new Term(this).table(table, options);
		};
		r.prototype.js = function(jsString, options) {
		  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arityRange(_args, 1, 2, 'r.js', this);
		  }
		  return new Term(this).js(jsString, options);
		};
		r.prototype.tableCreate = function(table, options) {
		  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arityRange(_args, 1, 2, 'r.tableCreate', this);
		  }
		  return new Term(this).tableCreate(table, options);
		};
		r.prototype.tableDrop = function(db) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.tableDrop', this);
		  }
		  return new Term(this).tableDrop(db);
		};
		r.prototype.tableList = function() {
		  if (Term.prototype._fastArity(arguments.length, 0) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 0, 'r.tableList', this);
		  }
		  return new Term(this).tableList();
		};
		r.prototype.dbCreate = function(db) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'dbCreate', this);
		  }
		  return new Term(this).dbCreate(db);
		};
		r.prototype.dbDrop = function(db) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'dbDrop', this);
		  }
		  return new Term(this).dbDrop(db);
		};
		r.prototype.dbList = function() {
		  if (Term.prototype._fastArity(arguments.length, 0) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 0, 'dbList', this);
		  }
		  return new Term(this).dbList();
		};
		r.prototype.literal = function(obj) {
		  if (Term.prototype._fastArityRange(arguments.length, 0, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arityRange(_args, 1, 2, 'r.literal', this);
		  }
		  if (obj === undefined) {
		    return new Term(this).literal();
		  }
		  else {
		    return new Term(this).literal(obj);
		  }
		};
		r.prototype.desc = function(field) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.desc', this);
		  }
		  return new Term(this).desc(field);
		};
		r.prototype.asc = function(field) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.asc', this);
		  }
		  return new Term(this).asc(field);
		};
		r.prototype.union = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}

		  var term = new Term(this).expr(_args[0]);
		  return term.union.apply(term, _args.slice(1));
		};
		r.prototype.add = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 2, Infinity, 'r.add', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.add.apply(term, _args.slice(1));
		};
		r.prototype.sub = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 2, Infinity, 'r.sub', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.sub.apply(term, _args.slice(1));
		};
		r.prototype.div = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 2, Infinity, 'r.div', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.div.apply(term, _args.slice(1));
		};
		r.prototype.mul = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 2, Infinity, 'r.mul', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.mul.apply(term, _args.slice(1));
		};
		r.prototype.mod = function(a, b) {
		  if (Term.prototype._fastArity(arguments.length, 2) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 2, 'r.mod', this);
		  }

		  return new Term(this).expr(a).mod(b);
		};
		r.prototype.and = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 1, Infinity, 'r.and', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.and.apply(term, _args.slice(1));
		};
		r.prototype.or = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 1, Infinity, 'r.or', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.or.apply(term, _args.slice(1));
		};
		r.prototype.eq = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 2, Infinity, 'r.eq', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.eq.apply(term, _args.slice(1));
		};
		r.prototype.ne = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 2, Infinity, 'r.ne', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.ne.apply(term, _args.slice(1));
		};
		r.prototype.gt = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 2, Infinity, 'r.gt', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.gt.apply(term, _args.slice(1));
		};
		r.prototype.ge = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 2, Infinity, 'r.ge', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.ge.apply(term, _args.slice(1));
		};
		r.prototype.lt = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 2, Infinity, 'r.lt', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.lt.apply(term, _args.slice(1));
		};
		r.prototype.le = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 2, Infinity, 'r.le', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.le.apply(term, _args.slice(1));
		};
		r.prototype.not = function(bool) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.not', this);
		  }
		  return new Term(this).expr(bool).not();
		}
		r.prototype.floor = function(num) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.floor', this);
		  }
		  return new Term(this).expr(num).floor();
		}
		r.prototype.ceil = function(num) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.ceil', this);
		  }
		  return new Term(this).expr(num).ceil();
		}
		r.prototype.round = function(num) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.round', this);
		  }
		  return new Term(this).expr(num).round();
		}


		r.prototype.now = function() {
		  if (Term.prototype._fastArity(arguments.length, 0) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 0, 'now', this);
		  }
		  return new Term(this).now();
		}
		r.prototype.time = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  var term = new Term(this);
		  return term.time.apply(term, _args);
		}
		r.prototype.epochTime = function(epochTime) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.epochTime', this);
		  }
		  return new Term(this).epochTime(epochTime);
		}
		r.prototype.ISO8601 = function(isoTime, options) {
		  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arityRange(_args, 1, 2, 'r.ISO8601', this);
		  }
		  return new Term(this).ISO8601(isoTime, options);
		}
		r.prototype.branch = function(predicate, trueBranch, falseBranch) {
		  if (Term.prototype._fastArity(arguments.length, 3) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 3, 'r.branch', this);
		  }
		  return new Term(this).expr(predicate).branch(trueBranch, falseBranch);
		}
		r.prototype.error = function(errorStr) {
		  if (Term.prototype._fastArityRange(arguments.length, 0, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arityRange(_args, 0, 1, 'r.error', this);
		  }
		  var term = new Term(this);
		  term._query.push(termTypes.ERROR);
		  if (errorStr !== undefined) {
		    term._query.push([new Term(this).expr(errorStr)._query]);
		  }
		  return term;

		}
		r.prototype.json = function(json) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.json', this);
		  }
		  return new Term(this).json(json);
		}

		r.prototype.object = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  var term = new Term(this);
		  return term.object.apply(term, _args);
		}
		r.prototype.args = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  var term = new Term(this);
		  return term.args.apply(term, _args);
		}
		r.prototype.random = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  var term = new Term(this);
		  return term.random.apply(term, _args);
		}
		r.prototype.http = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  var term = new Term(this);
		  return term.http.apply(term, _args);
		}
		r.prototype.do = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 2, Infinity, 'r.do', this);

		  var term = new Term(this).expr(_args[0]);
		  return term.do.apply(term, _args.slice(1));
		}
		r.prototype.binary = function(bin) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.binary', this);
		  }
		  var term = new Term(this);
		  return term.binary(bin);
		}
		r.prototype.uuid = function() {
		  if (Term.prototype._fastArity(arguments.length, 0) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 0, 'uuid', this);
		  }
		  return new Term(this).uuid();
		}

		r.prototype.line = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 2, Infinity, 'r.line', this);

		  var term = new Term(this);
		  return term.line.apply(term, _args);
		}
		r.prototype.point = function(longitude, latitude) {
		  if (Term.prototype._fastArity(arguments.length, 2) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 2, 'r.point', this);
		  }
		  return new Term(this).point(longitude, latitude);
		}
		r.prototype.polygon = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 3, Infinity, 'r.polygon', this);

		  var term = new Term(this);
		  return term.polygon.apply(term, _args);
		}
		r.prototype.circle = function(center, radius, options) {
		  if (Term.prototype._fastArityRange(arguments.length, 2, 3) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arityRange(_args, 2, 3, 'r.circle', this);
		  }
		  var term = new Term(this);
		  if (options !== undefined) {
		    return term.circle(center, radius, options);
		  }
		  else {
		    return term.circle(center, radius);
		  }
		}
		r.prototype.geojson = function(value) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.geojson', this);
		  }
		  var term = new Term(this);
		  return term.geojson(value);
		}
		r.prototype.range = function(start, end) {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 1, 2, 'r.range', this);

		  var term = new Term(this);
		  if (end !== undefined) {
		    return term.range(start, end);
		  }
		  else {
		    return term.range(start);
		  }
		}
		r.prototype.wait = function() {
		  if (Term.prototype._fastArity(arguments.length, 0) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 0, 'r.wait', this);
		  }
		  var term = new Term(this);
		  return term.wait();
		}
		r.prototype.reconfigure = function(config) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.reconfigure', this);
		  }
		  var term = new Term(this);
		  return term.reconfigure(config);
		}
		r.prototype.rebalance = function(config) {
		  if (Term.prototype._fastArity(arguments.length, 0) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 0, 'r.rebalance', this);
		  }
		  var term = new Term(this);
		  return term.rebalance();
		}
		r.prototype.map = function() {
		  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		  Term.prototype._arityRange(_args, 1, Infinity, 'r.map', this);

		  var term = new Term(this);
		  return term.map.apply(term, _args);
		};
		r.prototype.typeOf = function(value) {
		  if (Term.prototype._fastArity(arguments.length, 1) === false) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    Term.prototype._arity(_args, 1, 'r.typeOf', this);
		  }
		  var term = new Term(this);
		  return term.expr(value).typeOf();
		}


		r.prototype.Error = Error;


		function main(options) {
		  var _r = new r();

		  if (!helper.isPlainObject(options)) options = {};
		  if (options.pool !== false) _r.createPools(options);
		  _r._options = {};
		  if (options.cursor === true) _r._options.cursor = true;
		  if (options.stream === true) _r._options.stream = true;
		  if (options.optionalRun === false) {
		    delete _r._Term.prototype.then
		    delete _r._Term.prototype.error
		    delete _r._Term.prototype.catch
		    delete _r._Term.prototype.finally
		  }
		  return _r;
		}
		module.exports = main;


	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var old;
		if (typeof Promise !== "undefined") old = Promise;
		function noConflict() {
		    try { if (Promise === bluebird) Promise = old; }
		    catch (e) {}
		    return bluebird;
		}
		var bluebird = __webpack_require__(4)();
		bluebird.noConflict = noConflict;
		module.exports = bluebird;


	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function() {
		var makeSelfResolutionError = function () {
		    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
		};
		var reflect = function() {
		    return new Promise.PromiseInspection(this._target());
		};
		var apiRejection = function(msg) {
		    return Promise.reject(new TypeError(msg));
		};

		var util = __webpack_require__(5);

		var getDomain;
		if (util.isNode) {
		    getDomain = function() {
		        var ret = process.domain;
		        if (ret === undefined) ret = null;
		        return ret;
		    };
		} else {
		    getDomain = function() {
		        return null;
		    };
		}
		util.notEnumerableProp(Promise, "_getDomain", getDomain);

		var async = __webpack_require__(7);
		var errors = __webpack_require__(10);
		var TypeError = Promise.TypeError = errors.TypeError;
		Promise.RangeError = errors.RangeError;
		Promise.CancellationError = errors.CancellationError;
		Promise.TimeoutError = errors.TimeoutError;
		Promise.OperationalError = errors.OperationalError;
		Promise.RejectionError = errors.OperationalError;
		Promise.AggregateError = errors.AggregateError;
		var INTERNAL = function(){};
		var APPLY = {};
		var NEXT_FILTER = {e: null};
		var tryConvertToPromise = __webpack_require__(11)(Promise, INTERNAL);
		var PromiseArray =
		    __webpack_require__(12)(Promise, INTERNAL,
		                                    tryConvertToPromise, apiRejection);
		var CapturedTrace = __webpack_require__(13)();
		var isDebugging = __webpack_require__(14)(Promise, CapturedTrace);
		 /*jshint unused:false*/
		var createContext =
		    __webpack_require__(15)(Promise, CapturedTrace, isDebugging);
		var CatchFilter = __webpack_require__(16)(NEXT_FILTER);
		var PromiseResolver = __webpack_require__(17);
		var nodebackForPromise = PromiseResolver._nodebackForPromise;
		var errorObj = util.errorObj;
		var tryCatch = util.tryCatch;
		function Promise(resolver) {
		    if (typeof resolver !== "function") {
		        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
		    }
		    if (this.constructor !== Promise) {
		        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
		    }
		    this._bitField = 0;
		    this._fulfillmentHandler0 = undefined;
		    this._rejectionHandler0 = undefined;
		    this._progressHandler0 = undefined;
		    this._promise0 = undefined;
		    this._receiver0 = undefined;
		    this._settledValue = undefined;
		    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
		}

		Promise.prototype.toString = function () {
		    return "[object Promise]";
		};

		Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
		    var len = arguments.length;
		    if (len > 1) {
		        var catchInstances = new Array(len - 1),
		            j = 0, i;
		        for (i = 0; i < len - 1; ++i) {
		            var item = arguments[i];
		            if (typeof item === "function") {
		                catchInstances[j++] = item;
		            } else {
		                return Promise.reject(
		                    new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
		            }
		        }
		        catchInstances.length = j;
		        fn = arguments[i];
		        var catchFilter = new CatchFilter(catchInstances, fn, this);
		        return this._then(undefined, catchFilter.doFilter, undefined,
		            catchFilter, undefined);
		    }
		    return this._then(undefined, fn, undefined, undefined, undefined);
		};

		Promise.prototype.reflect = function () {
		    return this._then(reflect, reflect, undefined, this, undefined);
		};

		Promise.prototype.then = function (didFulfill, didReject, didProgress) {
		    if (isDebugging() && arguments.length > 0 &&
		        typeof didFulfill !== "function" &&
		        typeof didReject !== "function") {
		        var msg = ".then() only accepts functions but was passed: " +
		                util.classString(didFulfill);
		        if (arguments.length > 1) {
		            msg += ", " + util.classString(didReject);
		        }
		        this._warn(msg);
		    }
		    return this._then(didFulfill, didReject, didProgress,
		        undefined, undefined);
		};

		Promise.prototype.done = function (didFulfill, didReject, didProgress) {
		    var promise = this._then(didFulfill, didReject, didProgress,
		        undefined, undefined);
		    promise._setIsFinal();
		};

		Promise.prototype.spread = function (didFulfill, didReject) {
		    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
		};

		Promise.prototype.isCancellable = function () {
		    return !this.isResolved() &&
		        this._cancellable();
		};

		Promise.prototype.toJSON = function () {
		    var ret = {
		        isFulfilled: false,
		        isRejected: false,
		        fulfillmentValue: undefined,
		        rejectionReason: undefined
		    };
		    if (this.isFulfilled()) {
		        ret.fulfillmentValue = this.value();
		        ret.isFulfilled = true;
		    } else if (this.isRejected()) {
		        ret.rejectionReason = this.reason();
		        ret.isRejected = true;
		    }
		    return ret;
		};

		Promise.prototype.all = function () {
		    return new PromiseArray(this).promise();
		};

		Promise.prototype.error = function (fn) {
		    return this.caught(util.originatesFromRejection, fn);
		};

		Promise.is = function (val) {
		    return val instanceof Promise;
		};

		Promise.fromNode = function(fn) {
		    var ret = new Promise(INTERNAL);
		    var result = tryCatch(fn)(nodebackForPromise(ret));
		    if (result === errorObj) {
		        ret._rejectCallback(result.e, true, true);
		    }
		    return ret;
		};

		Promise.all = function (promises) {
		    return new PromiseArray(promises).promise();
		};

		Promise.defer = Promise.pending = function () {
		    var promise = new Promise(INTERNAL);
		    return new PromiseResolver(promise);
		};

		Promise.cast = function (obj) {
		    var ret = tryConvertToPromise(obj);
		    if (!(ret instanceof Promise)) {
		        var val = ret;
		        ret = new Promise(INTERNAL);
		        ret._fulfillUnchecked(val);
		    }
		    return ret;
		};

		Promise.resolve = Promise.fulfilled = Promise.cast;

		Promise.reject = Promise.rejected = function (reason) {
		    var ret = new Promise(INTERNAL);
		    ret._captureStackTrace();
		    ret._rejectCallback(reason, true);
		    return ret;
		};

		Promise.setScheduler = function(fn) {
		    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
		    var prev = async._schedule;
		    async._schedule = fn;
		    return prev;
		};

		Promise.prototype._then = function (
		    didFulfill,
		    didReject,
		    didProgress,
		    receiver,
		    internalData
		) {
		    var haveInternalData = internalData !== undefined;
		    var ret = haveInternalData ? internalData : new Promise(INTERNAL);

		    if (!haveInternalData) {
		        ret._propagateFrom(this, 4 | 1);
		        ret._captureStackTrace();
		    }

		    var target = this._target();
		    if (target !== this) {
		        if (receiver === undefined) receiver = this._boundTo;
		        if (!haveInternalData) ret._setIsMigrated();
		    }

		    var callbackIndex = target._addCallbacks(didFulfill,
		                                             didReject,
		                                             didProgress,
		                                             ret,
		                                             receiver,
		                                             getDomain());

		    if (target._isResolved() && !target._isSettlePromisesQueued()) {
		        async.invoke(
		            target._settlePromiseAtPostResolution, target, callbackIndex);
		    }

		    return ret;
		};

		Promise.prototype._settlePromiseAtPostResolution = function (index) {
		    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
		    this._settlePromiseAt(index);
		};

		Promise.prototype._length = function () {
		    return this._bitField & 131071;
		};

		Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
		    return (this._bitField & 939524096) > 0;
		};

		Promise.prototype._isFollowing = function () {
		    return (this._bitField & 536870912) === 536870912;
		};

		Promise.prototype._setLength = function (len) {
		    this._bitField = (this._bitField & -131072) |
		        (len & 131071);
		};

		Promise.prototype._setFulfilled = function () {
		    this._bitField = this._bitField | 268435456;
		};

		Promise.prototype._setRejected = function () {
		    this._bitField = this._bitField | 134217728;
		};

		Promise.prototype._setFollowing = function () {
		    this._bitField = this._bitField | 536870912;
		};

		Promise.prototype._setIsFinal = function () {
		    this._bitField = this._bitField | 33554432;
		};

		Promise.prototype._isFinal = function () {
		    return (this._bitField & 33554432) > 0;
		};

		Promise.prototype._cancellable = function () {
		    return (this._bitField & 67108864) > 0;
		};

		Promise.prototype._setCancellable = function () {
		    this._bitField = this._bitField | 67108864;
		};

		Promise.prototype._unsetCancellable = function () {
		    this._bitField = this._bitField & (~67108864);
		};

		Promise.prototype._setIsMigrated = function () {
		    this._bitField = this._bitField | 4194304;
		};

		Promise.prototype._unsetIsMigrated = function () {
		    this._bitField = this._bitField & (~4194304);
		};

		Promise.prototype._isMigrated = function () {
		    return (this._bitField & 4194304) > 0;
		};

		Promise.prototype._receiverAt = function (index) {
		    var ret = index === 0
		        ? this._receiver0
		        : this[
		            index * 5 - 5 + 4];
		    if (ret === undefined && this._isBound()) {
		        return this._boundValue();
		    }
		    return ret;
		};

		Promise.prototype._promiseAt = function (index) {
		    return index === 0
		        ? this._promise0
		        : this[index * 5 - 5 + 3];
		};

		Promise.prototype._fulfillmentHandlerAt = function (index) {
		    return index === 0
		        ? this._fulfillmentHandler0
		        : this[index * 5 - 5 + 0];
		};

		Promise.prototype._rejectionHandlerAt = function (index) {
		    return index === 0
		        ? this._rejectionHandler0
		        : this[index * 5 - 5 + 1];
		};

		Promise.prototype._boundValue = function() {
		    var ret = this._boundTo;
		    if (ret !== undefined) {
		        if (ret instanceof Promise) {
		            if (ret.isFulfilled()) {
		                return ret.value();
		            } else {
		                return undefined;
		            }
		        }
		    }
		    return ret;
		};

		Promise.prototype._migrateCallbacks = function (follower, index) {
		    var fulfill = follower._fulfillmentHandlerAt(index);
		    var reject = follower._rejectionHandlerAt(index);
		    var progress = follower._progressHandlerAt(index);
		    var promise = follower._promiseAt(index);
		    var receiver = follower._receiverAt(index);
		    if (promise instanceof Promise) promise._setIsMigrated();
		    this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
		};

		Promise.prototype._addCallbacks = function (
		    fulfill,
		    reject,
		    progress,
		    promise,
		    receiver,
		    domain
		) {
		    var index = this._length();

		    if (index >= 131071 - 5) {
		        index = 0;
		        this._setLength(0);
		    }

		    if (index === 0) {
		        this._promise0 = promise;
		        if (receiver !== undefined) this._receiver0 = receiver;
		        if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
		            this._fulfillmentHandler0 =
		                domain === null ? fulfill : domain.bind(fulfill);
		        }
		        if (typeof reject === "function") {
		            this._rejectionHandler0 =
		                domain === null ? reject : domain.bind(reject);
		        }
		        if (typeof progress === "function") {
		            this._progressHandler0 =
		                domain === null ? progress : domain.bind(progress);
		        }
		    } else {
		        var base = index * 5 - 5;
		        this[base + 3] = promise;
		        this[base + 4] = receiver;
		        if (typeof fulfill === "function") {
		            this[base + 0] =
		                domain === null ? fulfill : domain.bind(fulfill);
		        }
		        if (typeof reject === "function") {
		            this[base + 1] =
		                domain === null ? reject : domain.bind(reject);
		        }
		        if (typeof progress === "function") {
		            this[base + 2] =
		                domain === null ? progress : domain.bind(progress);
		        }
		    }
		    this._setLength(index + 1);
		    return index;
		};

		Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
		    var index = this._length();

		    if (index >= 131071 - 5) {
		        index = 0;
		        this._setLength(0);
		    }
		    if (index === 0) {
		        this._promise0 = promiseSlotValue;
		        this._receiver0 = receiver;
		    } else {
		        var base = index * 5 - 5;
		        this[base + 3] = promiseSlotValue;
		        this[base + 4] = receiver;
		    }
		    this._setLength(index + 1);
		};

		Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
		    this._setProxyHandlers(promiseArray, index);
		};

		Promise.prototype._resolveCallback = function(value, shouldBind) {
		    if (this._isFollowingOrFulfilledOrRejected()) return;
		    if (value === this)
		        return this._rejectCallback(makeSelfResolutionError(), false, true);
		    var maybePromise = tryConvertToPromise(value, this);
		    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

		    var propagationFlags = 1 | (shouldBind ? 4 : 0);
		    this._propagateFrom(maybePromise, propagationFlags);
		    var promise = maybePromise._target();
		    if (promise._isPending()) {
		        var len = this._length();
		        for (var i = 0; i < len; ++i) {
		            promise._migrateCallbacks(this, i);
		        }
		        this._setFollowing();
		        this._setLength(0);
		        this._setFollowee(promise);
		    } else if (promise._isFulfilled()) {
		        this._fulfillUnchecked(promise._value());
		    } else {
		        this._rejectUnchecked(promise._reason(),
		            promise._getCarriedStackTrace());
		    }
		};

		Promise.prototype._rejectCallback =
		function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
		    if (!shouldNotMarkOriginatingFromRejection) {
		        util.markAsOriginatingFromRejection(reason);
		    }
		    var trace = util.ensureErrorObject(reason);
		    var hasStack = trace === reason;
		    this._attachExtraTrace(trace, synchronous ? hasStack : false);
		    this._reject(reason, hasStack ? undefined : trace);
		};

		Promise.prototype._resolveFromResolver = function (resolver) {
		    var promise = this;
		    this._captureStackTrace();
		    this._pushContext();
		    var synchronous = true;
		    var r = tryCatch(resolver)(function(value) {
		        if (promise === null) return;
		        promise._resolveCallback(value);
		        promise = null;
		    }, function (reason) {
		        if (promise === null) return;
		        promise._rejectCallback(reason, synchronous);
		        promise = null;
		    });
		    synchronous = false;
		    this._popContext();

		    if (r !== undefined && r === errorObj && promise !== null) {
		        promise._rejectCallback(r.e, true, true);
		        promise = null;
		    }
		};

		Promise.prototype._settlePromiseFromHandler = function (
		    handler, receiver, value, promise
		) {
		    if (promise._isRejected()) return;
		    promise._pushContext();
		    var x;
		    if (receiver === APPLY && !this._isRejected()) {
		        x = tryCatch(handler).apply(this._boundValue(), value);
		    } else {
		        x = tryCatch(handler).call(receiver, value);
		    }
		    promise._popContext();

		    if (x === errorObj || x === promise || x === NEXT_FILTER) {
		        var err = x === promise ? makeSelfResolutionError() : x.e;
		        promise._rejectCallback(err, false, true);
		    } else {
		        promise._resolveCallback(x);
		    }
		};

		Promise.prototype._target = function() {
		    var ret = this;
		    while (ret._isFollowing()) ret = ret._followee();
		    return ret;
		};

		Promise.prototype._followee = function() {
		    return this._rejectionHandler0;
		};

		Promise.prototype._setFollowee = function(promise) {
		    this._rejectionHandler0 = promise;
		};

		Promise.prototype._cleanValues = function () {
		    if (this._cancellable()) {
		        this._cancellationParent = undefined;
		    }
		};

		Promise.prototype._propagateFrom = function (parent, flags) {
		    if ((flags & 1) > 0 && parent._cancellable()) {
		        this._setCancellable();
		        this._cancellationParent = parent;
		    }
		    if ((flags & 4) > 0 && parent._isBound()) {
		        this._setBoundTo(parent._boundTo);
		    }
		};

		Promise.prototype._fulfill = function (value) {
		    if (this._isFollowingOrFulfilledOrRejected()) return;
		    this._fulfillUnchecked(value);
		};

		Promise.prototype._reject = function (reason, carriedStackTrace) {
		    if (this._isFollowingOrFulfilledOrRejected()) return;
		    this._rejectUnchecked(reason, carriedStackTrace);
		};

		Promise.prototype._settlePromiseAt = function (index) {
		    var promise = this._promiseAt(index);
		    var isPromise = promise instanceof Promise;

		    if (isPromise && promise._isMigrated()) {
		        promise._unsetIsMigrated();
		        return async.invoke(this._settlePromiseAt, this, index);
		    }
		    var handler = this._isFulfilled()
		        ? this._fulfillmentHandlerAt(index)
		        : this._rejectionHandlerAt(index);

		    var carriedStackTrace =
		        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
		    var value = this._settledValue;
		    var receiver = this._receiverAt(index);
		    this._clearCallbackDataAtIndex(index);

		    if (typeof handler === "function") {
		        if (!isPromise) {
		            handler.call(receiver, value, promise);
		        } else {
		            this._settlePromiseFromHandler(handler, receiver, value, promise);
		        }
		    } else if (receiver instanceof PromiseArray) {
		        if (!receiver._isResolved()) {
		            if (this._isFulfilled()) {
		                receiver._promiseFulfilled(value, promise);
		            }
		            else {
		                receiver._promiseRejected(value, promise);
		            }
		        }
		    } else if (isPromise) {
		        if (this._isFulfilled()) {
		            promise._fulfill(value);
		        } else {
		            promise._reject(value, carriedStackTrace);
		        }
		    }

		    if (index >= 4 && (index & 31) === 4)
		        async.invokeLater(this._setLength, this, 0);
		};

		Promise.prototype._clearCallbackDataAtIndex = function(index) {
		    if (index === 0) {
		        if (!this._isCarryingStackTrace()) {
		            this._fulfillmentHandler0 = undefined;
		        }
		        this._rejectionHandler0 =
		        this._progressHandler0 =
		        this._receiver0 =
		        this._promise0 = undefined;
		    } else {
		        var base = index * 5 - 5;
		        this[base + 3] =
		        this[base + 4] =
		        this[base + 0] =
		        this[base + 1] =
		        this[base + 2] = undefined;
		    }
		};

		Promise.prototype._isSettlePromisesQueued = function () {
		    return (this._bitField &
		            -1073741824) === -1073741824;
		};

		Promise.prototype._setSettlePromisesQueued = function () {
		    this._bitField = this._bitField | -1073741824;
		};

		Promise.prototype._unsetSettlePromisesQueued = function () {
		    this._bitField = this._bitField & (~-1073741824);
		};

		Promise.prototype._queueSettlePromises = function() {
		    async.settlePromises(this);
		    this._setSettlePromisesQueued();
		};

		Promise.prototype._fulfillUnchecked = function (value) {
		    if (value === this) {
		        var err = makeSelfResolutionError();
		        this._attachExtraTrace(err);
		        return this._rejectUnchecked(err, undefined);
		    }
		    this._setFulfilled();
		    this._settledValue = value;
		    this._cleanValues();

		    if (this._length() > 0) {
		        this._queueSettlePromises();
		    }
		};

		Promise.prototype._rejectUncheckedCheckError = function (reason) {
		    var trace = util.ensureErrorObject(reason);
		    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
		};

		Promise.prototype._rejectUnchecked = function (reason, trace) {
		    if (reason === this) {
		        var err = makeSelfResolutionError();
		        this._attachExtraTrace(err);
		        return this._rejectUnchecked(err);
		    }
		    this._setRejected();
		    this._settledValue = reason;
		    this._cleanValues();

		    if (this._isFinal()) {
		        async.throwLater(function(e) {
		            if ("stack" in e) {
		                async.invokeFirst(
		                    CapturedTrace.unhandledRejection, undefined, e);
		            }
		            throw e;
		        }, trace === undefined ? reason : trace);
		        return;
		    }

		    if (trace !== undefined && trace !== reason) {
		        this._setCarriedStackTrace(trace);
		    }

		    if (this._length() > 0) {
		        this._queueSettlePromises();
		    } else {
		        this._ensurePossibleRejectionHandled();
		    }
		};

		Promise.prototype._settlePromises = function () {
		    this._unsetSettlePromisesQueued();
		    var len = this._length();
		    for (var i = 0; i < len; i++) {
		        this._settlePromiseAt(i);
		    }
		};

		util.notEnumerableProp(Promise,
		                       "_makeSelfResolutionError",
		                       makeSelfResolutionError);

		__webpack_require__(18)(Promise, PromiseArray);
		__webpack_require__(19)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
		__webpack_require__(20)(Promise, INTERNAL, tryConvertToPromise);
		__webpack_require__(21)(Promise, NEXT_FILTER, tryConvertToPromise);
		__webpack_require__(22)(Promise);
		__webpack_require__(23)(Promise);
		__webpack_require__(24)(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
		Promise.Promise = Promise;
		__webpack_require__(25)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
		__webpack_require__(26)(Promise);
		__webpack_require__(27)(Promise, apiRejection, tryConvertToPromise, createContext);
		__webpack_require__(28)(Promise, apiRejection, INTERNAL, tryConvertToPromise);
		__webpack_require__(29)(Promise);
		__webpack_require__(30)(Promise);
		__webpack_require__(31)(Promise, PromiseArray, tryConvertToPromise, apiRejection);
		__webpack_require__(32)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
		__webpack_require__(33)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
		__webpack_require__(34)(Promise, PromiseArray);
		__webpack_require__(35)(Promise, PromiseArray, apiRejection);
		__webpack_require__(36)(Promise, INTERNAL);
		__webpack_require__(37)(Promise);
		__webpack_require__(38)(Promise, INTERNAL);
		__webpack_require__(39)(Promise, INTERNAL);
		__webpack_require__(40)(Promise, INTERNAL);

		    util.toFastProperties(Promise);
		    util.toFastProperties(Promise.prototype);
		    function fillTypes(value) {
		        var p = new Promise(INTERNAL);
		        p._fulfillmentHandler0 = value;
		        p._rejectionHandler0 = value;
		        p._progressHandler0 = value;
		        p._promise0 = value;
		        p._receiver0 = value;
		        p._settledValue = value;
		    }
		    // Complete slack tracking, opt out of field-type tracking and
		    // stabilize map
		    fillTypes({a: 1});
		    fillTypes({b: 2});
		    fillTypes({c: 3});
		    fillTypes(1);
		    fillTypes(function(){});
		    fillTypes(undefined);
		    fillTypes(false);
		    fillTypes(new Promise(INTERNAL));
		    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);
		    return Promise;

		};


	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var es5 = __webpack_require__(6);
		var canEvaluate = typeof navigator == "undefined";
		var haveGetters = (function(){
		    try {
		        var o = {};
		        es5.defineProperty(o, "f", {
		            get: function () {
		                return 3;
		            }
		        });
		        return o.f === 3;
		    }
		    catch (e) {
		        return false;
		    }

		})();

		var errorObj = {e: {}};
		var tryCatchTarget;
		function tryCatcher() {
		    try {
		        var target = tryCatchTarget;
		        tryCatchTarget = null;
		        return target.apply(this, arguments);
		    } catch (e) {
		        errorObj.e = e;
		        return errorObj;
		    }
		}
		function tryCatch(fn) {
		    tryCatchTarget = fn;
		    return tryCatcher;
		}

		var inherits = function(Child, Parent) {
		    var hasProp = {}.hasOwnProperty;

		    function T() {
		        this.constructor = Child;
		        this.constructor$ = Parent;
		        for (var propertyName in Parent.prototype) {
		            if (hasProp.call(Parent.prototype, propertyName) &&
		                propertyName.charAt(propertyName.length-1) !== "$"
		           ) {
		                this[propertyName + "$"] = Parent.prototype[propertyName];
		            }
		        }
		    }
		    T.prototype = Parent.prototype;
		    Child.prototype = new T();
		    return Child.prototype;
		};


		function isPrimitive(val) {
		    return val == null || val === true || val === false ||
		        typeof val === "string" || typeof val === "number";

		}

		function isObject(value) {
		    return !isPrimitive(value);
		}

		function maybeWrapAsError(maybeError) {
		    if (!isPrimitive(maybeError)) return maybeError;

		    return new Error(safeToString(maybeError));
		}

		function withAppended(target, appendee) {
		    var len = target.length;
		    var ret = new Array(len + 1);
		    var i;
		    for (i = 0; i < len; ++i) {
		        ret[i] = target[i];
		    }
		    ret[i] = appendee;
		    return ret;
		}

		function getDataPropertyOrDefault(obj, key, defaultValue) {
		    if (es5.isES5) {
		        var desc = Object.getOwnPropertyDescriptor(obj, key);

		        if (desc != null) {
		            return desc.get == null && desc.set == null
		                    ? desc.value
		                    : defaultValue;
		        }
		    } else {
		        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
		    }
		}

		function notEnumerableProp(obj, name, value) {
		    if (isPrimitive(obj)) return obj;
		    var descriptor = {
		        value: value,
		        configurable: true,
		        enumerable: false,
		        writable: true
		    };
		    es5.defineProperty(obj, name, descriptor);
		    return obj;
		}

		function thrower(r) {
		    throw r;
		}

		var inheritedDataKeys = (function() {
		    var excludedPrototypes = [
		        Array.prototype,
		        Object.prototype,
		        Function.prototype
		    ];

		    var isExcludedProto = function(val) {
		        for (var i = 0; i < excludedPrototypes.length; ++i) {
		            if (excludedPrototypes[i] === val) {
		                return true;
		            }
		        }
		        return false;
		    };

		    if (es5.isES5) {
		        var getKeys = Object.getOwnPropertyNames;
		        return function(obj) {
		            var ret = [];
		            var visitedKeys = Object.create(null);
		            while (obj != null && !isExcludedProto(obj)) {
		                var keys;
		                try {
		                    keys = getKeys(obj);
		                } catch (e) {
		                    return ret;
		                }
		                for (var i = 0; i < keys.length; ++i) {
		                    var key = keys[i];
		                    if (visitedKeys[key]) continue;
		                    visitedKeys[key] = true;
		                    var desc = Object.getOwnPropertyDescriptor(obj, key);
		                    if (desc != null && desc.get == null && desc.set == null) {
		                        ret.push(key);
		                    }
		                }
		                obj = es5.getPrototypeOf(obj);
		            }
		            return ret;
		        };
		    } else {
		        var hasProp = {}.hasOwnProperty;
		        return function(obj) {
		            if (isExcludedProto(obj)) return [];
		            var ret = [];

		            /*jshint forin:false */
		            enumeration: for (var key in obj) {
		                if (hasProp.call(obj, key)) {
		                    ret.push(key);
		                } else {
		                    for (var i = 0; i < excludedPrototypes.length; ++i) {
		                        if (hasProp.call(excludedPrototypes[i], key)) {
		                            continue enumeration;
		                        }
		                    }
		                    ret.push(key);
		                }
		            }
		            return ret;
		        };
		    }

		})();

		var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
		function isClass(fn) {
		    try {
		        if (typeof fn === "function") {
		            var keys = es5.names(fn.prototype);

		            var hasMethods = es5.isES5 && keys.length > 1;
		            var hasMethodsOtherThanConstructor = keys.length > 0 &&
		                !(keys.length === 1 && keys[0] === "constructor");
		            var hasThisAssignmentAndStaticMethods =
		                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

		            if (hasMethods || hasMethodsOtherThanConstructor ||
		                hasThisAssignmentAndStaticMethods) {
		                return true;
		            }
		        }
		        return false;
		    } catch (e) {
		        return false;
		    }
		}

		function toFastProperties(obj) {
		    /*jshint -W027,-W055,-W031*/
		    function f() {}
		    f.prototype = obj;
		    var l = 8;
		    while (l--) new f();
		    return obj;
		    eval(obj);
		}

		var rident = /^[a-z$_][a-z$_0-9]*$/i;
		function isIdentifier(str) {
		    return rident.test(str);
		}

		function filledRange(count, prefix, suffix) {
		    var ret = new Array(count);
		    for(var i = 0; i < count; ++i) {
		        ret[i] = prefix + i + suffix;
		    }
		    return ret;
		}

		function safeToString(obj) {
		    try {
		        return obj + "";
		    } catch (e) {
		        return "[no string representation]";
		    }
		}

		function markAsOriginatingFromRejection(e) {
		    try {
		        notEnumerableProp(e, "isOperational", true);
		    }
		    catch(ignore) {}
		}

		function originatesFromRejection(e) {
		    if (e == null) return false;
		    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
		        e["isOperational"] === true);
		}

		function canAttachTrace(obj) {
		    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
		}

		var ensureErrorObject = (function() {
		    if (!("stack" in new Error())) {
		        return function(value) {
		            if (canAttachTrace(value)) return value;
		            try {throw new Error(safeToString(value));}
		            catch(err) {return err;}
		        };
		    } else {
		        return function(value) {
		            if (canAttachTrace(value)) return value;
		            return new Error(safeToString(value));
		        };
		    }
		})();

		function classString(obj) {
		    return {}.toString.call(obj);
		}

		function copyDescriptors(from, to, filter) {
		    var keys = es5.names(from);
		    for (var i = 0; i < keys.length; ++i) {
		        var key = keys[i];
		        if (filter(key)) {
		            try {
		                es5.defineProperty(to, key, es5.getDescriptor(from, key));
		            } catch (ignore) {}
		        }
		    }
		}

		var ret = {
		    isClass: isClass,
		    isIdentifier: isIdentifier,
		    inheritedDataKeys: inheritedDataKeys,
		    getDataPropertyOrDefault: getDataPropertyOrDefault,
		    thrower: thrower,
		    isArray: es5.isArray,
		    haveGetters: haveGetters,
		    notEnumerableProp: notEnumerableProp,
		    isPrimitive: isPrimitive,
		    isObject: isObject,
		    canEvaluate: canEvaluate,
		    errorObj: errorObj,
		    tryCatch: tryCatch,
		    inherits: inherits,
		    withAppended: withAppended,
		    maybeWrapAsError: maybeWrapAsError,
		    toFastProperties: toFastProperties,
		    filledRange: filledRange,
		    toString: safeToString,
		    canAttachTrace: canAttachTrace,
		    ensureErrorObject: ensureErrorObject,
		    originatesFromRejection: originatesFromRejection,
		    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
		    classString: classString,
		    copyDescriptors: copyDescriptors,
		    hasDevTools: typeof chrome !== "undefined" && chrome &&
		                 typeof chrome.loadTimes === "function",
		    isNode: typeof process !== "undefined" &&
		        classString(process).toLowerCase() === "[object process]"
		};
		ret.isRecentNode = ret.isNode && (function() {
		    var version = process.versions.node.split(".").map(Number);
		    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
		})();

		if (ret.isNode) ret.toFastProperties(process);

		try {throw new Error(); } catch (e) {ret.lastLineError = e;}
		module.exports = ret;


	/***/ },
	/* 6 */
	/***/ function(module, exports) {

		var isES5 = (function(){
		    "use strict";
		    return this === undefined;
		})();

		if (isES5) {
		    module.exports = {
		        freeze: Object.freeze,
		        defineProperty: Object.defineProperty,
		        getDescriptor: Object.getOwnPropertyDescriptor,
		        keys: Object.keys,
		        names: Object.getOwnPropertyNames,
		        getPrototypeOf: Object.getPrototypeOf,
		        isArray: Array.isArray,
		        isES5: isES5,
		        propertyIsWritable: function(obj, prop) {
		            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
		            return !!(!descriptor || descriptor.writable || descriptor.set);
		        }
		    };
		} else {
		    var has = {}.hasOwnProperty;
		    var str = {}.toString;
		    var proto = {}.constructor.prototype;

		    var ObjectKeys = function (o) {
		        var ret = [];
		        for (var key in o) {
		            if (has.call(o, key)) {
		                ret.push(key);
		            }
		        }
		        return ret;
		    };

		    var ObjectGetDescriptor = function(o, key) {
		        return {value: o[key]};
		    };

		    var ObjectDefineProperty = function (o, key, desc) {
		        o[key] = desc.value;
		        return o;
		    };

		    var ObjectFreeze = function (obj) {
		        return obj;
		    };

		    var ObjectGetPrototypeOf = function (obj) {
		        try {
		            return Object(obj).constructor.prototype;
		        }
		        catch (e) {
		            return proto;
		        }
		    };

		    var ArrayIsArray = function (obj) {
		        try {
		            return str.call(obj) === "[object Array]";
		        }
		        catch(e) {
		            return false;
		        }
		    };

		    module.exports = {
		        isArray: ArrayIsArray,
		        keys: ObjectKeys,
		        names: ObjectKeys,
		        defineProperty: ObjectDefineProperty,
		        getDescriptor: ObjectGetDescriptor,
		        freeze: ObjectFreeze,
		        getPrototypeOf: ObjectGetPrototypeOf,
		        isES5: isES5,
		        propertyIsWritable: function() {
		            return true;
		        }
		    };
		}


	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var firstLineError;
		try {throw new Error(); } catch (e) {firstLineError = e;}
		var schedule = __webpack_require__(8);
		var Queue = __webpack_require__(9);
		var util = __webpack_require__(5);

		function Async() {
		    this._isTickUsed = false;
		    this._lateQueue = new Queue(16);
		    this._normalQueue = new Queue(16);
		    this._trampolineEnabled = true;
		    var self = this;
		    this.drainQueues = function () {
		        self._drainQueues();
		    };
		    this._schedule =
		        schedule.isStatic ? schedule(this.drainQueues) : schedule;
		}

		Async.prototype.disableTrampolineIfNecessary = function() {
		    if (util.hasDevTools) {
		        this._trampolineEnabled = false;
		    }
		};

		Async.prototype.enableTrampoline = function() {
		    if (!this._trampolineEnabled) {
		        this._trampolineEnabled = true;
		        this._schedule = function(fn) {
		            setTimeout(fn, 0);
		        };
		    }
		};

		Async.prototype.haveItemsQueued = function () {
		    return this._normalQueue.length() > 0;
		};

		Async.prototype.throwLater = function(fn, arg) {
		    if (arguments.length === 1) {
		        arg = fn;
		        fn = function () { throw arg; };
		    }
		    if (typeof setTimeout !== "undefined") {
		        setTimeout(function() {
		            fn(arg);
		        }, 0);
		    } else try {
		        this._schedule(function() {
		            fn(arg);
		        });
		    } catch (e) {
		        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
		    }
		};

		function AsyncInvokeLater(fn, receiver, arg) {
		    this._lateQueue.push(fn, receiver, arg);
		    this._queueTick();
		}

		function AsyncInvoke(fn, receiver, arg) {
		    this._normalQueue.push(fn, receiver, arg);
		    this._queueTick();
		}

		function AsyncSettlePromises(promise) {
		    this._normalQueue._pushOne(promise);
		    this._queueTick();
		}

		if (!util.hasDevTools) {
		    Async.prototype.invokeLater = AsyncInvokeLater;
		    Async.prototype.invoke = AsyncInvoke;
		    Async.prototype.settlePromises = AsyncSettlePromises;
		} else {
		    if (schedule.isStatic) {
		        schedule = function(fn) { setTimeout(fn, 0); };
		    }
		    Async.prototype.invokeLater = function (fn, receiver, arg) {
		        if (this._trampolineEnabled) {
		            AsyncInvokeLater.call(this, fn, receiver, arg);
		        } else {
		            this._schedule(function() {
		                setTimeout(function() {
		                    fn.call(receiver, arg);
		                }, 100);
		            });
		        }
		    };

		    Async.prototype.invoke = function (fn, receiver, arg) {
		        if (this._trampolineEnabled) {
		            AsyncInvoke.call(this, fn, receiver, arg);
		        } else {
		            this._schedule(function() {
		                fn.call(receiver, arg);
		            });
		        }
		    };

		    Async.prototype.settlePromises = function(promise) {
		        if (this._trampolineEnabled) {
		            AsyncSettlePromises.call(this, promise);
		        } else {
		            this._schedule(function() {
		                promise._settlePromises();
		            });
		        }
		    };
		}

		Async.prototype.invokeFirst = function (fn, receiver, arg) {
		    this._normalQueue.unshift(fn, receiver, arg);
		    this._queueTick();
		};

		Async.prototype._drainQueue = function(queue) {
		    while (queue.length() > 0) {
		        var fn = queue.shift();
		        if (typeof fn !== "function") {
		            fn._settlePromises();
		            continue;
		        }
		        var receiver = queue.shift();
		        var arg = queue.shift();
		        fn.call(receiver, arg);
		    }
		};

		Async.prototype._drainQueues = function () {
		    this._drainQueue(this._normalQueue);
		    this._reset();
		    this._drainQueue(this._lateQueue);
		};

		Async.prototype._queueTick = function () {
		    if (!this._isTickUsed) {
		        this._isTickUsed = true;
		        this._schedule(this.drainQueues);
		    }
		};

		Async.prototype._reset = function () {
		    this._isTickUsed = false;
		};

		module.exports = new Async();
		module.exports.firstLineError = firstLineError;


	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var schedule;
		var util = __webpack_require__(5);
		var noAsyncScheduler = function() {
		    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
		};
		if (util.isNode && typeof MutationObserver === "undefined") {
		    var GlobalSetImmediate = global.setImmediate;
		    var ProcessNextTick = process.nextTick;
		    schedule = util.isRecentNode
		                ? function(fn) { GlobalSetImmediate.call(global, fn); }
		                : function(fn) { ProcessNextTick.call(process, fn); };
		} else if ((typeof MutationObserver !== "undefined") &&
		          !(typeof window !== "undefined" &&
		            window.navigator &&
		            window.navigator.standalone)) {
		    schedule = function(fn) {
		        var div = document.createElement("div");
		        var observer = new MutationObserver(fn);
		        observer.observe(div, {attributes: true});
		        return function() { div.classList.toggle("foo"); };
		    };
		    schedule.isStatic = true;
		} else if (typeof setImmediate !== "undefined") {
		    schedule = function (fn) {
		        setImmediate(fn);
		    };
		} else if (typeof setTimeout !== "undefined") {
		    schedule = function (fn) {
		        setTimeout(fn, 0);
		    };
		} else {
		    schedule = noAsyncScheduler;
		}
		module.exports = schedule;


	/***/ },
	/* 9 */
	/***/ function(module, exports) {

		"use strict";
		function arrayMove(src, srcIndex, dst, dstIndex, len) {
		    for (var j = 0; j < len; ++j) {
		        dst[j + dstIndex] = src[j + srcIndex];
		        src[j + srcIndex] = void 0;
		    }
		}

		function Queue(capacity) {
		    this._capacity = capacity;
		    this._length = 0;
		    this._front = 0;
		}

		Queue.prototype._willBeOverCapacity = function (size) {
		    return this._capacity < size;
		};

		Queue.prototype._pushOne = function (arg) {
		    var length = this.length();
		    this._checkCapacity(length + 1);
		    var i = (this._front + length) & (this._capacity - 1);
		    this[i] = arg;
		    this._length = length + 1;
		};

		Queue.prototype._unshiftOne = function(value) {
		    var capacity = this._capacity;
		    this._checkCapacity(this.length() + 1);
		    var front = this._front;
		    var i = (((( front - 1 ) &
		                    ( capacity - 1) ) ^ capacity ) - capacity );
		    this[i] = value;
		    this._front = i;
		    this._length = this.length() + 1;
		};

		Queue.prototype.unshift = function(fn, receiver, arg) {
		    this._unshiftOne(arg);
		    this._unshiftOne(receiver);
		    this._unshiftOne(fn);
		};

		Queue.prototype.push = function (fn, receiver, arg) {
		    var length = this.length() + 3;
		    if (this._willBeOverCapacity(length)) {
		        this._pushOne(fn);
		        this._pushOne(receiver);
		        this._pushOne(arg);
		        return;
		    }
		    var j = this._front + length - 3;
		    this._checkCapacity(length);
		    var wrapMask = this._capacity - 1;
		    this[(j + 0) & wrapMask] = fn;
		    this[(j + 1) & wrapMask] = receiver;
		    this[(j + 2) & wrapMask] = arg;
		    this._length = length;
		};

		Queue.prototype.shift = function () {
		    var front = this._front,
		        ret = this[front];

		    this[front] = undefined;
		    this._front = (front + 1) & (this._capacity - 1);
		    this._length--;
		    return ret;
		};

		Queue.prototype.length = function () {
		    return this._length;
		};

		Queue.prototype._checkCapacity = function (size) {
		    if (this._capacity < size) {
		        this._resizeTo(this._capacity << 1);
		    }
		};

		Queue.prototype._resizeTo = function (capacity) {
		    var oldCapacity = this._capacity;
		    this._capacity = capacity;
		    var front = this._front;
		    var length = this._length;
		    var moveItemsCount = (front + length) & (oldCapacity - 1);
		    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
		};

		module.exports = Queue;


	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var es5 = __webpack_require__(6);
		var Objectfreeze = es5.freeze;
		var util = __webpack_require__(5);
		var inherits = util.inherits;
		var notEnumerableProp = util.notEnumerableProp;

		function subError(nameProperty, defaultMessage) {
		    function SubError(message) {
		        if (!(this instanceof SubError)) return new SubError(message);
		        notEnumerableProp(this, "message",
		            typeof message === "string" ? message : defaultMessage);
		        notEnumerableProp(this, "name", nameProperty);
		        if (Error.captureStackTrace) {
		            Error.captureStackTrace(this, this.constructor);
		        } else {
		            Error.call(this);
		        }
		    }
		    inherits(SubError, Error);
		    return SubError;
		}

		var _TypeError, _RangeError;
		var Warning = subError("Warning", "warning");
		var CancellationError = subError("CancellationError", "cancellation error");
		var TimeoutError = subError("TimeoutError", "timeout error");
		var AggregateError = subError("AggregateError", "aggregate error");
		try {
		    _TypeError = TypeError;
		    _RangeError = RangeError;
		} catch(e) {
		    _TypeError = subError("TypeError", "type error");
		    _RangeError = subError("RangeError", "range error");
		}

		var methods = ("join pop push shift unshift slice filter forEach some " +
		    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

		for (var i = 0; i < methods.length; ++i) {
		    if (typeof Array.prototype[methods[i]] === "function") {
		        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
		    }
		}

		es5.defineProperty(AggregateError.prototype, "length", {
		    value: 0,
		    configurable: false,
		    writable: true,
		    enumerable: true
		});
		AggregateError.prototype["isOperational"] = true;
		var level = 0;
		AggregateError.prototype.toString = function() {
		    var indent = Array(level * 4 + 1).join(" ");
		    var ret = "\n" + indent + "AggregateError of:" + "\n";
		    level++;
		    indent = Array(level * 4 + 1).join(" ");
		    for (var i = 0; i < this.length; ++i) {
		        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
		        var lines = str.split("\n");
		        for (var j = 0; j < lines.length; ++j) {
		            lines[j] = indent + lines[j];
		        }
		        str = lines.join("\n");
		        ret += str + "\n";
		    }
		    level--;
		    return ret;
		};

		function OperationalError(message) {
		    if (!(this instanceof OperationalError))
		        return new OperationalError(message);
		    notEnumerableProp(this, "name", "OperationalError");
		    notEnumerableProp(this, "message", message);
		    this.cause = message;
		    this["isOperational"] = true;

		    if (message instanceof Error) {
		        notEnumerableProp(this, "message", message.message);
		        notEnumerableProp(this, "stack", message.stack);
		    } else if (Error.captureStackTrace) {
		        Error.captureStackTrace(this, this.constructor);
		    }

		}
		inherits(OperationalError, Error);

		var errorTypes = Error["__BluebirdErrorTypes__"];
		if (!errorTypes) {
		    errorTypes = Objectfreeze({
		        CancellationError: CancellationError,
		        TimeoutError: TimeoutError,
		        OperationalError: OperationalError,
		        RejectionError: OperationalError,
		        AggregateError: AggregateError
		    });
		    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
		}

		module.exports = {
		    Error: Error,
		    TypeError: _TypeError,
		    RangeError: _RangeError,
		    CancellationError: errorTypes.CancellationError,
		    OperationalError: errorTypes.OperationalError,
		    TimeoutError: errorTypes.TimeoutError,
		    AggregateError: errorTypes.AggregateError,
		    Warning: Warning
		};


	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(Promise, INTERNAL) {
		var util = __webpack_require__(5);
		var errorObj = util.errorObj;
		var isObject = util.isObject;

		function tryConvertToPromise(obj, context) {
		    if (isObject(obj)) {
		        if (obj instanceof Promise) {
		            return obj;
		        }
		        else if (isAnyBluebirdPromise(obj)) {
		            var ret = new Promise(INTERNAL);
		            obj._then(
		                ret._fulfillUnchecked,
		                ret._rejectUncheckedCheckError,
		                ret._progressUnchecked,
		                ret,
		                null
		            );
		            return ret;
		        }
		        var then = util.tryCatch(getThen)(obj);
		        if (then === errorObj) {
		            if (context) context._pushContext();
		            var ret = Promise.reject(then.e);
		            if (context) context._popContext();
		            return ret;
		        } else if (typeof then === "function") {
		            return doThenable(obj, then, context);
		        }
		    }
		    return obj;
		}

		function getThen(obj) {
		    return obj.then;
		}

		var hasProp = {}.hasOwnProperty;
		function isAnyBluebirdPromise(obj) {
		    return hasProp.call(obj, "_promise0");
		}

		function doThenable(x, then, context) {
		    var promise = new Promise(INTERNAL);
		    var ret = promise;
		    if (context) context._pushContext();
		    promise._captureStackTrace();
		    if (context) context._popContext();
		    var synchronous = true;
		    var result = util.tryCatch(then).call(x,
		                                        resolveFromThenable,
		                                        rejectFromThenable,
		                                        progressFromThenable);
		    synchronous = false;
		    if (promise && result === errorObj) {
		        promise._rejectCallback(result.e, true, true);
		        promise = null;
		    }

		    function resolveFromThenable(value) {
		        if (!promise) return;
		        promise._resolveCallback(value);
		        promise = null;
		    }

		    function rejectFromThenable(reason) {
		        if (!promise) return;
		        promise._rejectCallback(reason, synchronous, true);
		        promise = null;
		    }

		    function progressFromThenable(value) {
		        if (!promise) return;
		        if (typeof promise._progress === "function") {
		            promise._progress(value);
		        }
		    }
		    return ret;
		}

		return tryConvertToPromise;
		};


	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(Promise, INTERNAL, tryConvertToPromise,
		    apiRejection) {
		var util = __webpack_require__(5);
		var isArray = util.isArray;

		function toResolutionValue(val) {
		    switch(val) {
		    case -2: return [];
		    case -3: return {};
		    }
		}

		function PromiseArray(values) {
		    var promise = this._promise = new Promise(INTERNAL);
		    var parent;
		    if (values instanceof Promise) {
		        parent = values;
		        promise._propagateFrom(parent, 1 | 4);
		    }
		    this._values = values;
		    this._length = 0;
		    this._totalResolved = 0;
		    this._init(undefined, -2);
		}
		PromiseArray.prototype.length = function () {
		    return this._length;
		};

		PromiseArray.prototype.promise = function () {
		    return this._promise;
		};

		PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
		    var values = tryConvertToPromise(this._values, this._promise);
		    if (values instanceof Promise) {
		        values = values._target();
		        this._values = values;
		        if (values._isFulfilled()) {
		            values = values._value();
		            if (!isArray(values)) {
		                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
		                this.__hardReject__(err);
		                return;
		            }
		        } else if (values._isPending()) {
		            values._then(
		                init,
		                this._reject,
		                undefined,
		                this,
		                resolveValueIfEmpty
		           );
		            return;
		        } else {
		            this._reject(values._reason());
		            return;
		        }
		    } else if (!isArray(values)) {
		        this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
		        return;
		    }

		    if (values.length === 0) {
		        if (resolveValueIfEmpty === -5) {
		            this._resolveEmptyArray();
		        }
		        else {
		            this._resolve(toResolutionValue(resolveValueIfEmpty));
		        }
		        return;
		    }
		    var len = this.getActualLength(values.length);
		    this._length = len;
		    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
		    var promise = this._promise;
		    for (var i = 0; i < len; ++i) {
		        var isResolved = this._isResolved();
		        var maybePromise = tryConvertToPromise(values[i], promise);
		        if (maybePromise instanceof Promise) {
		            maybePromise = maybePromise._target();
		            if (isResolved) {
		                maybePromise._ignoreRejections();
		            } else if (maybePromise._isPending()) {
		                maybePromise._proxyPromiseArray(this, i);
		            } else if (maybePromise._isFulfilled()) {
		                this._promiseFulfilled(maybePromise._value(), i);
		            } else {
		                this._promiseRejected(maybePromise._reason(), i);
		            }
		        } else if (!isResolved) {
		            this._promiseFulfilled(maybePromise, i);
		        }
		    }
		};

		PromiseArray.prototype._isResolved = function () {
		    return this._values === null;
		};

		PromiseArray.prototype._resolve = function (value) {
		    this._values = null;
		    this._promise._fulfill(value);
		};

		PromiseArray.prototype.__hardReject__ =
		PromiseArray.prototype._reject = function (reason) {
		    this._values = null;
		    this._promise._rejectCallback(reason, false, true);
		};

		PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
		    this._promise._progress({
		        index: index,
		        value: progressValue
		    });
		};


		PromiseArray.prototype._promiseFulfilled = function (value, index) {
		    this._values[index] = value;
		    var totalResolved = ++this._totalResolved;
		    if (totalResolved >= this._length) {
		        this._resolve(this._values);
		    }
		};

		PromiseArray.prototype._promiseRejected = function (reason, index) {
		    this._totalResolved++;
		    this._reject(reason);
		};

		PromiseArray.prototype.shouldCopyValues = function () {
		    return true;
		};

		PromiseArray.prototype.getActualLength = function (len) {
		    return len;
		};

		return PromiseArray;
		};


	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function() {
		var async = __webpack_require__(7);
		var util = __webpack_require__(5);
		var bluebirdFramePattern =
		    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
		var stackFramePattern = null;
		var formatStack = null;
		var indentStackFrames = false;
		var warn;

		function CapturedTrace(parent) {
		    this._parent = parent;
		    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
		    captureStackTrace(this, CapturedTrace);
		    if (length > 32) this.uncycle();
		}
		util.inherits(CapturedTrace, Error);

		CapturedTrace.prototype.uncycle = function() {
		    var length = this._length;
		    if (length < 2) return;
		    var nodes = [];
		    var stackToIndex = {};

		    for (var i = 0, node = this; node !== undefined; ++i) {
		        nodes.push(node);
		        node = node._parent;
		    }
		    length = this._length = i;
		    for (var i = length - 1; i >= 0; --i) {
		        var stack = nodes[i].stack;
		        if (stackToIndex[stack] === undefined) {
		            stackToIndex[stack] = i;
		        }
		    }
		    for (var i = 0; i < length; ++i) {
		        var currentStack = nodes[i].stack;
		        var index = stackToIndex[currentStack];
		        if (index !== undefined && index !== i) {
		            if (index > 0) {
		                nodes[index - 1]._parent = undefined;
		                nodes[index - 1]._length = 1;
		            }
		            nodes[i]._parent = undefined;
		            nodes[i]._length = 1;
		            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

		            if (index < length - 1) {
		                cycleEdgeNode._parent = nodes[index + 1];
		                cycleEdgeNode._parent.uncycle();
		                cycleEdgeNode._length =
		                    cycleEdgeNode._parent._length + 1;
		            } else {
		                cycleEdgeNode._parent = undefined;
		                cycleEdgeNode._length = 1;
		            }
		            var currentChildLength = cycleEdgeNode._length + 1;
		            for (var j = i - 2; j >= 0; --j) {
		                nodes[j]._length = currentChildLength;
		                currentChildLength++;
		            }
		            return;
		        }
		    }
		};

		CapturedTrace.prototype.parent = function() {
		    return this._parent;
		};

		CapturedTrace.prototype.hasParent = function() {
		    return this._parent !== undefined;
		};

		CapturedTrace.prototype.attachExtraTrace = function(error) {
		    if (error.__stackCleaned__) return;
		    this.uncycle();
		    var parsed = CapturedTrace.parseStackAndMessage(error);
		    var message = parsed.message;
		    var stacks = [parsed.stack];

		    var trace = this;
		    while (trace !== undefined) {
		        stacks.push(cleanStack(trace.stack.split("\n")));
		        trace = trace._parent;
		    }
		    removeCommonRoots(stacks);
		    removeDuplicateOrEmptyJumps(stacks);
		    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
		    util.notEnumerableProp(error, "__stackCleaned__", true);
		};

		function reconstructStack(message, stacks) {
		    for (var i = 0; i < stacks.length - 1; ++i) {
		        stacks[i].push("From previous event:");
		        stacks[i] = stacks[i].join("\n");
		    }
		    if (i < stacks.length) {
		        stacks[i] = stacks[i].join("\n");
		    }
		    return message + "\n" + stacks.join("\n");
		}

		function removeDuplicateOrEmptyJumps(stacks) {
		    for (var i = 0; i < stacks.length; ++i) {
		        if (stacks[i].length === 0 ||
		            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
		            stacks.splice(i, 1);
		            i--;
		        }
		    }
		}

		function removeCommonRoots(stacks) {
		    var current = stacks[0];
		    for (var i = 1; i < stacks.length; ++i) {
		        var prev = stacks[i];
		        var currentLastIndex = current.length - 1;
		        var currentLastLine = current[currentLastIndex];
		        var commonRootMeetPoint = -1;

		        for (var j = prev.length - 1; j >= 0; --j) {
		            if (prev[j] === currentLastLine) {
		                commonRootMeetPoint = j;
		                break;
		            }
		        }

		        for (var j = commonRootMeetPoint; j >= 0; --j) {
		            var line = prev[j];
		            if (current[currentLastIndex] === line) {
		                current.pop();
		                currentLastIndex--;
		            } else {
		                break;
		            }
		        }
		        current = prev;
		    }
		}

		function cleanStack(stack) {
		    var ret = [];
		    for (var i = 0; i < stack.length; ++i) {
		        var line = stack[i];
		        var isTraceLine = stackFramePattern.test(line) ||
		            "    (No stack trace)" === line;
		        var isInternalFrame = isTraceLine && shouldIgnore(line);
		        if (isTraceLine && !isInternalFrame) {
		            if (indentStackFrames && line.charAt(0) !== " ") {
		                line = "    " + line;
		            }
		            ret.push(line);
		        }
		    }
		    return ret;
		}

		function stackFramesAsArray(error) {
		    var stack = error.stack.replace(/\s+$/g, "").split("\n");
		    for (var i = 0; i < stack.length; ++i) {
		        var line = stack[i];
		        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
		            break;
		        }
		    }
		    if (i > 0) {
		        stack = stack.slice(i);
		    }
		    return stack;
		}

		CapturedTrace.parseStackAndMessage = function(error) {
		    var stack = error.stack;
		    var message = error.toString();
		    stack = typeof stack === "string" && stack.length > 0
		                ? stackFramesAsArray(error) : ["    (No stack trace)"];
		    return {
		        message: message,
		        stack: cleanStack(stack)
		    };
		};

		CapturedTrace.formatAndLogError = function(error, title) {
		    if (typeof console !== "undefined") {
		        var message;
		        if (typeof error === "object" || typeof error === "function") {
		            var stack = error.stack;
		            message = title + formatStack(stack, error);
		        } else {
		            message = title + String(error);
		        }
		        if (typeof warn === "function") {
		            warn(message);
		        } else if (typeof console.log === "function" ||
		            typeof console.log === "object") {
		            console.log(message);
		        }
		    }
		};

		CapturedTrace.unhandledRejection = function (reason) {
		    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
		};

		CapturedTrace.isSupported = function () {
		    return typeof captureStackTrace === "function";
		};

		CapturedTrace.fireRejectionEvent =
		function(name, localHandler, reason, promise) {
		    var localEventFired = false;
		    try {
		        if (typeof localHandler === "function") {
		            localEventFired = true;
		            if (name === "rejectionHandled") {
		                localHandler(promise);
		            } else {
		                localHandler(reason, promise);
		            }
		        }
		    } catch (e) {
		        async.throwLater(e);
		    }

		    var globalEventFired = false;
		    try {
		        globalEventFired = fireGlobalEvent(name, reason, promise);
		    } catch (e) {
		        globalEventFired = true;
		        async.throwLater(e);
		    }

		    var domEventFired = false;
		    if (fireDomEvent) {
		        try {
		            domEventFired = fireDomEvent(name.toLowerCase(), {
		                reason: reason,
		                promise: promise
		            });
		        } catch (e) {
		            domEventFired = true;
		            async.throwLater(e);
		        }
		    }

		    if (!globalEventFired && !localEventFired && !domEventFired &&
		        name === "unhandledRejection") {
		        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
		    }
		};

		function formatNonError(obj) {
		    var str;
		    if (typeof obj === "function") {
		        str = "[function " +
		            (obj.name || "anonymous") +
		            "]";
		    } else {
		        str = obj.toString();
		        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
		        if (ruselessToString.test(str)) {
		            try {
		                var newStr = JSON.stringify(obj);
		                str = newStr;
		            }
		            catch(e) {

		            }
		        }
		        if (str.length === 0) {
		            str = "(empty array)";
		        }
		    }
		    return ("(<" + snip(str) + ">, no stack trace)");
		}

		function snip(str) {
		    var maxChars = 41;
		    if (str.length < maxChars) {
		        return str;
		    }
		    return str.substr(0, maxChars - 3) + "...";
		}

		var shouldIgnore = function() { return false; };
		var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
		function parseLineInfo(line) {
		    var matches = line.match(parseLineInfoRegex);
		    if (matches) {
		        return {
		            fileName: matches[1],
		            line: parseInt(matches[2], 10)
		        };
		    }
		}
		CapturedTrace.setBounds = function(firstLineError, lastLineError) {
		    if (!CapturedTrace.isSupported()) return;
		    var firstStackLines = firstLineError.stack.split("\n");
		    var lastStackLines = lastLineError.stack.split("\n");
		    var firstIndex = -1;
		    var lastIndex = -1;
		    var firstFileName;
		    var lastFileName;
		    for (var i = 0; i < firstStackLines.length; ++i) {
		        var result = parseLineInfo(firstStackLines[i]);
		        if (result) {
		            firstFileName = result.fileName;
		            firstIndex = result.line;
		            break;
		        }
		    }
		    for (var i = 0; i < lastStackLines.length; ++i) {
		        var result = parseLineInfo(lastStackLines[i]);
		        if (result) {
		            lastFileName = result.fileName;
		            lastIndex = result.line;
		            break;
		        }
		    }
		    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
		        firstFileName !== lastFileName || firstIndex >= lastIndex) {
		        return;
		    }

		    shouldIgnore = function(line) {
		        if (bluebirdFramePattern.test(line)) return true;
		        var info = parseLineInfo(line);
		        if (info) {
		            if (info.fileName === firstFileName &&
		                (firstIndex <= info.line && info.line <= lastIndex)) {
		                return true;
		            }
		        }
		        return false;
		    };
		};

		var captureStackTrace = (function stackDetection() {
		    var v8stackFramePattern = /^\s*at\s*/;
		    var v8stackFormatter = function(stack, error) {
		        if (typeof stack === "string") return stack;

		        if (error.name !== undefined &&
		            error.message !== undefined) {
		            return error.toString();
		        }
		        return formatNonError(error);
		    };

		    if (typeof Error.stackTraceLimit === "number" &&
		        typeof Error.captureStackTrace === "function") {
		        Error.stackTraceLimit = Error.stackTraceLimit + 6;
		        stackFramePattern = v8stackFramePattern;
		        formatStack = v8stackFormatter;
		        var captureStackTrace = Error.captureStackTrace;

		        shouldIgnore = function(line) {
		            return bluebirdFramePattern.test(line);
		        };
		        return function(receiver, ignoreUntil) {
		            Error.stackTraceLimit = Error.stackTraceLimit + 6;
		            captureStackTrace(receiver, ignoreUntil);
		            Error.stackTraceLimit = Error.stackTraceLimit - 6;
		        };
		    }
		    var err = new Error();

		    if (typeof err.stack === "string" &&
		        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
		        stackFramePattern = /@/;
		        formatStack = v8stackFormatter;
		        indentStackFrames = true;
		        return function captureStackTrace(o) {
		            o.stack = new Error().stack;
		        };
		    }

		    var hasStackAfterThrow;
		    try { throw new Error(); }
		    catch(e) {
		        hasStackAfterThrow = ("stack" in e);
		    }
		    if (!("stack" in err) && hasStackAfterThrow &&
		        typeof Error.stackTraceLimit === "number") {
		        stackFramePattern = v8stackFramePattern;
		        formatStack = v8stackFormatter;
		        return function captureStackTrace(o) {
		            Error.stackTraceLimit = Error.stackTraceLimit + 6;
		            try { throw new Error(); }
		            catch(e) { o.stack = e.stack; }
		            Error.stackTraceLimit = Error.stackTraceLimit - 6;
		        };
		    }

		    formatStack = function(stack, error) {
		        if (typeof stack === "string") return stack;

		        if ((typeof error === "object" ||
		            typeof error === "function") &&
		            error.name !== undefined &&
		            error.message !== undefined) {
		            return error.toString();
		        }
		        return formatNonError(error);
		    };

		    return null;

		})([]);

		var fireDomEvent;
		var fireGlobalEvent = (function() {
		    if (util.isNode) {
		        return function(name, reason, promise) {
		            if (name === "rejectionHandled") {
		                return process.emit(name, promise);
		            } else {
		                return process.emit(name, reason, promise);
		            }
		        };
		    } else {
		        var customEventWorks = false;
		        var anyEventWorks = true;
		        try {
		            var ev = new self.CustomEvent("test");
		            customEventWorks = ev instanceof CustomEvent;
		        } catch (e) {}
		        if (!customEventWorks) {
		            try {
		                var event = document.createEvent("CustomEvent");
		                event.initCustomEvent("testingtheevent", false, true, {});
		                self.dispatchEvent(event);
		            } catch (e) {
		                anyEventWorks = false;
		            }
		        }
		        if (anyEventWorks) {
		            fireDomEvent = function(type, detail) {
		                var event;
		                if (customEventWorks) {
		                    event = new self.CustomEvent(type, {
		                        detail: detail,
		                        bubbles: false,
		                        cancelable: true
		                    });
		                } else if (self.dispatchEvent) {
		                    event = document.createEvent("CustomEvent");
		                    event.initCustomEvent(type, false, true, detail);
		                }

		                return event ? !self.dispatchEvent(event) : false;
		            };
		        }

		        var toWindowMethodNameMap = {};
		        toWindowMethodNameMap["unhandledRejection"] = ("on" +
		            "unhandledRejection").toLowerCase();
		        toWindowMethodNameMap["rejectionHandled"] = ("on" +
		            "rejectionHandled").toLowerCase();

		        return function(name, reason, promise) {
		            var methodName = toWindowMethodNameMap[name];
		            var method = self[methodName];
		            if (!method) return false;
		            if (name === "rejectionHandled") {
		                method.call(self, promise);
		            } else {
		                method.call(self, reason, promise);
		            }
		            return true;
		        };
		    }
		})();

		if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
		    warn = function (message) {
		        console.warn(message);
		    };
		    if (util.isNode && process.stderr.isTTY) {
		        warn = function(message) {
		            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
		        };
		    } else if (!util.isNode && typeof (new Error().stack) === "string") {
		        warn = function(message) {
		            console.warn("%c" + message, "color: red");
		        };
		    }
		}

		return CapturedTrace;
		};


	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(Promise, CapturedTrace) {
		var getDomain = Promise._getDomain;
		var async = __webpack_require__(7);
		var Warning = __webpack_require__(10).Warning;
		var util = __webpack_require__(5);
		var canAttachTrace = util.canAttachTrace;
		var unhandledRejectionHandled;
		var possiblyUnhandledRejection;
		var debugging = false || (util.isNode &&
		                    (!!process.env["BLUEBIRD_DEBUG"] ||
		                     process.env["NODE_ENV"] === "development"));

		if (debugging) {
		    async.disableTrampolineIfNecessary();
		}

		Promise.prototype._ignoreRejections = function() {
		    this._unsetRejectionIsUnhandled();
		    this._bitField = this._bitField | 16777216;
		};

		Promise.prototype._ensurePossibleRejectionHandled = function () {
		    if ((this._bitField & 16777216) !== 0) return;
		    this._setRejectionIsUnhandled();
		    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
		};

		Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
		    CapturedTrace.fireRejectionEvent("rejectionHandled",
		                                  unhandledRejectionHandled, undefined, this);
		};

		Promise.prototype._notifyUnhandledRejection = function () {
		    if (this._isRejectionUnhandled()) {
		        var reason = this._getCarriedStackTrace() || this._settledValue;
		        this._setUnhandledRejectionIsNotified();
		        CapturedTrace.fireRejectionEvent("unhandledRejection",
		                                      possiblyUnhandledRejection, reason, this);
		    }
		};

		Promise.prototype._setUnhandledRejectionIsNotified = function () {
		    this._bitField = this._bitField | 524288;
		};

		Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
		    this._bitField = this._bitField & (~524288);
		};

		Promise.prototype._isUnhandledRejectionNotified = function () {
		    return (this._bitField & 524288) > 0;
		};

		Promise.prototype._setRejectionIsUnhandled = function () {
		    this._bitField = this._bitField | 2097152;
		};

		Promise.prototype._unsetRejectionIsUnhandled = function () {
		    this._bitField = this._bitField & (~2097152);
		    if (this._isUnhandledRejectionNotified()) {
		        this._unsetUnhandledRejectionIsNotified();
		        this._notifyUnhandledRejectionIsHandled();
		    }
		};

		Promise.prototype._isRejectionUnhandled = function () {
		    return (this._bitField & 2097152) > 0;
		};

		Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
		    this._bitField = this._bitField | 1048576;
		    this._fulfillmentHandler0 = capturedTrace;
		};

		Promise.prototype._isCarryingStackTrace = function () {
		    return (this._bitField & 1048576) > 0;
		};

		Promise.prototype._getCarriedStackTrace = function () {
		    return this._isCarryingStackTrace()
		        ? this._fulfillmentHandler0
		        : undefined;
		};

		Promise.prototype._captureStackTrace = function () {
		    if (debugging) {
		        this._trace = new CapturedTrace(this._peekContext());
		    }
		    return this;
		};

		Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
		    if (debugging && canAttachTrace(error)) {
		        var trace = this._trace;
		        if (trace !== undefined) {
		            if (ignoreSelf) trace = trace._parent;
		        }
		        if (trace !== undefined) {
		            trace.attachExtraTrace(error);
		        } else if (!error.__stackCleaned__) {
		            var parsed = CapturedTrace.parseStackAndMessage(error);
		            util.notEnumerableProp(error, "stack",
		                parsed.message + "\n" + parsed.stack.join("\n"));
		            util.notEnumerableProp(error, "__stackCleaned__", true);
		        }
		    }
		};

		Promise.prototype._warn = function(message) {
		    var warning = new Warning(message);
		    var ctx = this._peekContext();
		    if (ctx) {
		        ctx.attachExtraTrace(warning);
		    } else {
		        var parsed = CapturedTrace.parseStackAndMessage(warning);
		        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
		    }
		    CapturedTrace.formatAndLogError(warning, "");
		};

		Promise.onPossiblyUnhandledRejection = function (fn) {
		    var domain = getDomain();
		    possiblyUnhandledRejection =
		        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
		                                 : undefined;
		};

		Promise.onUnhandledRejectionHandled = function (fn) {
		    var domain = getDomain();
		    unhandledRejectionHandled =
		        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
		                                 : undefined;
		};

		Promise.longStackTraces = function () {
		    if (async.haveItemsQueued() &&
		        debugging === false
		   ) {
		        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
		    }
		    debugging = CapturedTrace.isSupported();
		    if (debugging) {
		        async.disableTrampolineIfNecessary();
		    }
		};

		Promise.hasLongStackTraces = function () {
		    return debugging && CapturedTrace.isSupported();
		};

		if (!CapturedTrace.isSupported()) {
		    Promise.longStackTraces = function(){};
		    debugging = false;
		}

		return function() {
		    return debugging;
		};
		};


	/***/ },
	/* 15 */
	/***/ function(module, exports) {

		"use strict";
		module.exports = function(Promise, CapturedTrace, isDebugging) {
		var contextStack = [];
		function Context() {
		    this._trace = new CapturedTrace(peekContext());
		}
		Context.prototype._pushContext = function () {
		    if (!isDebugging()) return;
		    if (this._trace !== undefined) {
		        contextStack.push(this._trace);
		    }
		};

		Context.prototype._popContext = function () {
		    if (!isDebugging()) return;
		    if (this._trace !== undefined) {
		        contextStack.pop();
		    }
		};

		function createContext() {
		    if (isDebugging()) return new Context();
		}

		function peekContext() {
		    var lastIndex = contextStack.length - 1;
		    if (lastIndex >= 0) {
		        return contextStack[lastIndex];
		    }
		    return undefined;
		}

		Promise.prototype._peekContext = peekContext;
		Promise.prototype._pushContext = Context.prototype._pushContext;
		Promise.prototype._popContext = Context.prototype._popContext;

		return createContext;
		};


	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(NEXT_FILTER) {
		var util = __webpack_require__(5);
		var errors = __webpack_require__(10);
		var tryCatch = util.tryCatch;
		var errorObj = util.errorObj;
		var keys = __webpack_require__(6).keys;
		var TypeError = errors.TypeError;

		function CatchFilter(instances, callback, promise) {
		    this._instances = instances;
		    this._callback = callback;
		    this._promise = promise;
		}

		function safePredicate(predicate, e) {
		    var safeObject = {};
		    var retfilter = tryCatch(predicate).call(safeObject, e);

		    if (retfilter === errorObj) return retfilter;

		    var safeKeys = keys(safeObject);
		    if (safeKeys.length) {
		        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
		        return errorObj;
		    }
		    return retfilter;
		}

		CatchFilter.prototype.doFilter = function (e) {
		    var cb = this._callback;
		    var promise = this._promise;
		    var boundTo = promise._boundValue();
		    for (var i = 0, len = this._instances.length; i < len; ++i) {
		        var item = this._instances[i];
		        var itemIsErrorType = item === Error ||
		            (item != null && item.prototype instanceof Error);

		        if (itemIsErrorType && e instanceof item) {
		            var ret = tryCatch(cb).call(boundTo, e);
		            if (ret === errorObj) {
		                NEXT_FILTER.e = ret.e;
		                return NEXT_FILTER;
		            }
		            return ret;
		        } else if (typeof item === "function" && !itemIsErrorType) {
		            var shouldHandle = safePredicate(item, e);
		            if (shouldHandle === errorObj) {
		                e = errorObj.e;
		                break;
		            } else if (shouldHandle) {
		                var ret = tryCatch(cb).call(boundTo, e);
		                if (ret === errorObj) {
		                    NEXT_FILTER.e = ret.e;
		                    return NEXT_FILTER;
		                }
		                return ret;
		            }
		        }
		    }
		    NEXT_FILTER.e = e;
		    return NEXT_FILTER;
		};

		return CatchFilter;
		};


	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var util = __webpack_require__(5);
		var maybeWrapAsError = util.maybeWrapAsError;
		var errors = __webpack_require__(10);
		var TimeoutError = errors.TimeoutError;
		var OperationalError = errors.OperationalError;
		var haveGetters = util.haveGetters;
		var es5 = __webpack_require__(6);

		function isUntypedError(obj) {
		    return obj instanceof Error &&
		        es5.getPrototypeOf(obj) === Error.prototype;
		}

		var rErrorKey = /^(?:name|message|stack|cause)$/;
		function wrapAsOperationalError(obj) {
		    var ret;
		    if (isUntypedError(obj)) {
		        ret = new OperationalError(obj);
		        ret.name = obj.name;
		        ret.message = obj.message;
		        ret.stack = obj.stack;
		        var keys = es5.keys(obj);
		        for (var i = 0; i < keys.length; ++i) {
		            var key = keys[i];
		            if (!rErrorKey.test(key)) {
		                ret[key] = obj[key];
		            }
		        }
		        return ret;
		    }
		    util.markAsOriginatingFromRejection(obj);
		    return obj;
		}

		function nodebackForPromise(promise) {
		    return function(err, value) {
		        if (promise === null) return;

		        if (err) {
		            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
		            promise._attachExtraTrace(wrapped);
		            promise._reject(wrapped);
		        } else if (arguments.length > 2) {
		            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
		            promise._fulfill(args);
		        } else {
		            promise._fulfill(value);
		        }

		        promise = null;
		    };
		}


		var PromiseResolver;
		if (!haveGetters) {
		    PromiseResolver = function (promise) {
		        this.promise = promise;
		        this.asCallback = nodebackForPromise(promise);
		        this.callback = this.asCallback;
		    };
		}
		else {
		    PromiseResolver = function (promise) {
		        this.promise = promise;
		    };
		}
		if (haveGetters) {
		    var prop = {
		        get: function() {
		            return nodebackForPromise(this.promise);
		        }
		    };
		    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
		    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
		}

		PromiseResolver._nodebackForPromise = nodebackForPromise;

		PromiseResolver.prototype.toString = function () {
		    return "[object PromiseResolver]";
		};

		PromiseResolver.prototype.resolve =
		PromiseResolver.prototype.fulfill = function (value) {
		    if (!(this instanceof PromiseResolver)) {
		        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
		    }
		    this.promise._resolveCallback(value);
		};

		PromiseResolver.prototype.reject = function (reason) {
		    if (!(this instanceof PromiseResolver)) {
		        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
		    }
		    this.promise._rejectCallback(reason);
		};

		PromiseResolver.prototype.progress = function (value) {
		    if (!(this instanceof PromiseResolver)) {
		        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
		    }
		    this.promise._progress(value);
		};

		PromiseResolver.prototype.cancel = function (err) {
		    this.promise.cancel(err);
		};

		PromiseResolver.prototype.timeout = function () {
		    this.reject(new TimeoutError("timeout"));
		};

		PromiseResolver.prototype.isResolved = function () {
		    return this.promise.isResolved();
		};

		PromiseResolver.prototype.toJSON = function () {
		    return this.promise.toJSON();
		};

		module.exports = PromiseResolver;


	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(Promise, PromiseArray) {
		var util = __webpack_require__(5);
		var async = __webpack_require__(7);
		var tryCatch = util.tryCatch;
		var errorObj = util.errorObj;

		Promise.prototype.progressed = function (handler) {
		    return this._then(undefined, undefined, handler, undefined, undefined);
		};

		Promise.prototype._progress = function (progressValue) {
		    if (this._isFollowingOrFulfilledOrRejected()) return;
		    this._target()._progressUnchecked(progressValue);

		};

		Promise.prototype._progressHandlerAt = function (index) {
		    return index === 0
		        ? this._progressHandler0
		        : this[(index << 2) + index - 5 + 2];
		};

		Promise.prototype._doProgressWith = function (progression) {
		    var progressValue = progression.value;
		    var handler = progression.handler;
		    var promise = progression.promise;
		    var receiver = progression.receiver;

		    var ret = tryCatch(handler).call(receiver, progressValue);
		    if (ret === errorObj) {
		        if (ret.e != null &&
		            ret.e.name !== "StopProgressPropagation") {
		            var trace = util.canAttachTrace(ret.e)
		                ? ret.e : new Error(util.toString(ret.e));
		            promise._attachExtraTrace(trace);
		            promise._progress(ret.e);
		        }
		    } else if (ret instanceof Promise) {
		        ret._then(promise._progress, null, null, promise, undefined);
		    } else {
		        promise._progress(ret);
		    }
		};


		Promise.prototype._progressUnchecked = function (progressValue) {
		    var len = this._length();
		    var progress = this._progress;
		    for (var i = 0; i < len; i++) {
		        var handler = this._progressHandlerAt(i);
		        var promise = this._promiseAt(i);
		        if (!(promise instanceof Promise)) {
		            var receiver = this._receiverAt(i);
		            if (typeof handler === "function") {
		                handler.call(receiver, progressValue, promise);
		            } else if (receiver instanceof PromiseArray &&
		                       !receiver._isResolved()) {
		                receiver._promiseProgressed(progressValue, promise);
		            }
		            continue;
		        }

		        if (typeof handler === "function") {
		            async.invoke(this._doProgressWith, this, {
		                handler: handler,
		                promise: promise,
		                receiver: this._receiverAt(i),
		                value: progressValue
		            });
		        } else {
		            async.invoke(progress, promise, progressValue);
		        }
		    }
		};
		};


	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports =
		function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
		var util = __webpack_require__(5);
		var tryCatch = util.tryCatch;

		Promise.method = function (fn) {
		    if (typeof fn !== "function") {
		        throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
		    }
		    return function () {
		        var ret = new Promise(INTERNAL);
		        ret._captureStackTrace();
		        ret._pushContext();
		        var value = tryCatch(fn).apply(this, arguments);
		        ret._popContext();
		        ret._resolveFromSyncValue(value);
		        return ret;
		    };
		};

		Promise.attempt = Promise["try"] = function (fn, args, ctx) {
		    if (typeof fn !== "function") {
		        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
		    }
		    var ret = new Promise(INTERNAL);
		    ret._captureStackTrace();
		    ret._pushContext();
		    var value = util.isArray(args)
		        ? tryCatch(fn).apply(ctx, args)
		        : tryCatch(fn).call(ctx, args);
		    ret._popContext();
		    ret._resolveFromSyncValue(value);
		    return ret;
		};

		Promise.prototype._resolveFromSyncValue = function (value) {
		    if (value === util.errorObj) {
		        this._rejectCallback(value.e, false, true);
		    } else {
		        this._resolveCallback(value, true);
		    }
		};
		};


	/***/ },
	/* 20 */
	/***/ function(module, exports) {

		"use strict";
		module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
		var rejectThis = function(_, e) {
		    this._reject(e);
		};

		var targetRejected = function(e, context) {
		    context.promiseRejectionQueued = true;
		    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
		};

		var bindingResolved = function(thisArg, context) {
		    if (this._isPending()) {
		        this._resolveCallback(context.target);
		    }
		};

		var bindingRejected = function(e, context) {
		    if (!context.promiseRejectionQueued) this._reject(e);
		};

		Promise.prototype.bind = function (thisArg) {
		    var maybePromise = tryConvertToPromise(thisArg);
		    var ret = new Promise(INTERNAL);
		    ret._propagateFrom(this, 1);
		    var target = this._target();

		    ret._setBoundTo(maybePromise);
		    if (maybePromise instanceof Promise) {
		        var context = {
		            promiseRejectionQueued: false,
		            promise: ret,
		            target: target,
		            bindingPromise: maybePromise
		        };
		        target._then(INTERNAL, targetRejected, ret._progress, ret, context);
		        maybePromise._then(
		            bindingResolved, bindingRejected, ret._progress, ret, context);
		    } else {
		        ret._resolveCallback(target);
		    }
		    return ret;
		};

		Promise.prototype._setBoundTo = function (obj) {
		    if (obj !== undefined) {
		        this._bitField = this._bitField | 131072;
		        this._boundTo = obj;
		    } else {
		        this._bitField = this._bitField & (~131072);
		    }
		};

		Promise.prototype._isBound = function () {
		    return (this._bitField & 131072) === 131072;
		};

		Promise.bind = function (thisArg, value) {
		    var maybePromise = tryConvertToPromise(thisArg);
		    var ret = new Promise(INTERNAL);

		    ret._setBoundTo(maybePromise);
		    if (maybePromise instanceof Promise) {
		        maybePromise._then(function() {
		            ret._resolveCallback(value);
		        }, ret._reject, ret._progress, ret, null);
		    } else {
		        ret._resolveCallback(value);
		    }
		    return ret;
		};
		};


	/***/ },
	/* 21 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
		var util = __webpack_require__(5);
		var isPrimitive = util.isPrimitive;
		var thrower = util.thrower;

		function returnThis() {
		    return this;
		}
		function throwThis() {
		    throw this;
		}
		function return$(r) {
		    return function() {
		        return r;
		    };
		}
		function throw$(r) {
		    return function() {
		        throw r;
		    };
		}
		function promisedFinally(ret, reasonOrValue, isFulfilled) {
		    var then;
		    if (isPrimitive(reasonOrValue)) {
		        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
		    } else {
		        then = isFulfilled ? returnThis : throwThis;
		    }
		    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
		}

		function finallyHandler(reasonOrValue) {
		    var promise = this.promise;
		    var handler = this.handler;

		    var ret = promise._isBound()
		                    ? handler.call(promise._boundValue())
		                    : handler();

		    if (ret !== undefined) {
		        var maybePromise = tryConvertToPromise(ret, promise);
		        if (maybePromise instanceof Promise) {
		            maybePromise = maybePromise._target();
		            return promisedFinally(maybePromise, reasonOrValue,
		                                    promise.isFulfilled());
		        }
		    }

		    if (promise.isRejected()) {
		        NEXT_FILTER.e = reasonOrValue;
		        return NEXT_FILTER;
		    } else {
		        return reasonOrValue;
		    }
		}

		function tapHandler(value) {
		    var promise = this.promise;
		    var handler = this.handler;

		    var ret = promise._isBound()
		                    ? handler.call(promise._boundValue(), value)
		                    : handler(value);

		    if (ret !== undefined) {
		        var maybePromise = tryConvertToPromise(ret, promise);
		        if (maybePromise instanceof Promise) {
		            maybePromise = maybePromise._target();
		            return promisedFinally(maybePromise, value, true);
		        }
		    }
		    return value;
		}

		Promise.prototype._passThroughHandler = function (handler, isFinally) {
		    if (typeof handler !== "function") return this.then();

		    var promiseAndHandler = {
		        promise: this,
		        handler: handler
		    };

		    return this._then(
		            isFinally ? finallyHandler : tapHandler,
		            isFinally ? finallyHandler : undefined, undefined,
		            promiseAndHandler, undefined);
		};

		Promise.prototype.lastly =
		Promise.prototype["finally"] = function (handler) {
		    return this._passThroughHandler(handler, true);
		};

		Promise.prototype.tap = function (handler) {
		    return this._passThroughHandler(handler, false);
		};
		};


	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var util = __webpack_require__(5);
		var isPrimitive = util.isPrimitive;

		module.exports = function(Promise) {
		var returner = function () {
		    return this;
		};
		var thrower = function () {
		    throw this;
		};
		var returnUndefined = function() {};
		var throwUndefined = function() {
		    throw undefined;
		};

		var wrapper = function (value, action) {
		    if (action === 1) {
		        return function () {
		            throw value;
		        };
		    } else if (action === 2) {
		        return function () {
		            return value;
		        };
		    }
		};


		Promise.prototype["return"] =
		Promise.prototype.thenReturn = function (value) {
		    if (value === undefined) return this.then(returnUndefined);

		    if (isPrimitive(value)) {
		        return this._then(
		            wrapper(value, 2),
		            undefined,
		            undefined,
		            undefined,
		            undefined
		       );
		    }
		    return this._then(returner, undefined, undefined, value, undefined);
		};

		Promise.prototype["throw"] =
		Promise.prototype.thenThrow = function (reason) {
		    if (reason === undefined) return this.then(throwUndefined);

		    if (isPrimitive(reason)) {
		        return this._then(
		            wrapper(reason, 1),
		            undefined,
		            undefined,
		            undefined,
		            undefined
		       );
		    }
		    return this._then(thrower, undefined, undefined, reason, undefined);
		};
		};


	/***/ },
	/* 23 */
	/***/ function(module, exports) {

		"use strict";
		module.exports = function(Promise) {
		function PromiseInspection(promise) {
		    if (promise !== undefined) {
		        promise = promise._target();
		        this._bitField = promise._bitField;
		        this._settledValue = promise._settledValue;
		    }
		    else {
		        this._bitField = 0;
		        this._settledValue = undefined;
		    }
		}

		PromiseInspection.prototype.value = function () {
		    if (!this.isFulfilled()) {
		        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
		    }
		    return this._settledValue;
		};

		PromiseInspection.prototype.error =
		PromiseInspection.prototype.reason = function () {
		    if (!this.isRejected()) {
		        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
		    }
		    return this._settledValue;
		};

		PromiseInspection.prototype.isFulfilled =
		Promise.prototype._isFulfilled = function () {
		    return (this._bitField & 268435456) > 0;
		};

		PromiseInspection.prototype.isRejected =
		Promise.prototype._isRejected = function () {
		    return (this._bitField & 134217728) > 0;
		};

		PromiseInspection.prototype.isPending =
		Promise.prototype._isPending = function () {
		    return (this._bitField & 402653184) === 0;
		};

		PromiseInspection.prototype.isResolved =
		Promise.prototype._isResolved = function () {
		    return (this._bitField & 402653184) > 0;
		};

		Promise.prototype.isPending = function() {
		    return this._target()._isPending();
		};

		Promise.prototype.isRejected = function() {
		    return this._target()._isRejected();
		};

		Promise.prototype.isFulfilled = function() {
		    return this._target()._isFulfilled();
		};

		Promise.prototype.isResolved = function() {
		    return this._target()._isResolved();
		};

		Promise.prototype._value = function() {
		    return this._settledValue;
		};

		Promise.prototype._reason = function() {
		    this._unsetRejectionIsUnhandled();
		    return this._settledValue;
		};

		Promise.prototype.value = function() {
		    var target = this._target();
		    if (!target.isFulfilled()) {
		        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
		    }
		    return target._settledValue;
		};

		Promise.prototype.reason = function() {
		    var target = this._target();
		    if (!target.isRejected()) {
		        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
		    }
		    target._unsetRejectionIsUnhandled();
		    return target._settledValue;
		};


		Promise.PromiseInspection = PromiseInspection;
		};


	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports =
		function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
		var util = __webpack_require__(5);
		var canEvaluate = util.canEvaluate;
		var tryCatch = util.tryCatch;
		var errorObj = util.errorObj;
		var reject;

		if (true) {
		if (canEvaluate) {
		    var thenCallback = function(i) {
		        return new Function("value", "holder", "                             \n\
		            'use strict';                                                    \n\
		            holder.pIndex = value;                                           \n\
		            holder.checkFulfillment(this);                                   \n\
		            ".replace(/Index/g, i));
		    };

		    var caller = function(count) {
		        var values = [];
		        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
		        return new Function("holder", "                                      \n\
		            'use strict';                                                    \n\
		            var callback = holder.fn;                                        \n\
		            return callback(values);                                         \n\
		            ".replace(/values/g, values.join(", ")));
		    };
		    var thenCallbacks = [];
		    var callers = [undefined];
		    for (var i = 1; i <= 5; ++i) {
		        thenCallbacks.push(thenCallback(i));
		        callers.push(caller(i));
		    }

		    var Holder = function(total, fn) {
		        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
		        this.fn = fn;
		        this.total = total;
		        this.now = 0;
		    };

		    Holder.prototype.callers = callers;
		    Holder.prototype.checkFulfillment = function(promise) {
		        var now = this.now;
		        now++;
		        var total = this.total;
		        if (now >= total) {
		            var handler = this.callers[total];
		            promise._pushContext();
		            var ret = tryCatch(handler)(this);
		            promise._popContext();
		            if (ret === errorObj) {
		                promise._rejectCallback(ret.e, false, true);
		            } else {
		                promise._resolveCallback(ret);
		            }
		        } else {
		            this.now = now;
		        }
		    };

		    var reject = function (reason) {
		        this._reject(reason);
		    };
		}
		}

		Promise.join = function () {
		    var last = arguments.length - 1;
		    var fn;
		    if (last > 0 && typeof arguments[last] === "function") {
		        fn = arguments[last];
		        if (true) {
		            if (last < 6 && canEvaluate) {
		                var ret = new Promise(INTERNAL);
		                ret._captureStackTrace();
		                var holder = new Holder(last, fn);
		                var callbacks = thenCallbacks;
		                for (var i = 0; i < last; ++i) {
		                    var maybePromise = tryConvertToPromise(arguments[i], ret);
		                    if (maybePromise instanceof Promise) {
		                        maybePromise = maybePromise._target();
		                        if (maybePromise._isPending()) {
		                            maybePromise._then(callbacks[i], reject,
		                                               undefined, ret, holder);
		                        } else if (maybePromise._isFulfilled()) {
		                            callbacks[i].call(ret,
		                                              maybePromise._value(), holder);
		                        } else {
		                            ret._reject(maybePromise._reason());
		                        }
		                    } else {
		                        callbacks[i].call(ret, maybePromise, holder);
		                    }
		                }
		                return ret;
		            }
		        }
		    }
		    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
		    if (fn) args.pop();
		    var ret = new PromiseArray(args).promise();
		    return fn !== undefined ? ret.spread(fn) : ret;
		};

		};


	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(Promise,
		                          PromiseArray,
		                          apiRejection,
		                          tryConvertToPromise,
		                          INTERNAL) {
		var getDomain = Promise._getDomain;
		var async = __webpack_require__(7);
		var util = __webpack_require__(5);
		var tryCatch = util.tryCatch;
		var errorObj = util.errorObj;
		var PENDING = {};
		var EMPTY_ARRAY = [];

		function MappingPromiseArray(promises, fn, limit, _filter) {
		    this.constructor$(promises);
		    this._promise._captureStackTrace();
		    var domain = getDomain();
		    this._callback = domain === null ? fn : domain.bind(fn);
		    this._preservedValues = _filter === INTERNAL
		        ? new Array(this.length())
		        : null;
		    this._limit = limit;
		    this._inFlight = 0;
		    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
		    async.invoke(init, this, undefined);
		}
		util.inherits(MappingPromiseArray, PromiseArray);
		function init() {this._init$(undefined, -2);}

		MappingPromiseArray.prototype._init = function () {};

		MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
		    var values = this._values;
		    var length = this.length();
		    var preservedValues = this._preservedValues;
		    var limit = this._limit;
		    if (values[index] === PENDING) {
		        values[index] = value;
		        if (limit >= 1) {
		            this._inFlight--;
		            this._drainQueue();
		            if (this._isResolved()) return;
		        }
		    } else {
		        if (limit >= 1 && this._inFlight >= limit) {
		            values[index] = value;
		            this._queue.push(index);
		            return;
		        }
		        if (preservedValues !== null) preservedValues[index] = value;

		        var callback = this._callback;
		        var receiver = this._promise._boundValue();
		        this._promise._pushContext();
		        var ret = tryCatch(callback).call(receiver, value, index, length);
		        this._promise._popContext();
		        if (ret === errorObj) return this._reject(ret.e);

		        var maybePromise = tryConvertToPromise(ret, this._promise);
		        if (maybePromise instanceof Promise) {
		            maybePromise = maybePromise._target();
		            if (maybePromise._isPending()) {
		                if (limit >= 1) this._inFlight++;
		                values[index] = PENDING;
		                return maybePromise._proxyPromiseArray(this, index);
		            } else if (maybePromise._isFulfilled()) {
		                ret = maybePromise._value();
		            } else {
		                return this._reject(maybePromise._reason());
		            }
		        }
		        values[index] = ret;
		    }
		    var totalResolved = ++this._totalResolved;
		    if (totalResolved >= length) {
		        if (preservedValues !== null) {
		            this._filter(values, preservedValues);
		        } else {
		            this._resolve(values);
		        }

		    }
		};

		MappingPromiseArray.prototype._drainQueue = function () {
		    var queue = this._queue;
		    var limit = this._limit;
		    var values = this._values;
		    while (queue.length > 0 && this._inFlight < limit) {
		        if (this._isResolved()) return;
		        var index = queue.pop();
		        this._promiseFulfilled(values[index], index);
		    }
		};

		MappingPromiseArray.prototype._filter = function (booleans, values) {
		    var len = values.length;
		    var ret = new Array(len);
		    var j = 0;
		    for (var i = 0; i < len; ++i) {
		        if (booleans[i]) ret[j++] = values[i];
		    }
		    ret.length = j;
		    this._resolve(ret);
		};

		MappingPromiseArray.prototype.preservedValues = function () {
		    return this._preservedValues;
		};

		function map(promises, fn, options, _filter) {
		    var limit = typeof options === "object" && options !== null
		        ? options.concurrency
		        : 0;
		    limit = typeof limit === "number" &&
		        isFinite(limit) && limit >= 1 ? limit : 0;
		    return new MappingPromiseArray(promises, fn, limit, _filter);
		}

		Promise.prototype.map = function (fn, options) {
		    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");

		    return map(this, fn, options, null).promise();
		};

		Promise.map = function (promises, fn, options, _filter) {
		    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
		    return map(promises, fn, options, _filter).promise();
		};


		};


	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(Promise) {
		var errors = __webpack_require__(10);
		var async = __webpack_require__(7);
		var CancellationError = errors.CancellationError;

		Promise.prototype._cancel = function (reason) {
		    if (!this.isCancellable()) return this;
		    var parent;
		    var promiseToReject = this;
		    while ((parent = promiseToReject._cancellationParent) !== undefined &&
		        parent.isCancellable()) {
		        promiseToReject = parent;
		    }
		    this._unsetCancellable();
		    promiseToReject._target()._rejectCallback(reason, false, true);
		};

		Promise.prototype.cancel = function (reason) {
		    if (!this.isCancellable()) return this;
		    if (reason === undefined) reason = new CancellationError();
		    async.invokeLater(this._cancel, this, reason);
		    return this;
		};

		Promise.prototype.cancellable = function () {
		    if (this._cancellable()) return this;
		    async.enableTrampoline();
		    this._setCancellable();
		    this._cancellationParent = undefined;
		    return this;
		};

		Promise.prototype.uncancellable = function () {
		    var ret = this.then();
		    ret._unsetCancellable();
		    return ret;
		};

		Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
		    var ret = this._then(didFulfill, didReject, didProgress,
		                         undefined, undefined);

		    ret._setCancellable();
		    ret._cancellationParent = undefined;
		    return ret;
		};
		};


	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function (Promise, apiRejection, tryConvertToPromise,
		    createContext) {
		    var TypeError = __webpack_require__(10).TypeError;
		    var inherits = __webpack_require__(5).inherits;
		    var PromiseInspection = Promise.PromiseInspection;

		    function inspectionMapper(inspections) {
		        var len = inspections.length;
		        for (var i = 0; i < len; ++i) {
		            var inspection = inspections[i];
		            if (inspection.isRejected()) {
		                return Promise.reject(inspection.error());
		            }
		            inspections[i] = inspection._settledValue;
		        }
		        return inspections;
		    }

		    function thrower(e) {
		        setTimeout(function(){throw e;}, 0);
		    }

		    function castPreservingDisposable(thenable) {
		        var maybePromise = tryConvertToPromise(thenable);
		        if (maybePromise !== thenable &&
		            typeof thenable._isDisposable === "function" &&
		            typeof thenable._getDisposer === "function" &&
		            thenable._isDisposable()) {
		            maybePromise._setDisposable(thenable._getDisposer());
		        }
		        return maybePromise;
		    }
		    function dispose(resources, inspection) {
		        var i = 0;
		        var len = resources.length;
		        var ret = Promise.defer();
		        function iterator() {
		            if (i >= len) return ret.resolve();
		            var maybePromise = castPreservingDisposable(resources[i++]);
		            if (maybePromise instanceof Promise &&
		                maybePromise._isDisposable()) {
		                try {
		                    maybePromise = tryConvertToPromise(
		                        maybePromise._getDisposer().tryDispose(inspection),
		                        resources.promise);
		                } catch (e) {
		                    return thrower(e);
		                }
		                if (maybePromise instanceof Promise) {
		                    return maybePromise._then(iterator, thrower,
		                                              null, null, null);
		                }
		            }
		            iterator();
		        }
		        iterator();
		        return ret.promise;
		    }

		    function disposerSuccess(value) {
		        var inspection = new PromiseInspection();
		        inspection._settledValue = value;
		        inspection._bitField = 268435456;
		        return dispose(this, inspection).thenReturn(value);
		    }

		    function disposerFail(reason) {
		        var inspection = new PromiseInspection();
		        inspection._settledValue = reason;
		        inspection._bitField = 134217728;
		        return dispose(this, inspection).thenThrow(reason);
		    }

		    function Disposer(data, promise, context) {
		        this._data = data;
		        this._promise = promise;
		        this._context = context;
		    }

		    Disposer.prototype.data = function () {
		        return this._data;
		    };

		    Disposer.prototype.promise = function () {
		        return this._promise;
		    };

		    Disposer.prototype.resource = function () {
		        if (this.promise().isFulfilled()) {
		            return this.promise().value();
		        }
		        return null;
		    };

		    Disposer.prototype.tryDispose = function(inspection) {
		        var resource = this.resource();
		        var context = this._context;
		        if (context !== undefined) context._pushContext();
		        var ret = resource !== null
		            ? this.doDispose(resource, inspection) : null;
		        if (context !== undefined) context._popContext();
		        this._promise._unsetDisposable();
		        this._data = null;
		        return ret;
		    };

		    Disposer.isDisposer = function (d) {
		        return (d != null &&
		                typeof d.resource === "function" &&
		                typeof d.tryDispose === "function");
		    };

		    function FunctionDisposer(fn, promise, context) {
		        this.constructor$(fn, promise, context);
		    }
		    inherits(FunctionDisposer, Disposer);

		    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
		        var fn = this.data();
		        return fn.call(resource, resource, inspection);
		    };

		    function maybeUnwrapDisposer(value) {
		        if (Disposer.isDisposer(value)) {
		            this.resources[this.index]._setDisposable(value);
		            return value.promise();
		        }
		        return value;
		    }

		    Promise.using = function () {
		        var len = arguments.length;
		        if (len < 2) return apiRejection(
		                        "you must pass at least 2 arguments to Promise.using");
		        var fn = arguments[len - 1];
		        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
		        len--;
		        var resources = new Array(len);
		        for (var i = 0; i < len; ++i) {
		            var resource = arguments[i];
		            if (Disposer.isDisposer(resource)) {
		                var disposer = resource;
		                resource = resource.promise();
		                resource._setDisposable(disposer);
		            } else {
		                var maybePromise = tryConvertToPromise(resource);
		                if (maybePromise instanceof Promise) {
		                    resource =
		                        maybePromise._then(maybeUnwrapDisposer, null, null, {
		                            resources: resources,
		                            index: i
		                    }, undefined);
		                }
		            }
		            resources[i] = resource;
		        }

		        var promise = Promise.settle(resources)
		            .then(inspectionMapper)
		            .then(function(vals) {
		                promise._pushContext();
		                var ret;
		                try {
		                    ret = fn.apply(undefined, vals);
		                } finally {
		                    promise._popContext();
		                }
		                return ret;
		            })
		            ._then(
		                disposerSuccess, disposerFail, undefined, resources, undefined);
		        resources.promise = promise;
		        return promise;
		    };

		    Promise.prototype._setDisposable = function (disposer) {
		        this._bitField = this._bitField | 262144;
		        this._disposer = disposer;
		    };

		    Promise.prototype._isDisposable = function () {
		        return (this._bitField & 262144) > 0;
		    };

		    Promise.prototype._getDisposer = function () {
		        return this._disposer;
		    };

		    Promise.prototype._unsetDisposable = function () {
		        this._bitField = this._bitField & (~262144);
		        this._disposer = undefined;
		    };

		    Promise.prototype.disposer = function (fn) {
		        if (typeof fn === "function") {
		            return new FunctionDisposer(fn, this, createContext());
		        }
		        throw new TypeError();
		    };

		};


	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(Promise,
		                          apiRejection,
		                          INTERNAL,
		                          tryConvertToPromise) {
		var errors = __webpack_require__(10);
		var TypeError = errors.TypeError;
		var util = __webpack_require__(5);
		var errorObj = util.errorObj;
		var tryCatch = util.tryCatch;
		var yieldHandlers = [];

		function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
		    for (var i = 0; i < yieldHandlers.length; ++i) {
		        traceParent._pushContext();
		        var result = tryCatch(yieldHandlers[i])(value);
		        traceParent._popContext();
		        if (result === errorObj) {
		            traceParent._pushContext();
		            var ret = Promise.reject(errorObj.e);
		            traceParent._popContext();
		            return ret;
		        }
		        var maybePromise = tryConvertToPromise(result, traceParent);
		        if (maybePromise instanceof Promise) return maybePromise;
		    }
		    return null;
		}

		function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
		    var promise = this._promise = new Promise(INTERNAL);
		    promise._captureStackTrace();
		    this._stack = stack;
		    this._generatorFunction = generatorFunction;
		    this._receiver = receiver;
		    this._generator = undefined;
		    this._yieldHandlers = typeof yieldHandler === "function"
		        ? [yieldHandler].concat(yieldHandlers)
		        : yieldHandlers;
		}

		PromiseSpawn.prototype.promise = function () {
		    return this._promise;
		};

		PromiseSpawn.prototype._run = function () {
		    this._generator = this._generatorFunction.call(this._receiver);
		    this._receiver =
		        this._generatorFunction = undefined;
		    this._next(undefined);
		};

		PromiseSpawn.prototype._continue = function (result) {
		    if (result === errorObj) {
		        return this._promise._rejectCallback(result.e, false, true);
		    }

		    var value = result.value;
		    if (result.done === true) {
		        this._promise._resolveCallback(value);
		    } else {
		        var maybePromise = tryConvertToPromise(value, this._promise);
		        if (!(maybePromise instanceof Promise)) {
		            maybePromise =
		                promiseFromYieldHandler(maybePromise,
		                                        this._yieldHandlers,
		                                        this._promise);
		            if (maybePromise === null) {
		                this._throw(
		                    new TypeError(
		                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
		                        "From coroutine:\u000a" +
		                        this._stack.split("\n").slice(1, -7).join("\n")
		                    )
		                );
		                return;
		            }
		        }
		        maybePromise._then(
		            this._next,
		            this._throw,
		            undefined,
		            this,
		            null
		       );
		    }
		};

		PromiseSpawn.prototype._throw = function (reason) {
		    this._promise._attachExtraTrace(reason);
		    this._promise._pushContext();
		    var result = tryCatch(this._generator["throw"])
		        .call(this._generator, reason);
		    this._promise._popContext();
		    this._continue(result);
		};

		PromiseSpawn.prototype._next = function (value) {
		    this._promise._pushContext();
		    var result = tryCatch(this._generator.next).call(this._generator, value);
		    this._promise._popContext();
		    this._continue(result);
		};

		Promise.coroutine = function (generatorFunction, options) {
		    if (typeof generatorFunction !== "function") {
		        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
		    }
		    var yieldHandler = Object(options).yieldHandler;
		    var PromiseSpawn$ = PromiseSpawn;
		    var stack = new Error().stack;
		    return function () {
		        var generator = generatorFunction.apply(this, arguments);
		        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
		                                      stack);
		        spawn._generator = generator;
		        spawn._next(undefined);
		        return spawn.promise();
		    };
		};

		Promise.coroutine.addYieldHandler = function(fn) {
		    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
		    yieldHandlers.push(fn);
		};

		Promise.spawn = function (generatorFunction) {
		    if (typeof generatorFunction !== "function") {
		        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
		    }
		    var spawn = new PromiseSpawn(generatorFunction, this);
		    var ret = spawn.promise();
		    spawn._run(Promise.spawn);
		    return ret;
		};
		};


	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(Promise) {
		var util = __webpack_require__(5);
		var async = __webpack_require__(7);
		var tryCatch = util.tryCatch;
		var errorObj = util.errorObj;

		function spreadAdapter(val, nodeback) {
		    var promise = this;
		    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
		    var ret =
		        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
		    if (ret === errorObj) {
		        async.throwLater(ret.e);
		    }
		}

		function successAdapter(val, nodeback) {
		    var promise = this;
		    var receiver = promise._boundValue();
		    var ret = val === undefined
		        ? tryCatch(nodeback).call(receiver, null)
		        : tryCatch(nodeback).call(receiver, null, val);
		    if (ret === errorObj) {
		        async.throwLater(ret.e);
		    }
		}
		function errorAdapter(reason, nodeback) {
		    var promise = this;
		    if (!reason) {
		        var target = promise._target();
		        var newReason = target._getCarriedStackTrace();
		        newReason.cause = reason;
		        reason = newReason;
		    }
		    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
		    if (ret === errorObj) {
		        async.throwLater(ret.e);
		    }
		}

		Promise.prototype.asCallback =
		Promise.prototype.nodeify = function (nodeback, options) {
		    if (typeof nodeback == "function") {
		        var adapter = successAdapter;
		        if (options !== undefined && Object(options).spread) {
		            adapter = spreadAdapter;
		        }
		        this._then(
		            adapter,
		            errorAdapter,
		            undefined,
		            this,
		            nodeback
		        );
		    }
		    return this;
		};
		};


	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var cr = Object.create;
		if (cr) {
		    var callerCache = cr(null);
		    var getterCache = cr(null);
		    callerCache[" size"] = getterCache[" size"] = 0;
		}

		module.exports = function(Promise) {
		var util = __webpack_require__(5);
		var canEvaluate = util.canEvaluate;
		var isIdentifier = util.isIdentifier;

		var getMethodCaller;
		var getGetter;
		if (true) {
		var makeMethodCaller = function (methodName) {
		    return new Function("ensureMethod", "                                    \n\
		        return function(obj) {                                               \n\
		            'use strict'                                                     \n\
		            var len = this.length;                                           \n\
		            ensureMethod(obj, 'methodName');                                 \n\
		            switch(len) {                                                    \n\
		                case 1: return obj.methodName(this[0]);                      \n\
		                case 2: return obj.methodName(this[0], this[1]);             \n\
		                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
		                case 0: return obj.methodName();                             \n\
		                default:                                                     \n\
		                    return obj.methodName.apply(obj, this);                  \n\
		            }                                                                \n\
		        };                                                                   \n\
		        ".replace(/methodName/g, methodName))(ensureMethod);
		};

		var makeGetter = function (propertyName) {
		    return new Function("obj", "                                             \n\
		        'use strict';                                                        \n\
		        return obj.propertyName;                                             \n\
		        ".replace("propertyName", propertyName));
		};

		var getCompiled = function(name, compiler, cache) {
		    var ret = cache[name];
		    if (typeof ret !== "function") {
		        if (!isIdentifier(name)) {
		            return null;
		        }
		        ret = compiler(name);
		        cache[name] = ret;
		        cache[" size"]++;
		        if (cache[" size"] > 512) {
		            var keys = Object.keys(cache);
		            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
		            cache[" size"] = keys.length - 256;
		        }
		    }
		    return ret;
		};

		getMethodCaller = function(name) {
		    return getCompiled(name, makeMethodCaller, callerCache);
		};

		getGetter = function(name) {
		    return getCompiled(name, makeGetter, getterCache);
		};
		}

		function ensureMethod(obj, methodName) {
		    var fn;
		    if (obj != null) fn = obj[methodName];
		    if (typeof fn !== "function") {
		        var message = "Object " + util.classString(obj) + " has no method '" +
		            util.toString(methodName) + "'";
		        throw new Promise.TypeError(message);
		    }
		    return fn;
		}

		function caller(obj) {
		    var methodName = this.pop();
		    var fn = ensureMethod(obj, methodName);
		    return fn.apply(obj, this);
		}
		Promise.prototype.call = function (methodName) {
		    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
		    if (true) {
		        if (canEvaluate) {
		            var maybeCaller = getMethodCaller(methodName);
		            if (maybeCaller !== null) {
		                return this._then(
		                    maybeCaller, undefined, undefined, args, undefined);
		            }
		        }
		    }
		    args.push(methodName);
		    return this._then(caller, undefined, undefined, args, undefined);
		};

		function namedGetter(obj) {
		    return obj[this];
		}
		function indexedGetter(obj) {
		    var index = +this;
		    if (index < 0) index = Math.max(0, index + obj.length);
		    return obj[index];
		}
		Promise.prototype.get = function (propertyName) {
		    var isIndex = (typeof propertyName === "number");
		    var getter;
		    if (!isIndex) {
		        if (canEvaluate) {
		            var maybeGetter = getGetter(propertyName);
		            getter = maybeGetter !== null ? maybeGetter : namedGetter;
		        } else {
		            getter = namedGetter;
		        }
		    } else {
		        getter = indexedGetter;
		    }
		    return this._then(getter, undefined, undefined, propertyName, undefined);
		};
		};


	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(
		    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
		var util = __webpack_require__(5);
		var isObject = util.isObject;
		var es5 = __webpack_require__(6);

		function PropertiesPromiseArray(obj) {
		    var keys = es5.keys(obj);
		    var len = keys.length;
		    var values = new Array(len * 2);
		    for (var i = 0; i < len; ++i) {
		        var key = keys[i];
		        values[i] = obj[key];
		        values[i + len] = key;
		    }
		    this.constructor$(values);
		}
		util.inherits(PropertiesPromiseArray, PromiseArray);

		PropertiesPromiseArray.prototype._init = function () {
		    this._init$(undefined, -3) ;
		};

		PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
		    this._values[index] = value;
		    var totalResolved = ++this._totalResolved;
		    if (totalResolved >= this._length) {
		        var val = {};
		        var keyOffset = this.length();
		        for (var i = 0, len = this.length(); i < len; ++i) {
		            val[this._values[i + keyOffset]] = this._values[i];
		        }
		        this._resolve(val);
		    }
		};

		PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
		    this._promise._progress({
		        key: this._values[index + this.length()],
		        value: value
		    });
		};

		PropertiesPromiseArray.prototype.shouldCopyValues = function () {
		    return false;
		};

		PropertiesPromiseArray.prototype.getActualLength = function (len) {
		    return len >> 1;
		};

		function props(promises) {
		    var ret;
		    var castValue = tryConvertToPromise(promises);

		    if (!isObject(castValue)) {
		        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
		    } else if (castValue instanceof Promise) {
		        ret = castValue._then(
		            Promise.props, undefined, undefined, undefined, undefined);
		    } else {
		        ret = new PropertiesPromiseArray(castValue).promise();
		    }

		    if (castValue instanceof Promise) {
		        ret._propagateFrom(castValue, 4);
		    }
		    return ret;
		}

		Promise.prototype.props = function () {
		    return props(this);
		};

		Promise.props = function (promises) {
		    return props(promises);
		};
		};


	/***/ },
	/* 32 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(
		    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
		var isArray = __webpack_require__(5).isArray;

		var raceLater = function (promise) {
		    return promise.then(function(array) {
		        return race(array, promise);
		    });
		};

		function race(promises, parent) {
		    var maybePromise = tryConvertToPromise(promises);

		    if (maybePromise instanceof Promise) {
		        return raceLater(maybePromise);
		    } else if (!isArray(promises)) {
		        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
		    }

		    var ret = new Promise(INTERNAL);
		    if (parent !== undefined) {
		        ret._propagateFrom(parent, 4 | 1);
		    }
		    var fulfill = ret._fulfill;
		    var reject = ret._reject;
		    for (var i = 0, len = promises.length; i < len; ++i) {
		        var val = promises[i];

		        if (val === undefined && !(i in promises)) {
		            continue;
		        }

		        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
		    }
		    return ret;
		}

		Promise.race = function (promises) {
		    return race(promises, undefined);
		};

		Promise.prototype.race = function () {
		    return race(this, undefined);
		};

		};


	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(Promise,
		                          PromiseArray,
		                          apiRejection,
		                          tryConvertToPromise,
		                          INTERNAL) {
		var getDomain = Promise._getDomain;
		var async = __webpack_require__(7);
		var util = __webpack_require__(5);
		var tryCatch = util.tryCatch;
		var errorObj = util.errorObj;
		function ReductionPromiseArray(promises, fn, accum, _each) {
		    this.constructor$(promises);
		    this._promise._captureStackTrace();
		    this._preservedValues = _each === INTERNAL ? [] : null;
		    this._zerothIsAccum = (accum === undefined);
		    this._gotAccum = false;
		    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
		    this._valuesPhase = undefined;
		    var maybePromise = tryConvertToPromise(accum, this._promise);
		    var rejected = false;
		    var isPromise = maybePromise instanceof Promise;
		    if (isPromise) {
		        maybePromise = maybePromise._target();
		        if (maybePromise._isPending()) {
		            maybePromise._proxyPromiseArray(this, -1);
		        } else if (maybePromise._isFulfilled()) {
		            accum = maybePromise._value();
		            this._gotAccum = true;
		        } else {
		            this._reject(maybePromise._reason());
		            rejected = true;
		        }
		    }
		    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
		    var domain = getDomain();
		    this._callback = domain === null ? fn : domain.bind(fn);
		    this._accum = accum;
		    if (!rejected) async.invoke(init, this, undefined);
		}
		function init() {
		    this._init$(undefined, -5);
		}
		util.inherits(ReductionPromiseArray, PromiseArray);

		ReductionPromiseArray.prototype._init = function () {};

		ReductionPromiseArray.prototype._resolveEmptyArray = function () {
		    if (this._gotAccum || this._zerothIsAccum) {
		        this._resolve(this._preservedValues !== null
		                        ? [] : this._accum);
		    }
		};

		ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
		    var values = this._values;
		    values[index] = value;
		    var length = this.length();
		    var preservedValues = this._preservedValues;
		    var isEach = preservedValues !== null;
		    var gotAccum = this._gotAccum;
		    var valuesPhase = this._valuesPhase;
		    var valuesPhaseIndex;
		    if (!valuesPhase) {
		        valuesPhase = this._valuesPhase = new Array(length);
		        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
		            valuesPhase[valuesPhaseIndex] = 0;
		        }
		    }
		    valuesPhaseIndex = valuesPhase[index];

		    if (index === 0 && this._zerothIsAccum) {
		        this._accum = value;
		        this._gotAccum = gotAccum = true;
		        valuesPhase[index] = ((valuesPhaseIndex === 0)
		            ? 1 : 2);
		    } else if (index === -1) {
		        this._accum = value;
		        this._gotAccum = gotAccum = true;
		    } else {
		        if (valuesPhaseIndex === 0) {
		            valuesPhase[index] = 1;
		        } else {
		            valuesPhase[index] = 2;
		            this._accum = value;
		        }
		    }
		    if (!gotAccum) return;

		    var callback = this._callback;
		    var receiver = this._promise._boundValue();
		    var ret;

		    for (var i = this._reducingIndex; i < length; ++i) {
		        valuesPhaseIndex = valuesPhase[i];
		        if (valuesPhaseIndex === 2) {
		            this._reducingIndex = i + 1;
		            continue;
		        }
		        if (valuesPhaseIndex !== 1) return;
		        value = values[i];
		        this._promise._pushContext();
		        if (isEach) {
		            preservedValues.push(value);
		            ret = tryCatch(callback).call(receiver, value, i, length);
		        }
		        else {
		            ret = tryCatch(callback)
		                .call(receiver, this._accum, value, i, length);
		        }
		        this._promise._popContext();

		        if (ret === errorObj) return this._reject(ret.e);

		        var maybePromise = tryConvertToPromise(ret, this._promise);
		        if (maybePromise instanceof Promise) {
		            maybePromise = maybePromise._target();
		            if (maybePromise._isPending()) {
		                valuesPhase[i] = 4;
		                return maybePromise._proxyPromiseArray(this, i);
		            } else if (maybePromise._isFulfilled()) {
		                ret = maybePromise._value();
		            } else {
		                return this._reject(maybePromise._reason());
		            }
		        }

		        this._reducingIndex = i + 1;
		        this._accum = ret;
		    }

		    this._resolve(isEach ? preservedValues : this._accum);
		};

		function reduce(promises, fn, initialValue, _each) {
		    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
		    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
		    return array.promise();
		}

		Promise.prototype.reduce = function (fn, initialValue) {
		    return reduce(this, fn, initialValue, null);
		};

		Promise.reduce = function (promises, fn, initialValue, _each) {
		    return reduce(promises, fn, initialValue, _each);
		};
		};


	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports =
		    function(Promise, PromiseArray) {
		var PromiseInspection = Promise.PromiseInspection;
		var util = __webpack_require__(5);

		function SettledPromiseArray(values) {
		    this.constructor$(values);
		}
		util.inherits(SettledPromiseArray, PromiseArray);

		SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
		    this._values[index] = inspection;
		    var totalResolved = ++this._totalResolved;
		    if (totalResolved >= this._length) {
		        this._resolve(this._values);
		    }
		};

		SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
		    var ret = new PromiseInspection();
		    ret._bitField = 268435456;
		    ret._settledValue = value;
		    this._promiseResolved(index, ret);
		};
		SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
		    var ret = new PromiseInspection();
		    ret._bitField = 134217728;
		    ret._settledValue = reason;
		    this._promiseResolved(index, ret);
		};

		Promise.settle = function (promises) {
		    return new SettledPromiseArray(promises).promise();
		};

		Promise.prototype.settle = function () {
		    return new SettledPromiseArray(this).promise();
		};
		};


	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports =
		function(Promise, PromiseArray, apiRejection) {
		var util = __webpack_require__(5);
		var RangeError = __webpack_require__(10).RangeError;
		var AggregateError = __webpack_require__(10).AggregateError;
		var isArray = util.isArray;


		function SomePromiseArray(values) {
		    this.constructor$(values);
		    this._howMany = 0;
		    this._unwrap = false;
		    this._initialized = false;
		}
		util.inherits(SomePromiseArray, PromiseArray);

		SomePromiseArray.prototype._init = function () {
		    if (!this._initialized) {
		        return;
		    }
		    if (this._howMany === 0) {
		        this._resolve([]);
		        return;
		    }
		    this._init$(undefined, -5);
		    var isArrayResolved = isArray(this._values);
		    if (!this._isResolved() &&
		        isArrayResolved &&
		        this._howMany > this._canPossiblyFulfill()) {
		        this._reject(this._getRangeError(this.length()));
		    }
		};

		SomePromiseArray.prototype.init = function () {
		    this._initialized = true;
		    this._init();
		};

		SomePromiseArray.prototype.setUnwrap = function () {
		    this._unwrap = true;
		};

		SomePromiseArray.prototype.howMany = function () {
		    return this._howMany;
		};

		SomePromiseArray.prototype.setHowMany = function (count) {
		    this._howMany = count;
		};

		SomePromiseArray.prototype._promiseFulfilled = function (value) {
		    this._addFulfilled(value);
		    if (this._fulfilled() === this.howMany()) {
		        this._values.length = this.howMany();
		        if (this.howMany() === 1 && this._unwrap) {
		            this._resolve(this._values[0]);
		        } else {
		            this._resolve(this._values);
		        }
		    }

		};
		SomePromiseArray.prototype._promiseRejected = function (reason) {
		    this._addRejected(reason);
		    if (this.howMany() > this._canPossiblyFulfill()) {
		        var e = new AggregateError();
		        for (var i = this.length(); i < this._values.length; ++i) {
		            e.push(this._values[i]);
		        }
		        this._reject(e);
		    }
		};

		SomePromiseArray.prototype._fulfilled = function () {
		    return this._totalResolved;
		};

		SomePromiseArray.prototype._rejected = function () {
		    return this._values.length - this.length();
		};

		SomePromiseArray.prototype._addRejected = function (reason) {
		    this._values.push(reason);
		};

		SomePromiseArray.prototype._addFulfilled = function (value) {
		    this._values[this._totalResolved++] = value;
		};

		SomePromiseArray.prototype._canPossiblyFulfill = function () {
		    return this.length() - this._rejected();
		};

		SomePromiseArray.prototype._getRangeError = function (count) {
		    var message = "Input array must contain at least " +
		            this._howMany + " items but contains only " + count + " items";
		    return new RangeError(message);
		};

		SomePromiseArray.prototype._resolveEmptyArray = function () {
		    this._reject(this._getRangeError(0));
		};

		function some(promises, howMany) {
		    if ((howMany | 0) !== howMany || howMany < 0) {
		        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
		    }
		    var ret = new SomePromiseArray(promises);
		    var promise = ret.promise();
		    ret.setHowMany(howMany);
		    ret.init();
		    return promise;
		}

		Promise.some = function (promises, howMany) {
		    return some(promises, howMany);
		};

		Promise.prototype.some = function (howMany) {
		    return some(this, howMany);
		};

		Promise._SomePromiseArray = SomePromiseArray;
		};


	/***/ },
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(Promise, INTERNAL) {
		var THIS = {};
		var util = __webpack_require__(5);
		var nodebackForPromise = __webpack_require__(17)
		    ._nodebackForPromise;
		var withAppended = util.withAppended;
		var maybeWrapAsError = util.maybeWrapAsError;
		var canEvaluate = util.canEvaluate;
		var TypeError = __webpack_require__(10).TypeError;
		var defaultSuffix = "Async";
		var defaultPromisified = {__isPromisified__: true};
		var noCopyProps = [
		    "arity",    "length",
		    "name",
		    "arguments",
		    "caller",
		    "callee",
		    "prototype",
		    "__isPromisified__"
		];
		var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

		var defaultFilter = function(name) {
		    return util.isIdentifier(name) &&
		        name.charAt(0) !== "_" &&
		        name !== "constructor";
		};

		function propsFilter(key) {
		    return !noCopyPropsPattern.test(key);
		}

		function isPromisified(fn) {
		    try {
		        return fn.__isPromisified__ === true;
		    }
		    catch (e) {
		        return false;
		    }
		}

		function hasPromisified(obj, key, suffix) {
		    var val = util.getDataPropertyOrDefault(obj, key + suffix,
		                                            defaultPromisified);
		    return val ? isPromisified(val) : false;
		}
		function checkValid(ret, suffix, suffixRegexp) {
		    for (var i = 0; i < ret.length; i += 2) {
		        var key = ret[i];
		        if (suffixRegexp.test(key)) {
		            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
		            for (var j = 0; j < ret.length; j += 2) {
		                if (ret[j] === keyWithoutAsyncSuffix) {
		                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
		                        .replace("%s", suffix));
		                }
		            }
		        }
		    }
		}

		function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
		    var keys = util.inheritedDataKeys(obj);
		    var ret = [];
		    for (var i = 0; i < keys.length; ++i) {
		        var key = keys[i];
		        var value = obj[key];
		        var passesDefaultFilter = filter === defaultFilter
		            ? true : defaultFilter(key, value, obj);
		        if (typeof value === "function" &&
		            !isPromisified(value) &&
		            !hasPromisified(obj, key, suffix) &&
		            filter(key, value, obj, passesDefaultFilter)) {
		            ret.push(key, value);
		        }
		    }
		    checkValid(ret, suffix, suffixRegexp);
		    return ret;
		}

		var escapeIdentRegex = function(str) {
		    return str.replace(/([$])/, "\\$");
		};

		var makeNodePromisifiedEval;
		if (true) {
		var switchCaseArgumentOrder = function(likelyArgumentCount) {
		    var ret = [likelyArgumentCount];
		    var min = Math.max(0, likelyArgumentCount - 1 - 3);
		    for(var i = likelyArgumentCount - 1; i >= min; --i) {
		        ret.push(i);
		    }
		    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
		        ret.push(i);
		    }
		    return ret;
		};

		var argumentSequence = function(argumentCount) {
		    return util.filledRange(argumentCount, "_arg", "");
		};

		var parameterDeclaration = function(parameterCount) {
		    return util.filledRange(
		        Math.max(parameterCount, 3), "_arg", "");
		};

		var parameterCount = function(fn) {
		    if (typeof fn.length === "number") {
		        return Math.max(Math.min(fn.length, 1023 + 1), 0);
		    }
		    return 0;
		};

		makeNodePromisifiedEval =
		function(callback, receiver, originalName, fn) {
		    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
		    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
		    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

		    function generateCallForArgumentCount(count) {
		        var args = argumentSequence(count).join(", ");
		        var comma = count > 0 ? ", " : "";
		        var ret;
		        if (shouldProxyThis) {
		            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
		        } else {
		            ret = receiver === undefined
		                ? "ret = callback({{args}}, nodeback); break;\n"
		                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
		        }
		        return ret.replace("{{args}}", args).replace(", ", comma);
		    }

		    function generateArgumentSwitchCase() {
		        var ret = "";
		        for (var i = 0; i < argumentOrder.length; ++i) {
		            ret += "case " + argumentOrder[i] +":" +
		                generateCallForArgumentCount(argumentOrder[i]);
		        }

		        ret += "                                                             \n\
		        default:                                                             \n\
		            var args = new Array(len + 1);                                   \n\
		            var i = 0;                                                       \n\
		            for (var i = 0; i < len; ++i) {                                  \n\
		               args[i] = arguments[i];                                       \n\
		            }                                                                \n\
		            args[i] = nodeback;                                              \n\
		            [CodeForCall]                                                    \n\
		            break;                                                           \n\
		        ".replace("[CodeForCall]", (shouldProxyThis
		                                ? "ret = callback.apply(this, args);\n"
		                                : "ret = callback.apply(receiver, args);\n"));
		        return ret;
		    }

		    var getFunctionCode = typeof callback === "string"
		                                ? ("this != null ? this['"+callback+"'] : fn")
		                                : "fn";

		    return new Function("Promise",
		                        "fn",
		                        "receiver",
		                        "withAppended",
		                        "maybeWrapAsError",
		                        "nodebackForPromise",
		                        "tryCatch",
		                        "errorObj",
		                        "notEnumerableProp",
		                        "INTERNAL","'use strict';                            \n\
		        var ret = function (Parameters) {                                    \n\
		            'use strict';                                                    \n\
		            var len = arguments.length;                                      \n\
		            var promise = new Promise(INTERNAL);                             \n\
		            promise._captureStackTrace();                                    \n\
		            var nodeback = nodebackForPromise(promise);                      \n\
		            var ret;                                                         \n\
		            var callback = tryCatch([GetFunctionCode]);                      \n\
		            switch(len) {                                                    \n\
		                [CodeForSwitchCase]                                          \n\
		            }                                                                \n\
		            if (ret === errorObj) {                                          \n\
		                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
		            }                                                                \n\
		            return promise;                                                  \n\
		        };                                                                   \n\
		        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
		        return ret;                                                          \n\
		        "
		        .replace("Parameters", parameterDeclaration(newParameterCount))
		        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
		        .replace("[GetFunctionCode]", getFunctionCode))(
		            Promise,
		            fn,
		            receiver,
		            withAppended,
		            maybeWrapAsError,
		            nodebackForPromise,
		            util.tryCatch,
		            util.errorObj,
		            util.notEnumerableProp,
		            INTERNAL
		        );
		};
		}

		function makeNodePromisifiedClosure(callback, receiver, _, fn) {
		    var defaultThis = (function() {return this;})();
		    var method = callback;
		    if (typeof method === "string") {
		        callback = fn;
		    }
		    function promisified() {
		        var _receiver = receiver;
		        if (receiver === THIS) _receiver = this;
		        var promise = new Promise(INTERNAL);
		        promise._captureStackTrace();
		        var cb = typeof method === "string" && this !== defaultThis
		            ? this[method] : callback;
		        var fn = nodebackForPromise(promise);
		        try {
		            cb.apply(_receiver, withAppended(arguments, fn));
		        } catch(e) {
		            promise._rejectCallback(maybeWrapAsError(e), true, true);
		        }
		        return promise;
		    }
		    util.notEnumerableProp(promisified, "__isPromisified__", true);
		    return promisified;
		}

		var makeNodePromisified = canEvaluate
		    ? makeNodePromisifiedEval
		    : makeNodePromisifiedClosure;

		function promisifyAll(obj, suffix, filter, promisifier) {
		    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
		    var methods =
		        promisifiableMethods(obj, suffix, suffixRegexp, filter);

		    for (var i = 0, len = methods.length; i < len; i+= 2) {
		        var key = methods[i];
		        var fn = methods[i+1];
		        var promisifiedKey = key + suffix;
		        obj[promisifiedKey] = promisifier === makeNodePromisified
		                ? makeNodePromisified(key, THIS, key, fn, suffix)
		                : promisifier(fn, function() {
		                    return makeNodePromisified(key, THIS, key, fn, suffix);
		                });
		    }
		    util.toFastProperties(obj);
		    return obj;
		}

		function promisify(callback, receiver) {
		    return makeNodePromisified(callback, receiver, undefined, callback);
		}

		Promise.promisify = function (fn, receiver) {
		    if (typeof fn !== "function") {
		        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
		    }
		    if (isPromisified(fn)) {
		        return fn;
		    }
		    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
		    util.copyDescriptors(fn, ret, propsFilter);
		    return ret;
		};

		Promise.promisifyAll = function (target, options) {
		    if (typeof target !== "function" && typeof target !== "object") {
		        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
		    }
		    options = Object(options);
		    var suffix = options.suffix;
		    if (typeof suffix !== "string") suffix = defaultSuffix;
		    var filter = options.filter;
		    if (typeof filter !== "function") filter = defaultFilter;
		    var promisifier = options.promisifier;
		    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

		    if (!util.isIdentifier(suffix)) {
		        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
		    }

		    var keys = util.inheritedDataKeys(target);
		    for (var i = 0; i < keys.length; ++i) {
		        var value = target[keys[i]];
		        if (keys[i] !== "constructor" &&
		            util.isClass(value)) {
		            promisifyAll(value.prototype, suffix, filter, promisifier);
		            promisifyAll(value, suffix, filter, promisifier);
		        }
		    }

		    return promisifyAll(target, suffix, filter, promisifier);
		};
		};



	/***/ },
	/* 37 */
	/***/ function(module, exports) {

		"use strict";
		module.exports = function(Promise) {
		var SomePromiseArray = Promise._SomePromiseArray;
		function any(promises) {
		    var ret = new SomePromiseArray(promises);
		    var promise = ret.promise();
		    ret.setHowMany(1);
		    ret.setUnwrap();
		    ret.init();
		    return promise;
		}

		Promise.any = function (promises) {
		    return any(promises);
		};

		Promise.prototype.any = function () {
		    return any(this);
		};

		};


	/***/ },
	/* 38 */
	/***/ function(module, exports) {

		"use strict";
		module.exports = function(Promise, INTERNAL) {
		var PromiseReduce = Promise.reduce;

		Promise.prototype.each = function (fn) {
		    return PromiseReduce(this, fn, null, INTERNAL);
		};

		Promise.each = function (promises, fn) {
		    return PromiseReduce(promises, fn, null, INTERNAL);
		};
		};


	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		module.exports = function(Promise, INTERNAL) {
		var util = __webpack_require__(5);
		var TimeoutError = Promise.TimeoutError;

		var afterTimeout = function (promise, message) {
		    if (!promise.isPending()) return;
		    if (typeof message !== "string") {
		        message = "operation timed out";
		    }
		    var err = new TimeoutError(message);
		    util.markAsOriginatingFromRejection(err);
		    promise._attachExtraTrace(err);
		    promise._cancel(err);
		};

		var afterValue = function(value) { return delay(+this).thenReturn(value); };
		var delay = Promise.delay = function (value, ms) {
		    if (ms === undefined) {
		        ms = value;
		        value = undefined;
		        var ret = new Promise(INTERNAL);
		        setTimeout(function() { ret._fulfill(); }, ms);
		        return ret;
		    }
		    ms = +ms;
		    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
		};

		Promise.prototype.delay = function (ms) {
		    return delay(this, ms);
		};

		function successClear(value) {
		    var handle = this;
		    if (handle instanceof Number) handle = +handle;
		    clearTimeout(handle);
		    return value;
		}

		function failureClear(reason) {
		    var handle = this;
		    if (handle instanceof Number) handle = +handle;
		    clearTimeout(handle);
		    throw reason;
		}

		Promise.prototype.timeout = function (ms, message) {
		    ms = +ms;
		    var ret = this.then().cancellable();
		    ret._cancellationParent = this;
		    var handle = setTimeout(function timeoutTimeout() {
		        afterTimeout(ret, message);
		    }, ms);
		    return ret._then(successClear, failureClear, undefined, handle, undefined);
		};

		};


	/***/ },
	/* 40 */
	/***/ function(module, exports) {

		"use strict";
		module.exports = function(Promise, INTERNAL) {
		var PromiseMap = Promise.map;

		Promise.prototype.filter = function (fn, options) {
		    return PromiseMap(this, fn, options, INTERNAL);
		};

		Promise.filter = function (promises, fn, options) {
		    return PromiseMap(promises, fn, options, INTERNAL);
		};
		};


	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {

		var protodef = __webpack_require__(42);
		var termTypes = protodef.Term.TermType;
		var datumTypes = protodef.Datum.DatumType;
		var net = __webpack_require__(43);


		function createLogger(poolMaster, silent) {
		  return function(message) {
		    if (silent !== true) {
		      console.error(message);
		    }
		    poolMaster.emit('log', message);
		  }
		}
		module.exports.createLogger = createLogger;

		function isPlainObject(obj) {
		  return Object.prototype.toString.call(obj) === '[object Object]';
		}
		module.exports.isPlainObject = isPlainObject;

		function toArray(args) {
		  return Array.prototype.slice.call(args);
		}
		module.exports.toArray = toArray;

		function hasImplicit(arg) {
		  if (Array.isArray(arg)) {
		    if (arg[0] === termTypes.IMPLICIT_VAR) return true;

		    if (Array.isArray(arg[1])) {
		      for(var i=0; i<arg[1].length; i++) {
		        if (hasImplicit(arg[1][i])) return true;
		      }
		    }
		    if (isPlainObject(arg[2])) {
		      for(var key in arg[2]) {
		        if (hasImplicit(arg[2][key])) return true;
		      }
		    }
		  }
		  else if (isPlainObject(arg)) {
		    for(var key in arg) {
		      if (hasImplicit(arg[key])) return true;
		    }
		  }
		  return false;
		}
		module.exports.hasImplicit = hasImplicit;

		function loopKeys(obj, fn) {
		  var keys = Object.keys(obj);
		  var result;
		  var keysLength = keys.length;
		  for(var i=0; i<keysLength; i++) {
		    result = fn(obj, keys[i]);
		    if (result === false) return;
		  }
		}
		module.exports.loopKeys = loopKeys;

		function convertPseudoType(obj, options) {
		  if (Array.isArray(obj)) {
		    for(var i=0; i<obj.length; i++) {
		      obj[i] = convertPseudoType(obj[i], options);
		    }
		  }
		  else if (isPlainObject(obj)) {
		    if ((options.timeFormat != 'raw') && (obj.$reql_type$ === 'TIME')) {
		      obj = new Date(obj.epoch_time*1000);
		    }
		    else if ((options.binaryFormat != 'raw') && (obj.$reql_type$ === 'BINARY')) {
		      obj = new Buffer(obj.data, 'base64');
		    }
		    else if ((options.groupFormat != 'raw') && (obj.$reql_type$ === 'GROUPED_DATA')) {
		      var result = [];
		      for(var i=0; i<obj.data.length; i++) {
		        result.push({
		          group: obj.data[i][0],
		          reduction: obj.data[i][1],
		        })
		      }
		      obj = result;
		    }
		    else{
		      for(var key in obj) {
		        if (obj.hasOwnProperty(key)) {
		          obj[key] = convertPseudoType(obj[key], options);
		        }
		      }
		    }
		  }
		  return obj;
		}
		function makeAtom(response, options) {
		  options = options || {};
		  return convertPseudoType(response.r[0], options);
		}
		module.exports.makeAtom = makeAtom;

		function makeSequence(response, options) {
		  var result = [];
		  options = options || {};

		  return convertPseudoType(response.r, options);
		}

		module.exports.makeSequence = makeSequence;

		function changeProto(object, other) {
		  object.__proto__ = other.__proto__;
		}
		module.exports.changeProto = changeProto;

		// Try to extract the most global address
		// Note: Mutate the input
		function getCanonicalAddress(addresses) {
		  // We suppose that the addresses are all valid, and therefore use loose regex
		  for(var i=0; i<addresses.length; i++) {
		    var addresse = addresses[i];
		    if ((/^127(\.\d{1,3}){3}$/.test(addresse.host)) || (/0?:?0?:?0?:?0?:?0?:?0?:0?:1/.test(addresse.host))) {
		      addresse.value = 0;
		    }
		    else if ((net.isIPv6(addresse.host)) && (/^[fF]|[eE]80:.*\:.*\:/.test(addresse.host))) {
		      addresse.value = 1;
		    }
		    else if (/^169\.254\.\d{1,3}\.\d{1,3}$/.test(addresse.host)) {
		      addresse.value = 2;
		    }
		    else if (/^192\.168\.\d{1,3}\.\d{1,3}$/.test(addresse.host)) {
		      addresse.value = 3;
		    }
		    else if (/^172\.(1\d|2\d|30|31)\.\d{1,3}\.\d{1,3}$/.test(addresse.host)) {
		      addresse.value = 4;
		    }
		    else if (/^10(\.\d{1,3}){3}$/.test(addresse.host)) {
		      addresse.value = 5;
		    }
		    else if ((net.isIPv6(addresse.host)) && (/^[fF]|[cCdD].*\:.*\:/.test('addresse.host'))) {
		      addresse.value = 6;
		    }
		    else {
		      addresse.value = 7;
		    }
		  }
		  var result = addresses[0];
		  var max = addresses[0].value;
		  for(var i=0; i<addresses.length; i++) {
		    if (addresses[i].value > max) {
		      result = addresses[i];
		      max = addresses[i].value;
		    }
		  }
		  return result;
		}
		module.exports.getCanonicalAddress = getCanonicalAddress;


		module.exports.localhostAliases = {
		  'localhost': true,
		  '127.0.0.1': true,
		  '::1': true
		}

		module.exports.tryCatch = function tryCatch(toTry, handleError) {
		  try{
		  toTry()
		  }
		  catch(err) {
		  handleError(err)
		  }
		}


	/***/ },
	/* 42 */
	/***/ function(module, exports) {

		// DO NOT EDIT
		// Autogenerated by convert_protofile

		module.exports = {
			VersionDummy: {
				Version: {
					V0_1: 1063369270,
					V0_2: 1915781601,
					V0_3: 1601562686,
					V0_4: 1074539808
				},

				Protocol: {
					PROTOBUF: 656407617,
					JSON: 2120839367
				}
			},

			Query: {
				QueryType: {
					START: 1,
					CONTINUE: 2,
					STOP: 3,
					NOREPLY_WAIT: 4
				},

				AssocPair: {}
			},

			Frame: {
				FrameType: {
					POS: 1,
					OPT: 2
				}
			},

			Backtrace: {},

			Response: {
				ResponseType: {
					SUCCESS_ATOM: 1,
					SUCCESS_SEQUENCE: 2,
					SUCCESS_PARTIAL: 3,
					WAIT_COMPLETE: 4,
					CLIENT_ERROR: 16,
					COMPILE_ERROR: 17,
					RUNTIME_ERROR: 18
				},

				ErrorType: {
					INTERNAL: 1000000,
					RESOURCE: 2000000,
					LOGIC: 3000000,
					NON_EXISTENCE: 3100000,
					OP_FAILED: 4100000,
					OP_INDETERMINATE: 4200000,
					USER: 5000000
				},

				ResponseNote: {
					SEQUENCE_FEED: 1,
					ATOM_FEED: 2,
					ORDER_BY_LIMIT_FEED: 3,
					UNIONED_FEED: 4,
					INCLUDES_STATES: 5
				}
			},

			Datum: {
				DatumType: {
					R_NULL: 1,
					R_BOOL: 2,
					R_NUM: 3,
					R_STR: 4,
					R_ARRAY: 5,
					R_OBJECT: 6,
					R_JSON: 7
				},

				AssocPair: {}
			},

			Term: {
				TermType: {
					DATUM: 1,
					MAKE_ARRAY: 2,
					MAKE_OBJ: 3,
					VAR: 10,
					JAVASCRIPT: 11,
					UUID: 169,
					HTTP: 153,
					ERROR: 12,
					IMPLICIT_VAR: 13,
					DB: 14,
					TABLE: 15,
					GET: 16,
					GET_ALL: 78,
					EQ: 17,
					NE: 18,
					LT: 19,
					LE: 20,
					GT: 21,
					GE: 22,
					NOT: 23,
					ADD: 24,
					SUB: 25,
					MUL: 26,
					DIV: 27,
					MOD: 28,
					FLOOR: 183,
					CEIL: 184,
					ROUND: 185,
					APPEND: 29,
					PREPEND: 80,
					DIFFERENCE: 95,
					SET_INSERT: 88,
					SET_INTERSECTION: 89,
					SET_UNION: 90,
					SET_DIFFERENCE: 91,
					SLICE: 30,
					SKIP: 70,
					LIMIT: 71,
					OFFSETS_OF: 87,
					CONTAINS: 93,
					GET_FIELD: 31,
					KEYS: 94,
					OBJECT: 143,
					HAS_FIELDS: 32,
					WITH_FIELDS: 96,
					PLUCK: 33,
					WITHOUT: 34,
					MERGE: 35,
					BETWEEN_DEPRECATED: 36,
					BETWEEN: 182,
					REDUCE: 37,
					MAP: 38,
					FILTER: 39,
					CONCAT_MAP: 40,
					ORDER_BY: 41,
					DISTINCT: 42,
					COUNT: 43,
					IS_EMPTY: 86,
					UNION: 44,
					NTH: 45,
					BRACKET: 170,
					INNER_JOIN: 48,
					OUTER_JOIN: 49,
					EQ_JOIN: 50,
					ZIP: 72,
					RANGE: 173,
					INSERT_AT: 82,
					DELETE_AT: 83,
					CHANGE_AT: 84,
					SPLICE_AT: 85,
					COERCE_TO: 51,
					TYPE_OF: 52,
					UPDATE: 53,
					DELETE: 54,
					REPLACE: 55,
					INSERT: 56,
					DB_CREATE: 57,
					DB_DROP: 58,
					DB_LIST: 59,
					TABLE_CREATE: 60,
					TABLE_DROP: 61,
					TABLE_LIST: 62,
					CONFIG: 174,
					STATUS: 175,
					WAIT: 177,
					RECONFIGURE: 176,
					REBALANCE: 179,
					SYNC: 138,
					INDEX_CREATE: 75,
					INDEX_DROP: 76,
					INDEX_LIST: 77,
					INDEX_STATUS: 139,
					INDEX_WAIT: 140,
					INDEX_RENAME: 156,
					FUNCALL: 64,
					BRANCH: 65,
					OR: 66,
					AND: 67,
					FOR_EACH: 68,
					FUNC: 69,
					ASC: 73,
					DESC: 74,
					INFO: 79,
					MATCH: 97,
					UPCASE: 141,
					DOWNCASE: 142,
					SAMPLE: 81,
					DEFAULT: 92,
					JSON: 98,
					TO_JSON_STRING: 172,
					ISO8601: 99,
					TO_ISO8601: 100,
					EPOCH_TIME: 101,
					TO_EPOCH_TIME: 102,
					NOW: 103,
					IN_TIMEZONE: 104,
					DURING: 105,
					DATE: 106,
					TIME_OF_DAY: 126,
					TIMEZONE: 127,
					YEAR: 128,
					MONTH: 129,
					DAY: 130,
					DAY_OF_WEEK: 131,
					DAY_OF_YEAR: 132,
					HOURS: 133,
					MINUTES: 134,
					SECONDS: 135,
					TIME: 136,
					MONDAY: 107,
					TUESDAY: 108,
					WEDNESDAY: 109,
					THURSDAY: 110,
					FRIDAY: 111,
					SATURDAY: 112,
					SUNDAY: 113,
					JANUARY: 114,
					FEBRUARY: 115,
					MARCH: 116,
					APRIL: 117,
					MAY: 118,
					JUNE: 119,
					JULY: 120,
					AUGUST: 121,
					SEPTEMBER: 122,
					OCTOBER: 123,
					NOVEMBER: 124,
					DECEMBER: 125,
					LITERAL: 137,
					GROUP: 144,
					SUM: 145,
					AVG: 146,
					MIN: 147,
					MAX: 148,
					SPLIT: 149,
					UNGROUP: 150,
					RANDOM: 151,
					CHANGES: 152,
					ARGS: 154,
					BINARY: 155,
					GEOJSON: 157,
					TO_GEOJSON: 158,
					POINT: 159,
					LINE: 160,
					POLYGON: 161,
					DISTANCE: 162,
					INTERSECTS: 163,
					INCLUDES: 164,
					CIRCLE: 165,
					GET_INTERSECTING: 166,
					FILL: 167,
					GET_NEAREST: 168,
					POLYGON_SUB: 171,
					MINVAL: 180,
					MAXVAL: 181
				},

				AssocPair: {}
			}
		}


	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		Object.defineProperty(exports, '__esModule', {
		  value: true
		});
		exports.configureTcpPolyfill = configureTcpPolyfill;
		exports.Socket = Socket;
		exports.connect = connect;

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var _blobToBuffer = __webpack_require__(44);

		var _blobToBuffer2 = _interopRequireDefault(_blobToBuffer);

		var _eventemitter2 = __webpack_require__(47);

		var _eventemitter22 = _interopRequireDefault(_eventemitter2);

		var tcpPolyfillOptions = {
		  path: '/',
		  secure: false,
		  wsProtocols: undefined,
		  simulatedLatencyMs: undefined
		};

		var notImpl = function notImpl(name) {
		  return function () {
		    throw new Error('Not implemented in TcpPolyfill: ' + name);
		  };
		};

		function configureTcpPolyfill(options) {
		  tcpPolyfillOptions.path = options.path;
		  tcpPolyfillOptions.secure = options.secure;
		  tcpPolyfillOptions.wsProtocols = options.wsProtocols;
		  tcpPolyfillOptions.simulatedLatencyMs = options.simulatedLatencyMs;
		}

		function Socket(options) {
		  var _this = this;

		  if (!(this instanceof Socket)) {
		    return new Socket(options);
		  }

		  var emitter = new _eventemitter22['default']({});
		  ['on', 'once', 'removeListener', 'emit', 'addListener', 'removeAllListeners', 'setMaxListeners', 'listeners'].forEach(function (method) {
		    _this[method] = emitter[method].bind(emitter);
		  });

		  var ws = null;

		  this.connect = function (port, host, connectListener) {
		    _this._simulatedLatencyMs = tcpPolyfillOptions.simulatedLatencyMs;
		    var protocol = tcpPolyfillOptions.secure ? 'wss' : 'ws';
		    var path = tcpPolyfillOptions.path;
		    var url = protocol + '://' + host + ':' + port + path;
		    ws = new WebSocket(url, tcpPolyfillOptions.wsProtocols);
		    if (connectListener) {
		      emitter.on('connect', connectListener);
		    }

		    ws.onopen = function (event) {
		      emitter.emit('connect');
		    };

		    ws.onclose = function (event) {
		      emitter.emit('end');
		      emitter.emit('close');
		    };

		    ws.onerror = function (event) {
		      emitter.emit('error', event);
		    };

		    ws.onmessage = function (event) {
		      var data = event.data;
		      if (typeof Blob !== 'undefined' && data instanceof Blob) {
		        (0, _blobToBuffer2['default'])(data, function (err, buffer) {
		          if (err) {
		            throw err;
		          }
		          emitter.emit('data', buffer);
		        });
		      } else {
		        emitter.emit('data', data);
		      }
		    };
		  };

		  this.end = function (data) {
		    if (data !== undefined) {
		      _this.write(data);
		    }
		    ws.close();
		  };

		  this.destroy = function () {
		    ws.close();
		  };

		  this.write = function (data) {
		    // Convert data (string or node.js Buffer) to ArrayBuffer for WebSocket
		    var arrayBuffer = new ArrayBuffer(data.length);
		    var view = new Uint8Array(arrayBuffer);
		    for (var i = 0; i < data.length; ++i) {
		      view[i] = data[i];
		    }
		    var delay = _this._simulatedLatencyMs;
		    if (typeof delay === 'number' && delay > 0) {
		      setTimeout(function () {
		        return ws.send(arrayBuffer);
		      }, delay);
		    } else {
		      ws.send(arrayBuffer);
		    }
		  };

		  this.setNoDelay = function (noDelay) {};
		  this.setKeepAlive = function (enable, initialDelay) {};

		  var notImplMethods = ['setEncoding', 'pause', 'resume', 'setTimeout', 'address', 'unref', 'ref'];
		  notImplMethods.forEach(function (name) {
		    _this[name] = notImpl(name);
		  });
		}

		function connect() {
		  var opts = {};
		  if (arguments[0] && typeof arguments[0] === 'object') {
		    opts.port = arguments[0].port;
		    opts.host = arguments[0].host;
		    opts.connectListener = arguments[1];
		  } else if (Number(arguments[0]) > 0) {
		    opts.port = arguments[0];
		    opts.host = arguments[1];
		    opts.connectListener = arguments[2];
		  } else {
		    throw new Error('Unsupported arguments for net.connect');
		  }
		  var socket = new Socket();
		  socket.connect(opts.port, opts.host, opts.connectListener);
		  return socket;
		}

		var createConnection = connect;

		exports.createConnection = createConnection;
		var createServer = notImpl('createServer');

		exports.createServer = createServer;
		// This is wrong, but irrelevant for connecting via websocket
		var isIPv4 = function isIPv4(input) {
		  return true;
		};
		exports.isIPv4 = isIPv4;
		var isIPv6 = function isIPv6(input) {
		  return false;
		};
		exports.isIPv6 = isIPv6;
		var isIP = function isIP(input) {
		  return isIPv4(input) ? 4 : isIPv6(input) ? 6 : 0;
		};
		exports.isIP = isIP;

	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {

		/* global Blob, FileReader */

		// arraybuffer -> buffer without copy
		var toBuffer = __webpack_require__(45)

		module.exports = function blobToBuffer (blob, cb) {
		  if (typeof Blob === 'undefined' || !(blob instanceof Blob)) {
		    throw new Error('first argument must be a Blob')
		  }
		  if (typeof cb !== 'function') {
		    throw new Error('second argument must be a function')
		  }

		  var reader = new FileReader()

		  function onLoadEnd (e) {
		    reader.removeEventListener('loadend', onLoadEnd, false)
		    if (e.error) cb(e.error)
		    else cb(null, toBuffer(reader.result))
		  }

		  reader.addEventListener('loadend', onLoadEnd, false)
		  reader.readAsArrayBuffer(blob)
		}


	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Convert a typed array to a Buffer without a copy
		 *
		 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
		 * License:  MIT
		 *
		 * `npm install typedarray-to-buffer`
		 */

		var isTypedArray = __webpack_require__(46).strict

		module.exports = function (arr) {
		  // If `Buffer` is the browser `buffer` module, and the browser supports typed arrays,
		  // then avoid a copy. Otherwise, create a `Buffer` with a copy.
		  var constructor = Buffer.TYPED_ARRAY_SUPPORT
		    ? Buffer._augment
		    : function (arr) { return new Buffer(arr) }

		  if (arr instanceof Uint8Array) {
		    return constructor(arr)
		  } else if (arr instanceof ArrayBuffer) {
		    return constructor(new Uint8Array(arr))
		  } else if (isTypedArray(arr)) {
		    // Use the typed array's underlying ArrayBuffer to back new Buffer. This respects
		    // the "view" on the ArrayBuffer, i.e. byteOffset and byteLength. No copy.
		    return constructor(new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength))
		  } else {
		    // Unsupported type, just pass it through to the `Buffer` constructor.
		    return new Buffer(arr)
		  }
		}


	/***/ },
	/* 46 */
	/***/ function(module, exports) {

		module.exports      = isTypedArray
		isTypedArray.strict = isStrictTypedArray
		isTypedArray.loose  = isLooseTypedArray

		var toString = Object.prototype.toString
		var names = {
		    '[object Int8Array]': true
		  , '[object Int16Array]': true
		  , '[object Int32Array]': true
		  , '[object Uint8Array]': true
		  , '[object Uint8ClampedArray]': true
		  , '[object Uint16Array]': true
		  , '[object Uint32Array]': true
		  , '[object Float32Array]': true
		  , '[object Float64Array]': true
		}

		function isTypedArray(arr) {
		  return (
		       isStrictTypedArray(arr)
		    || isLooseTypedArray(arr)
		  )
		}

		function isStrictTypedArray(arr) {
		  return (
		       arr instanceof Int8Array
		    || arr instanceof Int16Array
		    || arr instanceof Int32Array
		    || arr instanceof Uint8Array
		    || arr instanceof Uint8ClampedArray
		    || arr instanceof Uint16Array
		    || arr instanceof Uint32Array
		    || arr instanceof Float32Array
		    || arr instanceof Float64Array
		  )
		}

		function isLooseTypedArray(arr) {
		  return names[toString.call(arr)]
		}


	/***/ },
	/* 47 */
	/***/ function(module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_RESULT__;/*!
		 * EventEmitter2
		 * https://github.com/hij1nx/EventEmitter2
		 *
		 * Copyright (c) 2013 hij1nx
		 * Licensed under the MIT license.
		 */
		;!function(undefined) {

		  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
		    return Object.prototype.toString.call(obj) === "[object Array]";
		  };
		  var defaultMaxListeners = 10;

		  function init() {
		    this._events = {};
		    if (this._conf) {
		      configure.call(this, this._conf);
		    }
		  }

		  function configure(conf) {
		    if (conf) {

		      this._conf = conf;

		      conf.delimiter && (this.delimiter = conf.delimiter);
		      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);
		      conf.wildcard && (this.wildcard = conf.wildcard);
		      conf.newListener && (this.newListener = conf.newListener);

		      if (this.wildcard) {
		        this.listenerTree = {};
		      }
		    }
		  }

		  function EventEmitter(conf) {
		    this._events = {};
		    this.newListener = false;
		    configure.call(this, conf);
		  }

		  //
		  // Attention, function return type now is array, always !
		  // It has zero elements if no any matches found and one or more
		  // elements (leafs) if there are matches
		  //
		  function searchListenerTree(handlers, type, tree, i) {
		    if (!tree) {
		      return [];
		    }
		    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,
		        typeLength = type.length, currentType = type[i], nextType = type[i+1];
		    if (i === typeLength && tree._listeners) {
		      //
		      // If at the end of the event(s) list and the tree has listeners
		      // invoke those listeners.
		      //
		      if (typeof tree._listeners === 'function') {
		        handlers && handlers.push(tree._listeners);
		        return [tree];
		      } else {
		        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
		          handlers && handlers.push(tree._listeners[leaf]);
		        }
		        return [tree];
		      }
		    }

		    if ((currentType === '*' || currentType === '**') || tree[currentType]) {
		      //
		      // If the event emitted is '*' at this part
		      // or there is a concrete match at this patch
		      //
		      if (currentType === '*') {
		        for (branch in tree) {
		          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
		            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));
		          }
		        }
		        return listeners;
		      } else if(currentType === '**') {
		        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));
		        if(endReached && tree._listeners) {
		          // The next element has a _listeners, add it to the handlers.
		          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
		        }

		        for (branch in tree) {
		          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
		            if(branch === '*' || branch === '**') {
		              if(tree[branch]._listeners && !endReached) {
		                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
		              }
		              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
		            } else if(branch === nextType) {
		              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));
		            } else {
		              // No match on this one, shift into the tree but not in the type array.
		              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
		            }
		          }
		        }
		        return listeners;
		      }

		      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));
		    }

		    xTree = tree['*'];
		    if (xTree) {
		      //
		      // If the listener tree will allow any match for this part,
		      // then recursively explore all branches of the tree
		      //
		      searchListenerTree(handlers, type, xTree, i+1);
		    }

		    xxTree = tree['**'];
		    if(xxTree) {
		      if(i < typeLength) {
		        if(xxTree._listeners) {
		          // If we have a listener on a '**', it will catch all, so add its handler.
		          searchListenerTree(handlers, type, xxTree, typeLength);
		        }

		        // Build arrays of matching next branches and others.
		        for(branch in xxTree) {
		          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
		            if(branch === nextType) {
		              // We know the next element will match, so jump twice.
		              searchListenerTree(handlers, type, xxTree[branch], i+2);
		            } else if(branch === currentType) {
		              // Current node matches, move into the tree.
		              searchListenerTree(handlers, type, xxTree[branch], i+1);
		            } else {
		              isolatedBranch = {};
		              isolatedBranch[branch] = xxTree[branch];
		              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);
		            }
		          }
		        }
		      } else if(xxTree._listeners) {
		        // We have reached the end and still on a '**'
		        searchListenerTree(handlers, type, xxTree, typeLength);
		      } else if(xxTree['*'] && xxTree['*']._listeners) {
		        searchListenerTree(handlers, type, xxTree['*'], typeLength);
		      }
		    }

		    return listeners;
		  }

		  function growListenerTree(type, listener) {

		    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();

		    //
		    // Looks for two consecutive '**', if so, don't add the event at all.
		    //
		    for(var i = 0, len = type.length; i+1 < len; i++) {
		      if(type[i] === '**' && type[i+1] === '**') {
		        return;
		      }
		    }

		    var tree = this.listenerTree;
		    var name = type.shift();

		    while (name) {

		      if (!tree[name]) {
		        tree[name] = {};
		      }

		      tree = tree[name];

		      if (type.length === 0) {

		        if (!tree._listeners) {
		          tree._listeners = listener;
		        }
		        else if(typeof tree._listeners === 'function') {
		          tree._listeners = [tree._listeners, listener];
		        }
		        else if (isArray(tree._listeners)) {

		          tree._listeners.push(listener);

		          if (!tree._listeners.warned) {

		            var m = defaultMaxListeners;

		            if (typeof this._events.maxListeners !== 'undefined') {
		              m = this._events.maxListeners;
		            }

		            if (m > 0 && tree._listeners.length > m) {

		              tree._listeners.warned = true;
		              console.error('(node) warning: possible EventEmitter memory ' +
		                            'leak detected. %d listeners added. ' +
		                            'Use emitter.setMaxListeners() to increase limit.',
		                            tree._listeners.length);
		              console.trace();
		            }
		          }
		        }
		        return true;
		      }
		      name = type.shift();
		    }
		    return true;
		  }

		  // By default EventEmitters will print a warning if more than
		  // 10 listeners are added to it. This is a useful default which
		  // helps finding memory leaks.
		  //
		  // Obviously not all Emitters should be limited to 10. This function allows
		  // that to be increased. Set to zero for unlimited.

		  EventEmitter.prototype.delimiter = '.';

		  EventEmitter.prototype.setMaxListeners = function(n) {
		    this._events || init.call(this);
		    this._events.maxListeners = n;
		    if (!this._conf) this._conf = {};
		    this._conf.maxListeners = n;
		  };

		  EventEmitter.prototype.event = '';

		  EventEmitter.prototype.once = function(event, fn) {
		    this.many(event, 1, fn);
		    return this;
		  };

		  EventEmitter.prototype.many = function(event, ttl, fn) {
		    var self = this;

		    if (typeof fn !== 'function') {
		      throw new Error('many only accepts instances of Function');
		    }

		    function listener() {
		      if (--ttl === 0) {
		        self.off(event, listener);
		      }
		      fn.apply(this, arguments);
		    }

		    listener._origin = fn;

		    this.on(event, listener);

		    return self;
		  };

		  EventEmitter.prototype.emit = function() {

		    this._events || init.call(this);

		    var type = arguments[0];

		    if (type === 'newListener' && !this.newListener) {
		      if (!this._events.newListener) { return false; }
		    }

		    // Loop through the *_all* functions and invoke them.
		    if (this._all) {
		      var l = arguments.length;
		      var args = new Array(l - 1);
		      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
		      for (i = 0, l = this._all.length; i < l; i++) {
		        this.event = type;
		        this._all[i].apply(this, args);
		      }
		    }

		    // If there is no 'error' event listener then throw.
		    if (type === 'error') {

		      if (!this._all &&
		        !this._events.error &&
		        !(this.wildcard && this.listenerTree.error)) {

		        if (arguments[1] instanceof Error) {
		          throw arguments[1]; // Unhandled 'error' event
		        } else {
		          throw new Error("Uncaught, unspecified 'error' event.");
		        }
		        return false;
		      }
		    }

		    var handler;

		    if(this.wildcard) {
		      handler = [];
		      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
		      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
		    }
		    else {
		      handler = this._events[type];
		    }

		    if (typeof handler === 'function') {
		      this.event = type;
		      if (arguments.length === 1) {
		        handler.call(this);
		      }
		      else if (arguments.length > 1)
		        switch (arguments.length) {
		          case 2:
		            handler.call(this, arguments[1]);
		            break;
		          case 3:
		            handler.call(this, arguments[1], arguments[2]);
		            break;
		          // slower
		          default:
		            var l = arguments.length;
		            var args = new Array(l - 1);
		            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
		            handler.apply(this, args);
		        }
		      return true;
		    }
		    else if (handler) {
		      var l = arguments.length;
		      var args = new Array(l - 1);
		      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];

		      var listeners = handler.slice();
		      for (var i = 0, l = listeners.length; i < l; i++) {
		        this.event = type;
		        listeners[i].apply(this, args);
		      }
		      return (listeners.length > 0) || !!this._all;
		    }
		    else {
		      return !!this._all;
		    }

		  };

		  EventEmitter.prototype.on = function(type, listener) {

		    if (typeof type === 'function') {
		      this.onAny(type);
		      return this;
		    }

		    if (typeof listener !== 'function') {
		      throw new Error('on only accepts instances of Function');
		    }
		    this._events || init.call(this);

		    // To avoid recursion in the case that type == "newListeners"! Before
		    // adding it to the listeners, first emit "newListeners".
		    this.emit('newListener', type, listener);

		    if(this.wildcard) {
		      growListenerTree.call(this, type, listener);
		      return this;
		    }

		    if (!this._events[type]) {
		      // Optimize the case of one listener. Don't need the extra array object.
		      this._events[type] = listener;
		    }
		    else if(typeof this._events[type] === 'function') {
		      // Adding the second element, need to change to array.
		      this._events[type] = [this._events[type], listener];
		    }
		    else if (isArray(this._events[type])) {
		      // If we've already got an array, just append.
		      this._events[type].push(listener);

		      // Check for listener leak
		      if (!this._events[type].warned) {

		        var m = defaultMaxListeners;

		        if (typeof this._events.maxListeners !== 'undefined') {
		          m = this._events.maxListeners;
		        }

		        if (m > 0 && this._events[type].length > m) {

		          this._events[type].warned = true;
		          console.error('(node) warning: possible EventEmitter memory ' +
		                        'leak detected. %d listeners added. ' +
		                        'Use emitter.setMaxListeners() to increase limit.',
		                        this._events[type].length);
		          console.trace();
		        }
		      }
		    }
		    return this;
		  };

		  EventEmitter.prototype.onAny = function(fn) {

		    if (typeof fn !== 'function') {
		      throw new Error('onAny only accepts instances of Function');
		    }

		    if(!this._all) {
		      this._all = [];
		    }

		    // Add the function to the event listener collection.
		    this._all.push(fn);
		    return this;
		  };

		  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

		  EventEmitter.prototype.off = function(type, listener) {
		    if (typeof listener !== 'function') {
		      throw new Error('removeListener only takes instances of Function');
		    }

		    var handlers,leafs=[];

		    if(this.wildcard) {
		      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
		      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
		    }
		    else {
		      // does not use listeners(), so no side effect of creating _events[type]
		      if (!this._events[type]) return this;
		      handlers = this._events[type];
		      leafs.push({_listeners:handlers});
		    }

		    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
		      var leaf = leafs[iLeaf];
		      handlers = leaf._listeners;
		      if (isArray(handlers)) {

		        var position = -1;

		        for (var i = 0, length = handlers.length; i < length; i++) {
		          if (handlers[i] === listener ||
		            (handlers[i].listener && handlers[i].listener === listener) ||
		            (handlers[i]._origin && handlers[i]._origin === listener)) {
		            position = i;
		            break;
		          }
		        }

		        if (position < 0) {
		          continue;
		        }

		        if(this.wildcard) {
		          leaf._listeners.splice(position, 1);
		        }
		        else {
		          this._events[type].splice(position, 1);
		        }

		        if (handlers.length === 0) {
		          if(this.wildcard) {
		            delete leaf._listeners;
		          }
		          else {
		            delete this._events[type];
		          }
		        }
		        return this;
		      }
		      else if (handlers === listener ||
		        (handlers.listener && handlers.listener === listener) ||
		        (handlers._origin && handlers._origin === listener)) {
		        if(this.wildcard) {
		          delete leaf._listeners;
		        }
		        else {
		          delete this._events[type];
		        }
		      }
		    }

		    return this;
		  };

		  EventEmitter.prototype.offAny = function(fn) {
		    var i = 0, l = 0, fns;
		    if (fn && this._all && this._all.length > 0) {
		      fns = this._all;
		      for(i = 0, l = fns.length; i < l; i++) {
		        if(fn === fns[i]) {
		          fns.splice(i, 1);
		          return this;
		        }
		      }
		    } else {
		      this._all = [];
		    }
		    return this;
		  };

		  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

		  EventEmitter.prototype.removeAllListeners = function(type) {
		    if (arguments.length === 0) {
		      !this._events || init.call(this);
		      return this;
		    }

		    if(this.wildcard) {
		      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
		      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

		      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
		        var leaf = leafs[iLeaf];
		        leaf._listeners = null;
		      }
		    }
		    else {
		      if (!this._events[type]) return this;
		      this._events[type] = null;
		    }
		    return this;
		  };

		  EventEmitter.prototype.listeners = function(type) {
		    if(this.wildcard) {
		      var handlers = [];
		      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
		      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
		      return handlers;
		    }

		    this._events || init.call(this);

		    if (!this._events[type]) this._events[type] = [];
		    if (!isArray(this._events[type])) {
		      this._events[type] = [this._events[type]];
		    }
		    return this._events[type];
		  };

		  EventEmitter.prototype.listenersAny = function() {

		    if(this._all) {
		      return this._all;
		    }
		    else {
		      return [];
		    }

		  };

		  if (true) {
		     // AMD. Register as an anonymous module.
		    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
		      return EventEmitter;
		    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  } else if (typeof exports === 'object') {
		    // CommonJS
		    exports.EventEmitter2 = EventEmitter;
		  }
		  else {
		    // Browser global.
		    window.EventEmitter2 = EventEmitter;
		  }
		}();


	/***/ },
	/* 48 */
	/***/ function(module, exports, __webpack_require__) {

		var net = __webpack_require__(43);
		var tls = __webpack_require__(49);
		var Promise = __webpack_require__(3);
		var events = __webpack_require__(50);
		var util = __webpack_require__(51);

		var helper = __webpack_require__(41);
		var Err = __webpack_require__(52);
		var Cursor = __webpack_require__(53);
		var ReadableStream = __webpack_require__(54);
		var Metadata = __webpack_require__(56);

		var protodef = __webpack_require__(42);
		var responseTypes = protodef.Response.ResponseType;

		function Connection(r, options, resolve, reject) {
		  var self = this;
		  this.r = r;

		  // Set default options - We have to save them in case the user tries to reconnect
		  if (!helper.isPlainObject(options)) options = {};
		  this.host = options.host || r._host;
		  this.port = options.port || r._port;
		  this.authKey = options.authKey || r._authKey;
		  this.timeoutConnect = options.timeout || r._timeoutConnect; // period in *seconds* for the connection to be opened

		  if (options.db) this.db = options.db; // Pass to each query
		  if (options.max_batch_rows) this.max_batch_rows = options.max_batch_rows; // For testing only

		  this.token = 1;
		  this.buffer = new Buffer(0);

		  this.metadata = {}

		  this.open = false; // true only if the user can write on the socket
		  this.timeout = null;

		  var family = 'IPv4';
		  if (net.isIPv6(self.host)) {
		    family = 'IPv6';
		  }

		  var connectionArgs = {
		    host: self.host,
		    port: self.port,
		    family: family
		  }

		  var tlsOptions = options.ssl || false;
		  if (tlsOptions === false) {
		    self.connection = net.connect(connectionArgs);
		  } else {
		    if (helper.isPlainObject(tlsOptions)) {
		      // Copy the TLS options in connectionArgs
		      helper.loopKeys(tlsOptions, function(tlsOptions, key) {
		        connectionArgs[key] = tlsOptions[key];
		      });
		    }
		    self.connection = tls.connect(connectionArgs);
		  }

		  self.connection.setKeepAlive(true);

		  self.timeoutOpen = setTimeout(function() {
		    self.connection.end(); // Send a FIN packet
		    reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+' in less than '+self.timeoutConnect+'s'));
		  }, self.timeoutConnect*1000);

		  self.connection.on('end', function(error) {
		    // We emit end or close just once
		    self.connection.removeAllListeners();
		    self.emit('end');
		    // We got a FIN packet, so we'll just flush
		    self._flush();
		  });
		  self.connection.on('close', function(error) {
		    // We emit end or close just once
		    clearTimeout(self.timeoutOpen)
		    self.connection.removeAllListeners();
		    self.emit('closed');
		    // The connection is fully closed, flush (in case 'end' was not triggered)
		    self._flush();
		  });
		  self.connection.setNoDelay();
		  self.connection.once('error', function(error) {
		    reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+'\nFull error:\n'+JSON.stringify(error)));
		  });
		  self.connection.on('connect', function() {
		    self.connection.removeAllListeners('error');
		    self.connection.on('error', function(error) {
		      self.emit('error', error);
		    });

		    var initBuffer = new Buffer(4)
		    initBuffer.writeUInt32LE(protodef.VersionDummy.Version.V0_4, 0)

		    var authBuffer = new Buffer(self.authKey, 'ascii')
		    var lengthBuffer = new Buffer(4);
		    lengthBuffer.writeUInt32LE(authBuffer.length, 0)

		    var protocolBuffer = new Buffer(4)
		    protocolBuffer.writeUInt32LE(protodef.VersionDummy.Protocol.JSON, 0)
		    helper.tryCatch(function() {
		      self.connection.write(Buffer.concat([initBuffer, lengthBuffer, authBuffer, protocolBuffer]));
		    }, function(err) {
		      // The TCP connection is open, but the ReQL connection wasn't established.
		      // We can just abort the whole thing
		      // TODO dig in node's code to see if it can actually happen, errors are probably just emitted.
		      self.connection.emit('error', err);
		    });
		  });
		  self.connection.once('end', function() {
		    self.open = false;
		  });

		  self.connection.on('data', function(buffer) {
		    self.buffer = Buffer.concat([self.buffer, buffer]);

		    if (self.open == false) {
		      for(var i=0; i<self.buffer.length; i++) {
		        if (buffer[i] === 0) {
		          clearTimeout(self.timeoutOpen)
		          var connectionStatus = buffer.slice(0, i).toString();
		          if (connectionStatus === 'SUCCESS') {
		            self.open = true;
		            resolve(self);
		          }
		          else {
		            reject(new Err.ReqlDriverError('Server dropped connection with message: \''+connectionStatus+'\''));
		          }
		          self.buffer = buffer.slice(i+1);
		          break;
		        }
		      }
		      self.connection.removeAllListeners('error');
		      self.connection.on('error', function(e) {
		        self.open = false;
		      });
		    }
		    else {
		      while(self.buffer.length >= 12) {
		        var token = self.buffer.readUInt32LE(0) + 0x100000000 * self.buffer.readUInt32LE(4);
		        var responseLength = self.buffer.readUInt32LE(8);

		        if (self.buffer.length < 12+responseLength) break;

		        var responseBuffer = self.buffer.slice(12, 12+responseLength);
		        var response = JSON.parse(responseBuffer);

		        self._processResponse(response, token);

		        self.buffer = self.buffer.slice(12+responseLength);
		      }
		    }
		  });

		  self.connection.on('timeout', function(buffer) {
		    self.connection.open = false;
		    self.emit('timeout');
		  })
		  self.connection.toJSON = function() { // We want people to be able to jsonify a cursor
		    return '"A socket object cannot be converted to JSON due to circular references."'
		  }
		}

		util.inherits(Connection, events.EventEmitter);

		Connection.prototype._processResponse = function(response, token) {
		  //console.log('Connection.prototype._processResponse: '+token);
		  //console.log(JSON.stringify(response, null, 2));
		  var self = this;

		  var type = response.t;
		  var result;
		  var cursor;
		  var stream;
		  var currentResolve, currentReject;
		  var datum;
		  var options;

		  if (type === responseTypes.COMPILE_ERROR) {
		    self.emit('release');
		    if (typeof self.metadata[token].reject === 'function') {
		      self.metadata[token].reject(new Err.ReqlCompileError(helper.makeAtom(response), self.metadata[token].query, response));
		    }

		    delete self.metadata[token]
		  }
		  else if (type === responseTypes.CLIENT_ERROR) {
		    self.emit('release');

		    if (typeof self.metadata[token].reject === 'function') {
		      currentResolve = self.metadata[token].resolve;
		      currentReject = self.metadata[token].reject;
		      self.metadata[token].removeCallbacks();
		      currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));
		      if (typeof self.metadata[token].endReject !== 'function') {
		        // No pending STOP query, we can delete
		        delete self.metadata[token]
		      }
		    }
		    else if (typeof self.metadata[token].endResolve === 'function') {
		      currentResolve = self.metadata[token].endResolve;
		      currentReject = self.metadata[token].endReject;
		      self.metadata[token].removeEndCallbacks();
		      currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));
		      delete self.metadata[token]
		    }
		    else if (token === -1) { // This should not happen now since 1.13 took the token out of the query
		      var error = new Err.ReqlClientError(helper.makeAtom(response)+'\nClosing all outstanding queries...');
		      self.emit('error', error);
		      // We don't want a function to yield forever, so we just reject everything
		      helper.loopKeys(self.rejectMap, function(rejectMap, key) {
		        rejectMap[key](error);
		      });
		      self.close();
		      delete self.metadata[token]
		    }
		  }
		  else if (type === responseTypes.RUNTIME_ERROR) {
		    self.emit('release');
		    if (typeof self.metadata[token].reject === 'function') {
		    }

		    if (typeof self.metadata[token].reject === 'function') {
		      currentResolve = self.metadata[token].resolve;
		      currentReject = self.metadata[token].reject;
		      self.metadata[token].removeCallbacks();
		      var error = new Err.ReqlRuntimeError(helper.makeAtom(response), self.metadata[token].query, response);
		      error.setName(response.e);
		      currentReject(error);
		      if (typeof self.metadata[token].endReject !== 'function') {
		        // No pending STOP query, we can delete
		        delete self.metadata[token]
		      }
		    }
		    else if (typeof self.metadata[token].endResolve === 'function') {
		      currentResolve = self.metadata[token].endResolve;
		      currentReject = self.metadata[token].endReject;
		      self.metadata[token].removeEndCallbacks();
		      currentReject(new Err.ReqlRuntimeError(helper.makeAtom(response), self.metadata[token].query, response));
		      delete self.metadata[token]
		    }
		  }
		  else if (type === responseTypes.SUCCESS_ATOM) {
		    self.emit('release');
		    // self.metadata[token].resolve is always a function
		    datum = helper.makeAtom(response, self.metadata[token].options);

		    if ((Array.isArray(datum)) &&
		        ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) && (self.r._options.cursor === true)))) {
		      cursor = new Cursor(self, token, self.metadata[token].options, 'cursor');
		      if (self.metadata[token].options.profile === true) {
		        self.metadata[token].resolve({
		          profile: response.p,
		          result: cursor
		        });
		      }
		      else {
		        self.metadata[token].resolve(cursor);
		      }

		      cursor._push({done: true, response: { r: datum }});
		    }
		    else if ((Array.isArray(datum)) &&
		        ((self.metadata[token].options.stream === true || self.r._options.stream === true))) {
		      cursor = new Cursor(self, token, self.metadata[token].options, 'cursor');
		      stream = new ReadableStream({}, cursor);
		      if (self.metadata[token].options.profile === true) {
		        self.metadata[token].resolve({
		          profile: response.p,
		          result: stream
		        });
		      }
		      else {
		        self.metadata[token].resolve(stream);
		      }

		      cursor._push({done: true, response: { r: datum }});

		    }
		    else {
		      if (self.metadata[token].options.profile === true) {
		        result = {
		          profile: response.p,
		          result: cursor || datum
		        }
		      }
		      else {
		        result = datum;
		      }
		      self.metadata[token].resolve(result);
		    }

		    delete self.metadata[token];
		  }
		  else if (type === responseTypes.SUCCESS_PARTIAL) {
		    // We save the current resolve function because we are going to call cursor._fetch before resuming the user's yield
		    currentResolve = self.metadata[token].resolve;
		    currentReject = self.metadata[token].reject;

		    // We need to delete before calling cursor._push
		    self.metadata[token].removeCallbacks();

		    if (!self.metadata[token].cursor) { //No cursor, let's create one
		      self.metadata[token].cursor = true;

		      var typeResult = 'Cursor';
		      var includesStates = false;;
		      if (Array.isArray(response.n)) {
		        for(var i=0; i<response.n.length; i++) {
		          if (response.n[i] === protodef.Response.ResponseNote.SEQUENCE_FEED) {
		            typeResult = 'Feed';
		          }
		          else if (response.n[i] === protodef.Response.ResponseNote.ATOM_FEED) {
		            typeResult = 'AtomFeed';
		          }
		          else if (response.n[i] === protodef.Response.ResponseNote.ORDER_BY_LIMIT_FEED) {
		            typeResult = 'OrderByLimitFeed';
		          }
		          else if (response.n[i] === protodef.Response.ResponseNote.UNIONED_FEED) {
		            typeResult = 'UnionedFeed';
		          }
		          else if (response.n[i] === protodef.Response.ResponseNote.INCLUDES_STATES) {
		            includesStates = true;
		          }
		          else {
		            currentReject(new Err.ReqlDriverError('Unknown ResponseNote '+response.n[i]+', the driver is probably out of date.'));
		            return;
		          }
		        }
		      }
		      cursor = new Cursor(self, token, self.metadata[token].options, typeResult);
		      if (includesStates === true) {
		        cursor.setIncludesStates();
		      }
		      if ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) && (self.r._options.cursor === true))) {
		        // Return a cursor
		        if (self.metadata[token].options.profile === true) {
		          currentResolve({
		            profile: response.p,
		            result: cursor
		          });
		        }
		        else {
		          currentResolve(cursor);
		        }
		      }
		      else if ((self.metadata[token].options.stream === true || self.r._options.stream === true)) {
		        stream = new ReadableStream({}, cursor);
		        if (self.metadata[token].options.profile === true) {
		          currentResolve({
		            profile: response.p,
		            result: stream
		          });
		        }
		        else {
		          currentResolve(stream);
		        }
		      }
		      else if (typeResult !== 'Cursor') {
		        // Return a feed
		        if (self.metadata[token].options.profile === true) {
		          currentResolve({
		            profile: response.p,
		            result: cursor
		          });
		        }
		        else {
		          currentResolve(cursor);
		        }
		      }
		      else {
		        // When we get SUCCESS_SEQUENCE, we will delete self.metadata[token].options
		        // So we keep a reference of it here
		        options = self.metadata[token].options;

		        // Fetch everything and return an array
		        cursor.toArray().then(function(result) {
		          if (options.profile === true) {
		            currentResolve({
		              profile: response.p,
		              result: result
		            });
		          }
		          else {
		            currentResolve(result);
		          }
		        }).error(currentReject)
		      }
		      cursor._push({done: false, response: response});
		    }
		    else { // That was a continue query
		      currentResolve({done: false, response: response});
		    }
		  }
		  else if (type === responseTypes.SUCCESS_SEQUENCE) {
		    self.emit('release');

		    if (typeof self.metadata[token].resolve === 'function') {
		      currentResolve = self.metadata[token].resolve;
		      currentReject = self.metadata[token].reject;
		      self.metadata[token].removeCallbacks();
		    }
		    else if (typeof self.metadata[token].endResolve === 'function') {
		      currentResolve = self.metadata[token].endResolve;
		      currentReject = self.metadata[token].endReject;
		      self.metadata[token].removeEndCallbacks();
		    }

		    if (!self.metadata[token].cursor) { // No cursor, let's create one
		      cursor = new Cursor(self, token, self.metadata[token].options, 'Cursor');

		      if ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) && (self.r._options.cursor === true))) {
		        if (self.metadata[token].options.profile === true) {
		          currentResolve({
		            profile: response.p,
		            result: cursor
		          });
		        }
		        else {
		          currentResolve(cursor);
		        }

		        // We need to keep the options in the else statement, so we clean it inside the if/else blocks
		        delete self.metadata[token];
		      }
		      else if ((self.metadata[token].options.stream === true || self.r._options.stream === true)) {
		        stream = new ReadableStream({}, cursor);
		        if (self.metadata[token].options.profile === true) {
		          currentResolve({
		            profile: response.p,
		            result: stream
		          });
		        }
		        else {
		          currentResolve(stream);
		        }

		        // We need to keep the options in the else statement, so we clean it inside the if/else blocks
		        delete self.metadata[token];
		      }
		      else {
		        cursor.toArray().then(function(result) {
		          if (self.metadata[token].options.profile === true) {
		            currentResolve({
		              profile: response.p,
		              result: result
		            });
		          }
		          else {
		            currentResolve(result);
		          }
		          delete self.metadata[token];
		        }).error(currentReject)
		      }
		      cursor._push({done: true, response: response});
		    }
		    else { // That was a continue query
		      currentResolve({done: true, response: response});
		    }
		  }
		  else if (type === responseTypes.WAIT_COMPLETE) {
		    self.emit('release');
		    self.metadata[token].resolve();

		    delete self.metadata[token];
		  }
		}

		Connection.prototype.reconnect = function(options, callback) {
		  var self = this;

		  if (typeof options === 'function') {
		    callback = options;
		    options = {};
		  }

		  if (!helper.isPlainObject(options)) options = {};

		  if (options.noreplyWait === true) {
		    var p = new Promise(function(resolve, reject) {
		      self.close(options).then(function() {
		        self.r.connect({
		          host: self.host,
		          port: self.port,
		          authKey: self.authKey,
		          db: self.db
		        }).then(function(c) {
		          resolve(c);
		        }).error(function(e) {
		          reject(e);
		        });
		      }).error(function(e) {
		        reject(e)
		      })
		    }).nodeify(callback);
		  }
		  else {
		    return self.r.connect({
		      host: self.host,
		      port: self.port,
		      authKey: self.authKey,
		      db: self.db
		    }, callback);
		  }

		  return p;
		}

		Connection.prototype._send = function(query, token, resolve, reject, originalQuery, options, end) {
		  //console.log('Connection.prototype._send: '+token);
		  //console.log(JSON.stringify(query, null, 2));

		  var self = this;

		  var queryStr = JSON.stringify(query);
		  var querySize = Buffer.byteLength(queryStr);

		  var buffer = new Buffer(8+4+querySize);
		  buffer.writeUInt32LE(token & 0xFFFFFFFF, 0)
		  buffer.writeUInt32LE(Math.floor(token / 0xFFFFFFFF), 4)

		  buffer.writeUInt32LE(querySize, 8);

		  buffer.write(queryStr, 12);

		  // noreply instead of noReply because the otpions are translated for the server
		  if ((!helper.isPlainObject(options)) || (options.noreply != true)) {
		    if (!self.metadata[token]) {
		      self.metadata[token] = new Metadata(resolve, reject, originalQuery, options);
		    }
		    else if (end === true) {
		      self.metadata[token].setEnd(resolve, reject);
		    }
		    else {
		      self.metadata[token].setCallbacks(resolve, reject);
		    }
		  }
		  else {
		    if (typeof resolve === 'function') resolve();
		    this.emit('release');
		  }

		  // This will emit an error if the connection is closed
		  helper.tryCatch(function() {
		    self.connection.write(buffer);
		  }, function(err) {
		    self.metadata[token].reject(err);
		    delete self.metadata[token]
		  });

		};

		Connection.prototype._continue = function(token, resolve, reject) {
		  var query = [protodef.Query.QueryType.CONTINUE];
		  this._send(query, token, resolve, reject);
		}
		Connection.prototype._end = function(token, resolve, reject) {
		  var query = [protodef.Query.QueryType.STOP];
		  this._send(query, token, resolve, reject, undefined, undefined, true);
		}


		Connection.prototype.use = function(db) {
		  if (typeof db !== 'string') throw new Err.ReqlDriverError('First argument of `use` must be a string')
		  this.db = db;
		}

		Connection.prototype.close = function(options, callback) {
		  if (typeof options === 'function') {
		    callback = options;
		    options = {};
		  }
		  var self = this;

		  var p = new Promise(function(resolve, reject) {
		    if (!helper.isPlainObject(options)) options = {};
		    if (options.noreplyWait === true) {
		      self.noreplyWait().then(function(r) {
		        self.open = false;
		        self.connection.end()
		        resolve(r);
		      }).error(function(e) {
		        reject(e)
		      });
		    }
		    else{
		      self.open = false;
		      self.connection.end();
		      resolve();
		    }
		  }).nodeify(callback);
		  return p;
		};


		Connection.prototype.noReplyWait = function() {
		  throw new Err.ReqlDriverError('Did you mean to use `noreplyWait` instead of `noReplyWait`?')
		}
		Connection.prototype.noreplyWait = function(callback) {
		  var self = this;
		  var token = self.token++;

		  var p = new Promise(function(resolve, reject) {
		    var query = [protodef.Query.QueryType.NOREPLY_WAIT];

		    self._send(query, token, resolve, reject);
		  }).nodeify(callback);
		  return p;
		}
		Connection.prototype._isConnection = function() {
		  return true;
		}
		Connection.prototype._isOpen = function() {
		  return this.open;
		}

		Connection.prototype._flush = function() {
		  helper.loopKeys(this.metadata, function(metadata, key) {
		    if (typeof metadata[key].reject === 'function') {
		      metadata[key].reject(new Err.ReqlServerError(
		            'The connection was closed before the query could be completed.',
		            metadata[key].query));
		    }
		    if (typeof metadata[key].endReject === 'function') {
		      metadata[key].endReject(new Err.ReqlServerError(
		            'The connection was closed before the query could be completed.',
		            metadata[key].query));
		    }
		  });
		  this.metadata = {};
		}

		module.exports = Connection


	/***/ },
	/* 49 */
	/***/ function(module, exports) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.connect = connect;

		function connect() {
		  throw new Error("TlsStub does not implement tls.connect()");
		}

	/***/ },
	/* 50 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(8);

	/***/ },
	/* 51 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(9);

	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {

		var helper = __webpack_require__(41);
		var INDENT = 4;
		var LIMIT = 80;

		var protodef = __webpack_require__(42);
		var responseTypes = protodef.Response.ResponseType;
		var protoErrorType = protodef.Response.ErrorType;
		var termTypes = protodef.Term.TermType;
		var datumTypes = protodef.Datum.DatumType;
		var frameTypes = protodef.Frame.FrameType;

		function ReqlDriverError(message, query, secondMessage) {
		  Error.captureStackTrace(this, ReqlDriverError);
		  this.message = message;
		  if ((Array.isArray(query) && (query.length > 0)) || (!Array.isArray(query) && query != null)) {
		    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {
		      this.message = this.message.slice(0, this.message.length-1);
		    }

		    this.message += ' after:\n';

		    var backtrace = generateBacktrace(query, 0, null, [], {indent: 0, extra: 0});

		    this.message += backtrace.str;
		  }
		  else {
		    if (this.message[this.message.length-1] !== '?') this.message += '.';
		  }
		  if (secondMessage) this.message += '\n'+secondMessage;
		};
		ReqlDriverError.prototype = new Error();
		ReqlDriverError.prototype.name = 'ReqlDriverError';

		module.exports.ReqlDriverError = ReqlDriverError;


		function ReqlServerError(message, query) {
		  Error.captureStackTrace(this, ReqlServerError);
		  this.message = message;

		  if ((Array.isArray(query) && (query.length > 0)) || (!Array.isArray(query) && query != null)) {
		    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {
		      this.message = this.message.slice(0, this.message.length-1);
		    }

		    this.message += ' for:\n';

		    var backtrace = generateBacktrace(query, 0, null, [], {indent: 0, extra: 0});

		    this.message += backtrace.str;
		  }
		  else {
		    if (this.message[this.message.length-1] !== '?') this.message += '.';
		  }

		};
		ReqlServerError.prototype = new Error();
		ReqlServerError.prototype.name = 'ReqlServerError';

		module.exports.ReqlServerError = ReqlServerError;


		function ReqlRuntimeError(message, query, frames) {
		  Error.captureStackTrace(this, ReqlRuntimeError);
		  this.message = message;

		  if ((query != null) && (frames)) {
		    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {
		      this.message = this.message.slice(0, this.message.length-1);
		    }
		    this.message += ' in:\n';

		    frames = frames.b;
		    if (frames) this.frames = frames.slice(0);
		    //this.frames = JSON.stringify(frames, null, 2);

		    var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});

		    var queryLines = backtrace.str.split('\n');
		    var carrotLines = backtrace.car.split('\n');

		    for(var i=0; i<queryLines.length; i++) {
		      this.message += queryLines[i]+'\n';
		      if (carrotLines[i].match(/\^/)) {
		        var pos = queryLines[i].match(/[^\s]/);
		        if ((pos) && (pos.index)) {
		          this.message += space(pos.index)+carrotLines[i].slice(pos.index)+'\n';
		        }
		        else {
		          this.message += carrotLines[i]+'\n';
		        }
		      }
		    }
		  }
		  //this.query = JSON.stringify(query, null, 2);
		};
		ReqlRuntimeError.prototype = new Error();
		ReqlRuntimeError.prototype.name = 'ReqlRuntimeError';
		ReqlRuntimeError.prototype.setName = function(type) {
		  switch(type) {
		    case protoErrorType.INTERNAL:
		      this.name = 'ReqlInternalError';
		      break;
		    case protoErrorType.RESOURCE:
		      this.name = 'ReqlResourceError';
		      break;
		    case protoErrorType.LOGIC:
		      this.name = 'ReqlLogicError';
		      break;
		    case protoErrorType.OP_FAILED:
		      this.name = 'ReqlOpFailedError';
		      break;
		    case protoErrorType.OP_INDETERMINATE:
		      this.name = 'ReqlOpIndeterminateError';
		      break;
		    case protoErrorType.USER:
		      this.name = 'ReqlUserError';
		      break;
		    //default: // Do nothing
		  }
		}


		module.exports.ReqlRuntimeError = ReqlRuntimeError;


		function ReqlCompileError(message, query, frames) {
		  Error.captureStackTrace(this, ReqlCompileError);
		  this.message = message;

		  if ((query != null) && (frames)) {
		    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {
		      this.message = this.message.slice(0, this.message.length-1);
		    }

		    this.message += ' in:\n';

		    frames = frames.b;
		    if (frames) this.frames = frames.slice(0);
		    //this.frames = JSON.stringify(frames, null, 2);

		    var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});

		    var queryLines = backtrace.str.split('\n');
		    var carrotLines = backtrace.car.split('\n');

		    for(var i=0; i<queryLines.length; i++) {
		      this.message += queryLines[i]+'\n';
		      if (carrotLines[i].match(/\^/)) {
		        var pos = queryLines[i].match(/[^\s]/);
		        if ((pos) && (pos.index)) {
		          this.message += space(pos.index)+carrotLines[i].slice(pos.index)+'\n';
		        }
		        else {
		          this.message += carrotLines[i]+'\n';
		        }
		      }
		    }
		  }
		};
		ReqlCompileError.prototype = new Error();
		ReqlCompileError.prototype.name = 'ReqlCompileError';

		module.exports.ReqlCompileError = ReqlCompileError;


		function ReqlClientError(message) {
		  Error.captureStackTrace(this, ReqlClientError);
		  this.message = message;
		};
		ReqlClientError.prototype = new Error();
		ReqlClientError.prototype.name = 'ReqlClientError';

		module.exports.ReqlClientError = ReqlClientError;



		var _constants = {
		  MONDAY: true,
		  TUESDAY: true,
		  WEDNESDAY: true,
		  THURSDAY: true,
		  FRIDAY: true,
		  SATURDAY: true,
		  SUNDAY: true,
		  JANUARY: true,
		  FEBRUARY: true,
		  MARCH: true,
		  APRIL: true,
		  MAY: true,
		  JUNE: true,
		  JULY: true,
		  AUGUST: true,
		  SEPTEMBER: true,
		  OCTOBER: true,
		  NOVEMBER: true,
		  DECEMBER: true,
		  MINVAL: true,
		  MAXVAL: true,
		}
		var constants = {};
		for(var key in _constants) {
		  constants[termTypes[key]] = true;
		}


		var _nonPrefix = {
		  DB: true,
		  DB_CREATE: true,
		  DB_LIST: true,
		  DB_DROP: true,
		  JS: true,
		  NOW: true,
		  TIME: true,
		  EPOCH_TIME: true,
		  ISO8601: true,
		  BRANCH: true,
		  JAVASCRIPT: true,
		  ERROR: true,
		  MAKE_ARRAY: true,
		  JSON: true,
		  ARGS: true,
		  HTTP: true,
		  RANDOM: true,
		  BINARY: true,
		  OBJECT: true,
		  CIRCLE: true,
		  GEOJSON: true,
		  POINT: true,
		  LINE: true,
		  POLYGON: true,
		  UUID: true,
		  DESC: true,
		  ASC: true,
		  RANGE: true,
		  LITERAL: 'true'
		}
		var nonPrefix = {};
		for(var key in _nonPrefix) {
		  nonPrefix[termTypes[key]] = true;
		}
		// Constants are also in nonPrefix
		for(var key in _constants) {
		  nonPrefix[termTypes[key]] = true;
		}


		var _typeToString = {
		  DB: 'db',
		  DB_CREATE: 'dbCreate',
		  DB_LIST: 'dbList',
		  DB_DROP: 'dbDrop',
		  TABLE_CREATE: 'tableCreate',
		  TABLE_LIST: 'tableList',
		  TABLE_DROP: 'tableDrop',
		  TABLE: 'table',
		  INDEX_CREATE: 'indexCreate',
		  INDEX_DROP: 'indexDrop',
		  INDEX_LIST: 'indexList',
		  INDEX_WAIT: 'indexWait',
		  INDEX_STATUS: 'indexStatus',
		  INSERT: 'insert',
		  UPDATE: 'update',
		  REPLACE: 'replace',
		  DELETE: 'delete',
		  SYNC: 'sync',
		  GET: 'get',
		  GET_ALL: 'getAll',
		  BETWEEN: 'between',
		  FILTER: 'filter',
		  INNER_JOIN: 'innerJoin',
		  OUTER_JOIN: 'outerJoin',
		  EQ_JOIN: 'eqJoin',
		  ZIP: 'zip',
		  MAP: 'map',
		  WITH_FIELDS: 'withFields',
		  CONCAT_MAP: 'concatMap',
		  ORDER_BY: 'orderBy',
		  DESC: 'desc',
		  ASC: 'asc',
		  SKIP: 'skip',
		  LIMIT: 'limit',
		  SLICE: 'slice',
		  NTH: 'nth',
		  OFFSETS_OF: 'offsetsOf',
		  IS_EMPTY: 'isEmpty',
		  UNION: 'union',
		  SAMPLE: 'sample',
		  REDUCE: 'reduce',
		  COUNT: 'count',
		  SUM: 'sum',
		  AVG: 'avg',
		  MIN: 'min',
		  MAX: 'max',
		  OBJECT: 'object',
		  DISTINCT: 'distinct',
		  GROUP: 'group',
		  UNGROUP: 'ungroup',
		  CONTAINS: 'contains',
		  IMPLICIT_VAR: 'row',
		  PLUCK: 'pluck',
		  WITHOUT: 'without',
		  MERGE: 'merge',
		  APPEND: 'append',
		  PREPEND: 'prepend',
		  DIFFERENCE: 'difference',
		  SET_INSERT: 'setInsert',
		  SET_UNION: 'setUnion',
		  SET_INTERSECTION: 'setIntersection',
		  SET_DIFFERENCE: 'setDifference',
		  HAS_FIELDS: 'hasFields',
		  INSERT_AT: 'insertAt',
		  SPLICE_AT: 'spliceAt',
		  DELETE_AT: 'deleteAt',
		  CHANGE_AT: 'changeAt',
		  KEYS: 'keys',
		  MATCH: 'match',
		  UPCASE: 'upcase',
		  DOWNCASE: 'downcase',
		  ADD: 'add',
		  SUB: 'sub',
		  MUL: 'mul',
		  DIV: 'div',
		  MOD: 'mod',
		  AND: 'and',
		  OR: 'or',
		  EQ: 'eq',
		  NE: 'ne',
		  GT: 'gt',
		  GE: 'ge',
		  LT: 'lt',
		  LE: 'le',
		  NOT: 'not',
		  FLOOR: 'floor',
		  CEIL: 'ceil',
		  ROUND: 'round',
		  NOW: 'now',
		  TIME: 'time',
		  EPOCH_TIME: 'epochTime',
		  ISO8601: 'ISO8601',
		  IN_TIMEZONE: 'inTimezone',
		  TIMEZONE: 'timezone',
		  DURING: 'during',
		  DATE: 'date',
		  TIME_OF_DAY: 'timeOfDay',
		  YEAR: 'year',
		  MONTH: 'month',
		  DAY: 'day',
		  DAY_OF_WEEK: 'dayOfWeek',
		  DAY_OF_YEAR: 'dayOfYear',
		  HOURS: 'hours',
		  MINUTES: 'minutes',
		  SECONDS: 'seconds',
		  TO_ISO8601: 'toISO8601',
		  TO_EPOCH_TIME: 'toEpochTime',
		  FUNCALL: 'do',
		  BRANCH: 'branch',
		  FOR_EACH: 'forEach',
		  ERROR: 'error',
		  DEFAULT: 'default',
		  JAVASCRIPT: 'js',
		  COERCE_TO: 'coerceTo',
		  TYPE_OF: 'typeOf',
		  INFO: 'info',
		  JSON: 'json',
		  ARGS: 'args',
		  HTTP: 'http',
		  RANDOM: 'random',
		  CHANGES: 'changes',
		  BINARY: 'binary',
		  INDEX_RENAME: 'indexRename',
		  CIRCLE: 'circle',
		  DISTANCE: 'distance',
		  FILL: 'fill',
		  GEOJSON: 'geojson',
		  TO_GEOJSON: 'toGeojson',
		  GET_INTERSECTING: 'getIntersecting',
		  GET_NEAREST: 'getNearest',
		  INCLUDES: 'includes',
		  INTERSECTS: 'intersects',
		  LINE: 'line',
		  POINT: 'point',
		  POLYGON: 'polygon',
		  POLYGON_SUB: 'polygonSub',
		  UUID: 'uuid',
		  RANGE: 'range',
		  TO_JSON_STRING: 'toJSON',
		  CONFIG: 'config',
		  STATUS: 'status',
		  WAIT: 'wait',
		  RECONFIGURE: 'reconfigure',
		  REBALANCE: 'rebalance',
		  SPLIT: 'split',
		  LITERAL: 'literal',
		  MONDAY: 'monday',
		  TUESDAY: 'tuesday',
		  WEDNESDAY: 'wednesday',
		  THURSDAY: 'thursday',
		  FRIDAY: 'friday',
		  SATURDAY: 'saturday',
		  SUNDAY: 'sunday',
		  JANUARY: 'january',
		  FEBRUARY: 'february',
		  MARCH: 'march',
		  APRIL: 'april',
		  MAY: 'may',
		  JUNE: 'june',
		  JULY: 'july',
		  AUGUST: 'august',
		  SEPTEMBER: 'september',
		  OCTOBER: 'october',
		  NOVEMBER: 'november',
		  DECEMBER: 'december' ,
		  MINVAL: 'minval',
		  MAXVAL: 'maxval',
		}
		var typeToString = {};
		for(var key in _typeToString) {
		  typeToString[termTypes[key]] = _typeToString[key];
		}

		var _noPrefixOptargs = {
		  ISO8601: true,
		}
		var noPrefixOptargs = {};
		for(var key in _noPrefixOptargs) {
		  noPrefixOptargs[termTypes[key]] = true;
		}

		var _specialType = {
		  DATUM: function(term, index, father, frames, options, optarg) {
		    optarg = optarg || false;

		    var underline = Array.isArray(frames) && (frames.length === 0);
		    var currentFrame, backtrace;
		    if (Array.isArray(frames)) currentFrame = frames.shift();

		    var result = {
		      str: '',
		      car: ''
		    }

		    if ((helper.isPlainObject(term)) && (term.$reql_type$ === 'BINARY')) {
		      carify(result, 'r.binary(<Buffer>)', underline);
		      return result;
		    }

		    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) carify(result, 'r.expr(', underline)

		    if (typeof term === 'string' ) {
		      carify(result, '"'+term+'"', underline);
		    }
		    else if (helper.isPlainObject(term)) {
		      var totalKeys = Object.keys(term).length;
		      if (totalKeys === 0) {
		        carify(result, '{}', underline);
		      }
		      else {
		        carify(result, '{\n', underline);
		        var countKeys = 0;
		        var extraToRemove = options.extra;
		        options.indent += INDENT+options.extra;
		        options.extra = 0;
		        for(var key in term) {
		          countKeys++;
		          //if (!((father) && (Array.isArray(father[2])) && (Object.keys(father[2]).length > 0))) options.extra = 0;

		          if (optarg) {
		            carify(result, space(options.indent)+camelCase(key)+': ', underline);
		          }
		          else {
		            carify(result, space(options.indent)+key+': ', underline);
		          }
		          if ((currentFrame != null) && (currentFrame === key)) {
		            backtrace = generateBacktrace(term[key], i, term, frames, options);
		          }
		          else {
		            backtrace = generateBacktrace(term[key], i, term, null, options);
		          }
		          result.str += backtrace.str;
		          result.car += backtrace.car;

		          if (countKeys !== totalKeys) {
		            carify(result, ',\n', underline);
		          }

		        }
		        options.indent -= INDENT+extraToRemove;
		        carify(result, '\n'+space(options.indent+extraToRemove)+'}', underline);
		      }
		    }
		    else if (Array.isArray(term)) {
		      carify(result, '[', underline);
		      for(var i=0; i<term.length; i++) {
		        if ((currentFrame != null) && (currentFrame === i)) {
		          backtrace = generateBacktrace(term[i], i, term, frames, options);
		        }
		        else {
		          backtrace = generateBacktrace(term[i], i, term, null, options);
		        }
		        result.str += backtrace.str;
		        result.car += backtrace.car;
		      }
		      carify(result, ']', underline);
		    }
		    else {
		      carify(result, ''+term, underline);
		    }

		    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) carify(result, ')', underline);

		    if (underline) result.car = result.str.replace(/./g, '^');

		    return result;
		  },
		  TABLE: function(term, index, father, frames, options) {
		    var result = {
		      str: '',
		      car: ''
		    }
		    var backtrace, underline, currentFrame;


		    if ((term.length === 1) || (term[1].length === 0) || (term[1][0][0] !== termTypes.DB)) {
		      var underline = Array.isArray(frames) && (frames.length === 0);
		      if (Array.isArray(frames)) currentFrame = frames.shift();

		      carify(result, 'r.'+typeToString[term[0]]+'(', underline);
		      if (Array.isArray(term[1])) {
		        for(var i=0; i<term[1].length; i++) {
		          if (i !==0) result.str += ', ';


		          if ((currentFrame != null) && (currentFrame === 1)) {
		            // +1 for index because it's like if there was a r.db(...) before .table(...)
		            backtrace = generateBacktrace(term[1][i], i+1, term, frames, options)
		          }
		          else {
		            backtrace = generateBacktrace(term[1][i], i+1, term, null, options)
		          }
		          result.str += backtrace.str;
		          result.car += backtrace.car
		        }
		      }

		      backtrace = makeOptargs(term, i, term, frames, options, currentFrame)
		      result.str += backtrace.str;
		      result.car += backtrace.car;

		      carify(result, ')', underline);

		      if (underline) result.car = result.str.replace(/./g, '^');
		    }
		    else {
		      backtrace = generateNormalBacktrace(term, index, father, frames, options);
		      result.str = backtrace.str;
		      result.car = backtrace.car;
		    }

		    return result;
		  },
		  GET_FIELD: function(term, index, father, frames, options) {
		    var result = {
		      str: '',
		      car: ''
		    }
		    var backtrace, underline, currentFrame;

		    var underline = Array.isArray(frames) && (frames.length === 0);
		    if (Array.isArray(frames)) currentFrame = frames.shift();

		    if ((currentFrame != null) && (currentFrame === 0)) {
		      backtrace = generateBacktrace(term[1][0], 0, term, frames, options)
		    }
		    else {
		      backtrace = generateBacktrace(term[1][0], 0, term, null, options)
		    }
		    result.str = backtrace.str;
		    result.car = backtrace.car;

		    carify(result, '(', underline);

		    if ((currentFrame != null) && (currentFrame === 1)) {
		      backtrace = generateBacktrace(term[1][1], 1, term, frames, options)
		    }
		    else {
		      backtrace = generateBacktrace(term[1][1], 1, term, null, options)
		    }
		    result.str += backtrace.str;
		    result.car += backtrace.car;

		    carify(result, ')', underline);

		    if (underline) result.car = result.str.replace(/./g, '^');

		    return result;
		  },
		  MAKE_ARRAY: function(term, index, father, frames, options) {
		    var result = {
		      str: '',
		      car: ''
		    };
		    var backtrace, underline, currentFrame;

		    var underline = Array.isArray(frames) && (frames.length === 0);
		    if (Array.isArray(frames)) currentFrame = frames.shift();

		    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) carify(result, 'r.expr(', underline)

		    if (!((options) && (options.noBracket))) {
		      carify(result, '[', underline);
		    }
		    for(var i=0; i<term[1].length; i++) {
		      if (i !== 0) {
		        carify(result, ', ', underline);
		      }

		      if ((currentFrame != null) && (currentFrame  === i)) {
		        backtrace = generateBacktrace(term[1][i], i, term, frames, options);
		      }
		      else {
		        backtrace = generateBacktrace(term[1][i], i, term, null, options);
		      }
		      result.str += backtrace.str;
		      result.car += backtrace.car;

		    }

		    if (!((options) && (options.noBracket))) {
		      carify(result, ']', underline);
		    }

		    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) {
		      carify(result, ')', underline);
		    }

		    if (underline) result.car = result.str.replace(/./g, '^');

		    return result;
		  },
		  FUNC: function(term, index, father, frames, options) {
		    var result = {
		      str: '',
		      car: ''
		    };
		    var backtrace, underline, currentFrame;

		    var underline = Array.isArray(frames) && (frames.length === 0);
		    if (Array.isArray(frames)) currentFrame = frames.shift();

		    if ((term[1][0][1].length === 1) && (helper.hasImplicit(term[1][1]))) {
		      if ((currentFrame != null) && (currentFrame === 1)) {
		        backtrace = generateBacktrace(term[1][1], 1, term, frames, options);
		      }
		      else {
		        backtrace = generateBacktrace(term[1][1], 1, term, null, options);
		      }
		      result.str = backtrace.str;
		      result.car = backtrace.car;
		    }
		    else {
		      carify(result, 'function(', underline);

		      for(var i=0; i<term[1][0][1].length; i++) {
		        if (i !== 0) {
		          carify(result, ', ', underline);
		        }
		        carify(result, 'var_'+term[1][0][1][i], underline);
		      }

		      options.indent += INDENT+options.extra;
		      var extraToRemove = options.extra;
		      options.extra = 0;
		      //if (!((Array.isArray(term[2])) && (term[2].length > 0))) options.extra = 0;

		      carify(result, ') {\n'+space(options.indent)+'return ', underline);

		      if ((currentFrame != null) && (currentFrame === 1)) {
		        backtrace = generateBacktrace(term[1][1], 1, term, frames, options);
		      }
		      else {
		        backtrace = generateBacktrace(term[1][1], 1, term, null, options);
		      }

		      result.str += backtrace.str;
		      result.car += backtrace.car;

		      options.indent -= INDENT+extraToRemove;
		      options.extra = extraToRemove;

		      carify(result, '\n'+space(options.indent+extraToRemove)+'}', underline);

		    }

		    if (underline) result.car = result.str.replace(/./g, '^');

		    return result;
		  },
		  VAR: function(term, index, father, frames, options) {
		    var result = {
		      str: '',
		      car: ''
		    }
		    var backtrace, underline, currentFrame;

		    var underline = Array.isArray(frames) && (frames.length === 0);
		    if (Array.isArray(frames)) currentFrame = frames.shift();

		    carify(result, 'var_'+term[1][0], underline);

		    if (underline) result.car = result.str.replace(/./g, '^');
		    return result;
		  },
		  FUNCALL: function(term, index, father, frames, options) {
		    // The syntax is args[1].do(args[0])
		    var result = {
		      str: '',
		      car: ''
		    };
		    var backtrace, underline, currentFrame;

		    var underline = Array.isArray(frames) && (frames.length === 0);
		    if (Array.isArray(frames)) currentFrame = frames.shift();

		    if (term[1].length === 2) {
		      if ((currentFrame != null) && (currentFrame === 1)) {
		        backtrace = generateBacktrace(term[1][1], 0, term, frames, options);
		      }
		      else {
		        backtrace = generateBacktrace(term[1][1], 0, term, null, options);
		      }
		      result.str = backtrace.str;
		      result.car = backtrace.car;

		      carify(result, '.do(', underline);
		    }
		    else {
		      carify(result, 'r.do(', underline);

		      for(var i=1; i<term[1].length; i++) {
		        if ((currentFrame != null) && (currentFrame === i)) {
		          backtrace = generateBacktrace(term[1][i], i, term, frames, options);
		        }
		        else {
		          backtrace = generateBacktrace(term[1][i], i, term, null, options);
		        }
		        result.str += backtrace.str;
		        result.car += backtrace.car;

		        if (i !== term[1].length) {
		          carify(result, ', ' , underline);
		        }
		      }
		    }

		    if ((currentFrame != null) && (currentFrame === 0)) {
		      backtrace = generateBacktrace(term[1][0], 0, term, frames, options);
		    }
		    else {
		      backtrace = generateBacktrace(term[1][0], 0, term, null, options);
		    }
		    result.str += backtrace.str;
		    result.car += backtrace.car;

		    carify(result, ')', underline);

		    if (underline) result.car = result.str.replace(/./g, '^');

		    return result;
		  },
		  IMPLICIT_VAR: function(term, index, father, frames, options) {
		    var result = {
		      str: '',
		      car: ''
		    }
		    var backtrace, underline, currentFrame;

		    var underline = Array.isArray(frames) && (frames.length === 0);
		    if (Array.isArray(frames)) currentFrame = frames.shift();

		    carify(result, 'r.row', underline);

		    if (underline) result.car = result.str.replace(/./g, '^');
		    return result;
		  },
		  WAIT: function(term, index, father, frames, options) {
		    var result = {
		      str: '',
		      car: ''
		    }
		    var backtrace, underline, currentFrame;

		    if (term.length === 1 || term[1].length === 0) {
		      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);
		      result.str = backtrace.str;
		      result.car = backtrace.car;
		    }
		    else {
		      backtrace = generateNormalBacktrace(term, index, father, frames, options);
		      result.str = backtrace.str;
		      result.car = backtrace.car;
		    }
		    return result;
		  },
		  MAP: function(term, index, father, frames, options) {
		    var result = {
		      str: '',
		      car: ''
		    }
		    var backtrace, underline, currentFrame;

		    if (term.length > 1 && term[1].length > 2) {
		      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);
		      result.str = backtrace.str;
		      result.car = backtrace.car;
		    }
		    else {
		      backtrace = generateNormalBacktrace(term, index, father, frames, options);
		      result.str = backtrace.str;
		      result.car = backtrace.car;
		    }
		    return result;
		  },
		}
		_specialType.TABLE_CREATE = _specialType.TABLE;
		_specialType.TABLE_DROP = _specialType.TABLE;
		_specialType.TABLE_LIST = _specialType.TABLE;
		_specialType.RECONFIGURE = _specialType.WAIT;
		_specialType.REBALANCE = _specialType.WAIT;
		_specialType.BRACKET = _specialType.GET_FIELD;

		var specialType = {};
		for(var key in _specialType) {
		  specialType[termTypes[key]] = _specialType[key];
		}


		function space(n) {
		  return new Array(n+1).join(' ');
		}
		function carify(result, str, underline) {
		  if (underline === true) {
		    result.str += str;
		    result.car += str.replace(/[^\n]/g, '^');
		  }
		  else {
		    result.str += str;
		    result.car += str.replace(/[^\n]/g, ' ');
		  }
		}
		function makeOptargs(term, index, father, frames, options, currentFrame) {
		  var result = {
		    str: '',
		    car: ''
		  }
		  var backtrace, currentFrame, underline;

		  if (helper.isPlainObject(term[2])) {
		    //if ((currentFrame != null) && (frames != null)) frames.unshift(currentFrame);

		    //underline = Array.isArray(frames) && (frames.length === 0);
		    var underline = false;
		    //if (Array.isArray(frames)) currentFrame = frames.shift();

		    // This works before there is no prefix term than can be called with no normal argument but with an optarg
		    if (Array.isArray(term[1]) && (term[1].length > 1)) {
		      carify(result, ', ' , underline);
		    }
		    else if (Array.isArray(term[1]) && (term[1].length > 0) && (noPrefixOptargs[term[0]])) {
		      carify(result, ', ' , underline);
		    }

		    backtrace = specialType[termTypes.DATUM](term[2], index, term[2], frames, options, true);

		    result.str += backtrace.str;
		    result.car += backtrace.car;

		    if (underline) result.car = result.str.replace(/./g, '^');
		  }

		  return result;
		}
		function generateNormalBacktrace(term, index, father, frames, options) {
		  var result = {
		    str: '',
		    car: ''
		  }
		  var backtrace, currentFrame, underline;

		  //if (term[1]) {
		    var underline = Array.isArray(frames) && (frames.length === 0);
		    if (Array.isArray(frames)) currentFrame = frames.shift();

		    if ((currentFrame != null) && (currentFrame === 0)) {
		      backtrace = generateBacktrace(term[1][0], 0, term, frames, options);
		    }
		    else {
		      backtrace = generateBacktrace(term[1][0], 0, term, null, options);
		    }
		    result.str = backtrace.str;
		    result.car = backtrace.car;

		    var lines = backtrace.str.split('\n');
		    var line = lines[lines.length-1];
		    var pos = line.match(/[^\s]/);
		    pos = (pos) ? pos.index : 0;

		    if (line.length-pos > LIMIT) {
		      if (options.extra === 0) options.extra += INDENT;
		      carify(result, '\n'+space(options.indent+options.extra) , underline);
		    }

		    carify(result, '.'+typeToString[term[0]]+'(' , underline);
		    options.indent += options.extra;
		    var extraToRemove = options.extra;
		    options.extra = 0;

		    for(var i=1; i<term[1].length; i++) {
		      if (i !== 1) {
		        carify(result, ', ' , underline);
		      }
		      if ((currentFrame != null) && (currentFrame === i)) {
		        backtrace = generateBacktrace(term[1][i], i, term, frames, options);
		      }
		      else {
		        backtrace = generateBacktrace(term[1][i], i, term, null, options);
		      }
		      result.str += backtrace.str;
		      result.car += backtrace.car;
		    }

		    backtrace = makeOptargs(term, i, term, frames, options, currentFrame)
		    result.str += backtrace.str;
		    result.car += backtrace.car;

		    options.indent -= extraToRemove;
		    options.extra = extraToRemove;

		    carify(result, ')' , underline);

		    if (underline) result.car = result.str.replace(/./g, '^');
		  /*
		  }
		  else {
		    throw new Error('The driver should never enter this condition. Please report the query to the developers -- End 1 --\n'+JSON.stringify(term, null, 2))
		  }
		  */


		  return result;
		}

		function generateWithoutPrefixBacktrace(term, index, father, frames, options) {
		  var result = {
		    str: '',
		    car: ''
		  }

		  var backtrace, currentFrame, underline;

		  var underline = Array.isArray(frames) && (frames.length === 0);
		  if (Array.isArray(frames)) currentFrame = frames.shift();

		  if (constants[term[0]]) {
		    carify(result, 'r.'+typeToString[term[0]], underline);
		    return result;
		  }

		  carify(result, 'r.'+typeToString[term[0]]+'(', underline);

		  if (Array.isArray(term[1])) {
		    for(var i=0; i<term[1].length; i++) {
		      if (i !== 0) carify(result, ', ', underline)

		      if ((currentFrame != null) && (currentFrame === i)) {
		        backtrace = generateBacktrace(term[1][i], i, term, frames, options)
		      }
		      else {
		        backtrace = generateBacktrace(term[1][i], i, term, null, options)
		      }
		      result.str += backtrace.str;
		      result.car += backtrace.car;
		    }
		  }

		  backtrace = makeOptargs(term, i, term, frames, options, currentFrame)
		  result.str += backtrace.str;
		  result.car += backtrace.car;

		  carify(result, ')', underline);

		  if (underline) result.car = result.str.replace(/./g, '^');

		  return result;
		}

		function generateBacktrace(term, index, father, frames, options) {
		  var result = {
		    str: '',
		    car: ''
		  }
		  var backtrace, currentFrame, underline;

		  // frames = null -> do not underline
		  // frames = [] -> underline

		  if (Array.isArray(term)) {
		    if (term.length === 0) {
		      var underline = Array.isArray(frames) && (frames.length === 0);
		      carify(result, 'undefined', underline);
		    }
		    else if (specialType[term[0]]) {
		      backtrace = specialType[term[0]](term, index, father, frames, options);
		      result.str = backtrace.str;
		      result.car = backtrace.car;
		    }
		    else if (nonPrefix[term[0]]) {
		      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);
		      result.str = backtrace.str;
		      result.car = backtrace.car;
		    }
		    else { // normal type -- this.<method>( this.args... )
		      backtrace = generateNormalBacktrace(term, index, father, frames, options);
		      result.str = backtrace.str;
		      result.car = backtrace.car;
		    }
		  }
		  else if (term !== undefined) {
		    backtrace = specialType[termTypes.DATUM](term, index, father, frames, options);

		    result.str = backtrace.str;
		    result.car = backtrace.car;
		  }
		  else {
		    //throw new Error('The driver should never enter this condition. Please report the query to the developers -- End 2')
		  }
		  return result;
		}

		function camelCase(str) {
		  return str.replace(/_(.)/g, function (m, char) { return char.toUpperCase() });
		}
		module.exports.generateBacktrace = generateBacktrace;



	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {

		var Promise = __webpack_require__(3);
		var Err = __webpack_require__(52);
		var helper = __webpack_require__(41);
		var EventEmitter = __webpack_require__(50).EventEmitter;

		function Cursor(connection, token, options, type) {
		  this.connection = connection;
		  this.token = token;

		  this._index = 0; // Position in this._data[0]
		  this._data = []; // Array of non empty arrays
		  this._fetching = false; // Are we fetching data
		  this._canFetch = true; // Can we fetch more data?
		  this._pendingPromises = []; // Pending promises' resolve/reject
		  this.options = options || {};
		  this._closed = false;
		  this._type = type;
		  this._setIncludesStates = false;
		  if ((type === 'feed') || (type === 'atomFeed')) {
		    this.toArray = function() {
		      throw new Error('The `toArray` method is not available on feeds.')
		    }
		  }
		  this.each = this._each;
		  this.next = this._next;
		}

		Cursor.prototype.toString = function() {
		  return '[object '+this._type+']';
		}
		Cursor.prototype.setIncludesStates = function() {
		  this._setIncludesStates = true;
		}
		Cursor.prototype.includesStates = function() {
		  return this._setIncludesStates;
		}
		Cursor.prototype.getType = function() {
		  return this._type;
		}

		Cursor.prototype.toJSON = function() {
		  if (this._type === 'Cursor') {
		    throw new Err.ReqlDriverError('You cannot serialize a Cursor to JSON. Retrieve data from the cursor with `toArray` or `next`');
		  }
		  else {
		    throw new Err.ReqlDriverError('You cannot serialize a '+this._type+' to JSON. Retrieve data from the cursor with `each` or `next`');
		  }
		}

		Cursor.prototype._next = function(callback) {
		  var self = this;
		  var p = new Promise(function(resolve, reject) {
		    if (self._closed === true) {
		      reject(new Err.ReqlDriverError('You cannot called `next` on a closed '+this._type))
		    }
		    else if ((self._data.length === 0) && (self._canFetch === false)) {
		      reject(new Err.ReqlDriverError('No more rows in the '+self._type))
		    }
		    else {
		      if ((self._data.length > 0) && (self._data[0].length > self._index)) {
		        var result = self._data[0][self._index++];
		        if (result instanceof Error) {
		          reject(result);
		        }
		        else {
		          resolve(result);

		          // This could be possible if we get back batch with just one document?
		          if (self._data[0].length === self._index) {
		            self._index = 0;
		            self._data.shift();
		            if ((self._data.length === 1)
		              && (self._canFetch === true)
		              && (self._closed === false)
		              && (self._fetching === false)) {
		                self._fetch();
		            }
		          }
		        }
		      }
		      else {
		        self._pendingPromises.push({resolve: resolve, reject: reject});
		      }
		    }
		  }).nodeify(callback);
		  return p;
		}
		Cursor.prototype.hasNext = function() {
		  throw new Error('The `hasNext` command has been removed in 1.13, please use `next`.')
		}
		Cursor.prototype.toArray = function(callback) {
		  var self = this;
		  var p = new Promise(function(resolve, reject) {
		    var result = [];
		    var i =0;
		    self._each(function(err, data) {
		      if (err) {
		        reject(err);
		      }
		      else {
		        result.push(data);
		      }
		    }, function() {
		      resolve(result);
		    });
		  }).nodeify(callback);
		  return p;
		}

		Cursor.prototype._fetch = function() {
		  var self = this;
		  this._fetching = true;

		  var p = new Promise(function(resolve, reject) {
		    self.connection._continue(self.token, resolve, reject);
		  }).then(function(response) {
		    self._push(response);
		  }).error(function(error) {
		    self._fetching = false;
		    self._canFetch = false;
		    self._pushError(error);
		  })
		}

		Cursor.prototype._push = function(data) {
		  var couldfetch = this._canFetch;
		  if (data.done) this._done();
		  var response = data.response;
		  this._fetching = false;
		  // If the cursor was closed, we ignore all following response
		  if ((response.r.length > 0) && (couldfetch === true)) {
		    this._data.push(helper.makeSequence(response, this.options));
		  }
		  // this._fetching = false
		  if ((this._closed === false) && (this._canFetch) && (this._data.length <= 1)) this._fetch();
		  this._flush();
		}
		// Try to solve as many pending promises as possible
		Cursor.prototype._flush = function() {
		  while ((this._pendingPromises.length > 0) && ((this._data.length > 0) || ((this._fetching === false) && (this._canFetch === false)))) {
		    var fullfiller = this._pendingPromises.shift();
		    var resolve = fullfiller.resolve;
		    var reject = fullfiller.reject;

		    if (this._data.length > 0) {
		      var result = this._data[0][this._index++];
		      if (result instanceof Error) {
		        reject(result);
		      }
		      else {
		        resolve(result);
		      }

		      if (this._data[0].length === this._index) {
		        this._index = 0;
		        this._data.shift();
		        if ((this._data.length <= 1)
		          && (this._canFetch === true)
		          && (this._closed === false)
		          && (this._fetching === false)) {
		            this._fetch();
		        }
		      }
		    }
		    else {
		      reject(new Err.ReqlDriverError('No more rows in the '+this._type))
		    }
		  }
		}
		Cursor.prototype._pushError = function(error) {
		  this._data.push([error]);
		  this._flush();
		}

		Cursor.prototype._done = function() {
		  this._canFetch = false;
		}

		Cursor.prototype._set = function(ar) {
		  this._fetching = false;
		  this._canFetch = false;
		  if (ar.length > 0) {
		    this._data.push(ar);
		  }
		  this._flush();
		}

		Cursor.prototype.close = function(callback) {
		  var self = this;

		  self._closed = true;

		  var p = new Promise(function(resolve, reject) {
		    if ((self._canFetch === false) && (self._fetching === false)) {
		      resolve()
		    }
		    else { // since v0_4 (RethinkDB 2.0) we can (must) force a STOP request even if a CONTINUE query is pending
		      self.connection._end(self.token, resolve, reject);
		    }
		  }).nodeify(callback);
		  return p;
		}
		Cursor.prototype._each = function(callback, onFinish) {
		  if (this._closed === true) {
		    return callback(new Err.ReqlDriverError('You cannot retrieve data from a cursor that is closed'));
		  }
		  var self = this;

		  var reject = function(err) {
		    if (err.message === 'No more rows in the '+self._type+'.') {
		      if (typeof onFinish === 'function') {
		        onFinish();
		      }
		    }
		    else {
		      callback(err);
		    }
		  }
		  var resolve = function(data) {
		    var keepGoing = callback(null, data);
		    if (keepGoing === false) {
		      if (typeof onFinish === 'function') {
		        onFinish();
		      }
		    }
		    else {
		      if (self._closed === false) {
		        self._next().then(resolve).error(function(error) {
		          if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &&
		              (error.message.match(/You cannot called `next` on a closed/) === null)) {
		            reject(error);
		          }
		        });
		      }
		    }
		  }

		  self._next().then(resolve).error(function(error) {
		    // We can silence error when the cursor is closed as this
		    if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &&
		        (error.message.match(/You cannot called `next` on a closed/) === null)) {
		      reject(error);
		    }

		  });
		}
		Cursor.prototype._makeEmitter = function() {
		  this.next = function() {
		    throw new Err.ReqlDriverError('You cannot called `next` once you have bound listeners on the '+this._type)
		  }
		  this.each = function() {
		    throw new Err.ReqlDriverError('You cannot called `each` once you have bound listeners on the '+this._type)
		  }
		  this.toArray = function() {
		    throw new Err.ReqlDriverError('You cannot called `toArray` once you have bound listeners on the '+this._type)
		  }
		  this._eventEmitter = new EventEmitter();
		}
		Cursor.prototype._eachCb = function(err, data) {
		  // We should silent things if the cursor/feed is closed
		  if (this._closed === false) {
		    if (err) {
		      this._eventEmitter.emit('error', err);
		    }
		    else {
		      this._eventEmitter.emit('data', data);
		    }
		  }
		}

		var methods = [
		  'addListener',
		  'on',
		  'once',
		  'removeListener',
		  'removeAllListeners',
		  'setMaxListeners',
		  'listeners',
		  'emit'
		];

		for(var i=0; i<methods.length; i++) {
		  (function(n) {
		    var method = methods[n];
		    Cursor.prototype[method] = function() {
		      var self = this;
		      if (self._eventEmitter == null) {
		        self._makeEmitter();
		        setImmediate(function() {
		          if ((self._type === 'feed') || (self._type === 'atomFeed')) {
		            self._each(self._eachCb.bind(self));
		          }
		          else {
		            self._each(self._eachCb.bind(self), function() {
		              self._eventEmitter.emit('end');
		            });
		          }
		        });
		      }
		      var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		      self._eventEmitter[method].apply(self._eventEmitter, _args);
		    };
		  })(i);
		}

		module.exports = Cursor;


	/***/ },
	/* 54 */
	/***/ function(module, exports, __webpack_require__) {

		var Readable = __webpack_require__(55).Readable;
		var Cursor = __webpack_require__(53);
		var util = __webpack_require__(51);

		// Experimental, but should work fine.
		function ReadableStream(options, cursor) {
		  if (cursor) this._cursor = cursor;
		  this._pending = 0; // How many time we called _read while no cursor was available
		  this._index = 0;
		  this._maxRecursion = 1000; // Hardcoded
		  this._highWaterMark = options.highWaterMark;

		  Readable.call(this, {
		    objectMode: true,
		    highWaterMark: this._highWaterMark
		  });
		};
		util.inherits(ReadableStream, Readable);


		ReadableStream.prototype._setCursor = function(cursor) {
		  if (cursor instanceof Cursor === false) {
		    this.emit('error', new Error('Cannot create a stream on a single value.'));
		    return this;
		  }
		  this._cursor = cursor;
		  this._fetchAndDecrement();
		}
		ReadableStream.prototype._read = function(size) {
		  this._count++;
		  if (this._cursor === undefined) {
		    this._pending++;
		    return;
		  }

		  this._recursion = 0;
		  this._fetch();
		}

		//TODO: Refactor with _fetch?
		ReadableStream.prototype._fetchAndDecrement = function() {
		  var self = this;
		  self._pending--;
		  if (self._pending < 0) {
		    return;
		  }

		  if (self._cursor._closed === true) {
		    self.push(null);
		  }
		  else {
		    self._cursor._next().then(function(data) {
		      // Silently drop null values for now
		      if (data === null) {
		        if (self._recursion++ === self._maxRecursion) {
		          //Avoid maximum call stack errors
		          process.nextTick(function() {
		            self._fetchAndDecrement();
		          });
		        }
		        else {
		          self._fetchAndDecrement();
		        }
		      }
		      else {
		        if (self.push(data) !== false) {
		          if (self._recursion++ === self._maxRecursion) {
		            process.nextTick(function() {
		              self._fetchAndDecrement();
		            });
		          }
		          else {
		            self._fetchAndDecrement();
		          }
		        }
		      }
		    }).error(function(error) {
		      if (error.message.match(/No more rows in the/)) {
		        self.push(null);
		      }
		      else if (error.message === 'You cannot retrieve data from a cursor that is closed.') {
		        // if the user call `close`, the cursor may reject pending requests. We just
		        // ignore them here.
		      }
		      else {
		        self.emit('error', error);
		      }
		    });
		  }
		}

		ReadableStream.prototype._fetch = function() {
		  var self = this;
		  if (self._cursor._closed === true) {
		    self.push(null);
		  }
		  else {
		    self._cursor._next().then(function(data) {
		      // Silently drop null values for now
		      if (data === null) {
		        if (self._recursion++ === self._maxRecursion) {
		          process.nextTick(function() {
		            self._fetch();
		          });
		        }
		        else {
		          self._fetch();
		        }
		      }
		      else {
		        if (self.push(data) !== false) {
		          if (self._recursion++ === self._maxRecursion) {
		            process.nextTick(function() {
		              self._fetch();
		            });
		          }
		          else {
		            self._fetch();
		          }
		        }
		      }
		    }).error(function(error) {
		      if (error.message.match(/No more rows in the/)) {
		        self.push(null);
		      }
		      else if (error.message === 'You cannot retrieve data from a cursor that is closed.') {
		        // if the user call `close`, the cursor may reject pending requests. We just
		        // ignore them here.
		      }
		      else {
		        self.emit('error', error);
		      }
		    });
		  }
		}


		ReadableStream.prototype.close = function() {
		  this.push(null);
		  return this._cursor.close();
		}

		module.exports = ReadableStream;


	/***/ },
	/* 55 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(12);

	/***/ },
	/* 56 */
	/***/ function(module, exports) {

		// Metadata we keep per query
		function Metadata(resolve, reject, query, options) {
		  this.resolve = resolve;
		  this.reject = reject;
		  this.query = query; // The query in case we have to build a backtrace
		  this.options = options;
		  this.cursor = false;
		}

		Metadata.prototype.setCursor = function() {
		  this.cursor = true;
		}

		Metadata.prototype.setEnd = function(resolve, reject) {
		  this.endResolve = resolve;
		  this.endReject = reject;
		}

		Metadata.prototype.setCallbacks = function(resolve, reject) {
		  this.resolve = resolve;
		  this.reject = reject;
		}
		Metadata.prototype.removeCallbacks = function() {
		  this.resolve = null;
		  this.reject = null;
		}
		Metadata.prototype.removeEndCallbacks = function() {
		  this.endResolve = null;
		  this.endReject = null;
		}

		module.exports = Metadata;


	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {

		var Promise = __webpack_require__(3);
		var protodef = __webpack_require__(42);
		var termTypes = protodef.Term.TermType;

		var Error = __webpack_require__(52);
		var helper = __webpack_require__(41);
		var ReadableStream = __webpack_require__(54);
		var WritableStream = __webpack_require__(58);
		var TransformStream = __webpack_require__(59);

		function Term(r, value, error) {
		    var self = this;
		    var term = function(field) {
		        if (Term.prototype._fastArity(arguments.length, 1) === false) {
		            var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		            Term.prototype._arity(_args, 1, '(...)', self);
		        }
		        return term.bracket(field);
		    }
		    helper.changeProto(term, self);

		    if (value === undefined) {
		        term._query = [];
		    }
		    else {
		        term._query = value;
		    }
		    term._r = r; // Keep a reference to r for global settings

		    if (error !== undefined) {
		        term._error = error;
		        term._frames = [];
		    }

		    return term;
		}

		// run([connection][, options][, callback])
		Term.prototype.run = function(connection, options, callback) {
		    var self = this;

		    if (self._error != null) {
		      var error = new Error.ReqlRuntimeError(self._error, self._query, {b: self._frames});
		      return Promise.reject(error);
		    }

		    if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {
		        if (typeof options === 'function') {
		            callback = options;
		            options = {};
		        }
		        else {
		            if (!helper.isPlainObject(options)) options = {};
		        }

		        if (connection._isOpen() !== true) {
		            return new Promise(function(resolve, reject) {
		                reject(new Error.ReqlDriverError('`run` was called with a closed connection', self._query));
		            });
		        }
		        var p = new Promise(function(resolve, reject) {
		            var token = connection.token++;

		            var query = [protodef.Query.QueryType.START];
		            query.push(self._query);

		            var _options = {};
		            var sendOptions = false;
		            if (connection.db != null) {
		                sendOptions = true;
		                _options.db = self._r.db(connection.db)._query;
		            }

		            //For testing only
		            if (connection.max_batch_rows) {
		                sendOptions = true;
		                _options.max_batch_rows = connection.max_batch_rows;
		            }
		            if (self._r.arrayLimit != null) {
		                sendOptions = true;
		                _options[self._translateArgs['arrayLimit']] = self._r.arrayLimit;
		            };


		            var keepGoing = true; // we need it just to avoir calling resolve/reject multiple times
		            helper.loopKeys(options, function(options, key) {
		                if (keepGoing === true) {
		                    if ((key === 'readMode') || (key === 'durability') || (key === 'db') ||
		                        (key === 'noreply') || (key === 'arrayLimit') || (key === 'profile')) {

		                        sendOptions = true;
		                        if (key === 'db') {
		                            _options[key] = self._r.db(options[key])._query;
		                        }
		                        else if (self._translateArgs.hasOwnProperty(key)) {
		                            _options[self._translateArgs[key]] = new Term(self._r).expr(options[key])._query;
		                        }
		                        else {
		                            _options[key] = new Term(self._r).expr(options[key])._query;
		                        }
		                    }
		                    else if ((key !== 'timeFormat') && (key !== 'groupFormat') &&
		                            (key !== 'binaryFormat') && (key !== 'cursor') &&
		                            (key !== 'readable') && (key !== 'writable') &&
		                            (key !== 'transform') && (key !== 'stream') &&
		                            (key !== 'highWaterMark')) {
		                        reject(new Error.ReqlDriverError('Unrecognized option `'+key+'` in `run`. Available options are readMode <string>, durability <string>, noreply <bool>, timeFormat <string>, groupFormat: <string>, profile <bool>, binaryFormat <bool>, cursor <bool>, stream <bool>'));
		                        keepGoing = false;
		                    }
		                }
		            });

		            if (keepGoing === false) {
		                connection.emit('release');
		                return // The promise was rejected in the loopKeys
		            }

		            if (sendOptions === true) {
		                query.push(_options);
		            }
		            connection._send(query, token, resolve, reject, self._query, options);
		        }).nodeify(callback);
		    }
		    else {
		        var poolMaster = self._r.getPoolMaster(); // if self._r is defined, so is self._r.getPool()
		        if (!poolMaster) {
		            throw new Error.ReqlDriverError('`run` was called without a connection and no pool has been created', self._query);
		        }
		        else {
		            if (typeof connection === 'function') {
		                // run(callback);
		                callback = connection;
		                options = {};
		            }
		            else if (helper.isPlainObject(connection)) {
		                // run(options[, callback])
		                callback = options;
		                options = connection;
		            }
		            else {
		                options = {};
		            }


		            var p = new Promise(function(resolve, reject) {
		                poolMaster.getConnection().then(function(connection) {
		                    var token = connection.token++;
		                    var query = [protodef.Query.QueryType.START];
		                    query.push(self._query);

		                    var _options = {};
		                    var sendOptions = false;
		                    if (connection.db != null) {
		                        sendOptions = true;
		                        _options.db = self._r.db(connection.db)._query;
		                    }
		                    if (self._r.arrayLimit != null) {
		                        sendOptions = true;
		                        _options[self._translateArgs['arrayLimit']] = self._r.arrayLimit;
		                    };

		                    var keepGoing = true;
		                    helper.loopKeys(options, function(options, key) {
		                        if (keepGoing === true) {
		                            if ((key === 'readMode') || (key === 'durability') || (key === 'db') ||
		                               (key === 'noreply') || (key === 'arrayLimit') || (key === 'profile')) {

		                                sendOptions = true;
		                                if (key === 'db') {
		                                    _options[key] = self._r.db(options[key])._query;
		                                }
		                                else if (self._translateArgs.hasOwnProperty(key)) {
		                                    _options[self._translateArgs[key]] = new Term(self._r).expr(options[key])._query
		                                }
		                                else {
		                                    _options[key] = new Term(self._r).expr(options[key])._query
		                                }
		                            }
		                            else if ((key !== 'timeFormat') && (key !== 'groupFormat') &&
		                                    (key !== 'binaryFormat') && (key !== 'cursor') &&
		                                    (key !== 'readable') && (key !== 'writable') &&
		                                    (key !== 'transform') && (key !== 'stream') &&
		                                    (key !== 'highWaterMark')) {

		                                setTimeout( function() {
		                                    reject(new Error.ReqlDriverError('Unrecognized option `'+key+'` in `run`. Available options are readMode <string>, durability <string>, noreply <bool>, timeFormat <string>, groupFormat: <string>, profile <bool>, binaryFormat <string>, cursor <bool>, stream <bool>'));
		                                }, 0);
		                                keepGoing = false;
		                                return false;
		                            }
		                        }
		                    });

		                    if (keepGoing === false) {
		                        connection.emit('release');
		                        return // The promise was rejected in the loopKeys
		                    }

		                    if (sendOptions === true) {
		                        query.push(_options);
		                    }
		                    connection._send(query, token, resolve, reject, self._query, options);
		                }).error(function(error) {
		                    reject(error);
		                });
		            }).nodeify(callback);
		        }
		    }

		    //if (options.noreply) return self; // Do not return a promise if the user ask for no reply.

		    return p;
		}

		Term.prototype.toStream = function(connection, options) {
		    if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {
		        if (helper.isPlainObject(options) === false) {
		            options = {};
		        }
		        if (options.readable === true) {
		            return this._toReadableStream(connection, options);
		        }
		        else if (options.writable === true) {
		            return this._toWritableStream(connection, options);
		        }
		        else if (options.transform === true) {
		            return this._toTransformStream(connection, options);
		        }
		        else {
		            return this._toReadableStream(connection, options);
		        }
		    }
		    else {
		        options = connection;
		        if (helper.isPlainObject(options) === false) {
		            options = {};
		        }
		        if (options.readable === true) {
		            return this._toReadableStream(options);
		        }
		        else if (options.writable === true) {
		            return this._toWritableStream(options);
		        }
		        else if (options.transform === true) {
		            return this._toTransformStream(options);
		        }
		        else {
		            return this._toReadableStream(options);
		        }
		    }
		}

		Term.prototype._toReadableStream = function(connection, options) {
		    var stream;

		    var _options = {};
		    if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {
		        //toStream make sure that options is an object
		        helper.loopKeys(options, function(obj, key) {
		            _options[key] = obj[key];
		        });
		        _options.cursor = true;
		        stream = new ReadableStream(_options);
		        this.run(connection, _options).then(function(cursor) {
		            stream._setCursor(cursor);
		        }).error(function(error) {
		            stream.emit('error', error);
		        });
		    }
		    else {
		        helper.loopKeys(connection, function(obj, key) {
		            _options[key] = obj[key];
		        });
		        _options.cursor = true;
		        stream = new ReadableStream(_options);
		        this.run(_options).then(function(cursor) {
		            stream._setCursor(cursor);
		        }).error(function(error) {
		            stream.emit('error', error);
		        });
		    }
		    return stream;
		}

		Term.prototype._toWritableStream = function(connection, options) {
		    if (this._query[0] !== termTypes.TABLE) {
		        throw new Error.ReqlDriverError('Cannot create a writable stream on something else than a table.');
		    }

		    if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {
		        return new WritableStream(this, options, connection);
		    }
		    else {
		        return new WritableStream(this, connection);
		    }
		}
		Term.prototype._toTransformStream = function(connection, options) {
		    if (this._query[0] !== termTypes.TABLE) {
		        throw new Error.ReqlDriverError('Cannot create a writable stream on something else than a table.');
		    }

		    if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {
		        return new TransformStream(this, options, connection);
		    }
		    else {
		        return new TransformStream(this, connection);
		    }
		}


		// Manipulating databases
		Term.prototype.dbCreate = function(db) {
		    // Check for arity is done in r.prototype.dbCreate
		    this._noPrefix(this, 'dbCreate');

		    var term = new Term(this._r);
		    term._query.push(termTypes.DB_CREATE);
		    var args = [new Term(this._r).expr(db)._query]
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.dbDrop = function(db) {
		    this._noPrefix(this, 'dbDrop');

		    var term = new Term(this._r);
		    term._query.push(termTypes.DB_DROP);
		    var args = [new Term(this._r).expr(db)._query]
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.dbList = function() {
		    this._noPrefix(this, 'dbList');

		    var term = new Term(this._r);
		    term._query.push(termTypes.DB_LIST)
		    return term;
		}

		// Manipulating Tables
		Term.prototype.tableCreate = function(table, options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 1, 2, 'tableCreate', self);
		    }


		    var term = new Term(self._r);
		    term._query.push(termTypes.TABLE_CREATE)

		    var args = [];
		    if (Array.isArray(self._query) && (self._query.length > 0)) {
		        args.push(self); // Push db
		    }
		    args.push(new Term(self._r).expr(table))
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        // Check for non valid key
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'primaryKey')
		                    && (key !== 'durability')
		                    && (key !== 'shards')
		                    && (key !== 'replicas')
		                    && (key !== 'primaryReplicaTag')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `tableCreate`', self._query, 'Available options are primaryKey <string>, durability <string>, shards <number>, replicas <number/object>, primaryReplicaTag <object>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}

		Term.prototype.tableDrop = function(table) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'tableDrop', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.TABLE_DROP)

		    var args = [];
		    if (Array.isArray(this._query) && (this._query.length > 0)) {
		        args.push(this); // push db
		    }
		    args.push(new Term(this._r).expr(table))
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.tableList = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'tableList', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.TABLE_LIST);

		    var args = [];
		    if (Array.isArray(this._query) && (this._query.length > 0)) {
		        args.push(this);
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.indexList = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'indexList', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.INDEX_LIST);
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.indexCreate = function(name, fn, options) {
		    if (this._fastArityRange(arguments.length, 1, 3) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 1, 3, 'indexCreate', this);
		    }

		    if ((options == null) && (helper.isPlainObject(fn))) {
		        options = fn;
		        fn = undefined;
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.INDEX_CREATE);
		    var args = [this];
		    args.push(new Term(this._r).expr(name));
		    if (typeof fn !== 'undefined') args.push(new Term(this._r).expr(fn)._wrap());
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        // There is no need to translate here
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'multi') && (key !== 'geo')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `indexCreate`', self._query, 'Available option is multi <bool> and geo <bool>');
		            }
		        });
		        term._query.push(new Term(this._r).expr(options)._query);
		    }
		    return term;
		}
		Term.prototype.indexDrop = function(name) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'indexDrop', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.INDEX_DROP);
		    var args = [this, new Term(this._r).expr(name)];
		    term._fillArgs(args);
		    return term;
		}

		Term.prototype.indexStatus = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    var term = new Term(this._r);
		    term._query.push(termTypes.INDEX_STATUS);
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.indexWait = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    var term = new Term(this._r);
		    term._query.push(termTypes.INDEX_WAIT);
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.indexRename = function(oldName, newName, options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 2, 3) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 2, 3, 'indexRename', self);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.INDEX_RENAME);
		    var args = [this, new Term(this._r).expr(oldName), new Term(this._r).expr(newName)];
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if (key !== 'overwrite') {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `indexRename`', self._query, 'Available options are overwrite <bool>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }


		    return term;
		}
		Term.prototype.changes = function(options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 0, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 0, 1, 'changes', self);
		    }

		    var term = new Term(self._r);
		    term._query.push(termTypes.CHANGES);
		    var args = [self];
		    term._fillArgs(args);
		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'squash') && (key !== 'includeStates')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `changes`', self._query, 'Available options are squash <bool>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}

		// Writing data
		Term.prototype.insert = function(documents, options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 1, 2, 'insert', self);
		    }

		    var term = new Term(self._r);
		    term._query.push(termTypes.INSERT);
		    var args = [self, new Term(self._r).expr(documents)];
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'returnChanges') && (key !== 'durability') && (key !== 'conflict')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `insert`', self._query, 'Available options are returnChanges <bool>, durability <string>, conflict <string>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}
		Term.prototype.update = function(newValue, options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 1, 2, 'update', self);
		    }

		    var term = new Term(self._r);
		    term._query.push(termTypes.UPDATE);
		    var args = [self, new Term(self._r).expr(newValue)._wrap()];
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'returnChanges') && (key !== 'durability') && (key !== 'nonAtomic')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `update`', self._query, 'Available options are returnChanges <bool>, durability <string>, nonAtomic <bool>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}
		Term.prototype.replace = function(newValue, options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 1, 2, 'replace', self);
		    }

		    var term = new Term(self._r);
		    term._query.push(termTypes.REPLACE);
		    var args = [self, new Term(self._r).expr(newValue)._wrap()];
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'returnChanges') && (key !== 'durability') && (key !== 'nonAtomic')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `replace`', self._query, 'Available options are returnChanges <bool>, durability <string>, nonAtomic <bool>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}
		Term.prototype.delete = function(options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 0, 1, 'delete', self);
		    }

		    var term = new Term(self._r);
		    term._query.push(termTypes.DELETE);
		    var args = [self];
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'returnChanges') && (key !== 'durability')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `delete`', self._query, 'Available options are returnChanges <bool>, durability <string>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}
		Term.prototype.sync = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'sync', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.SYNC)
		    var args = [this._query];
		    term._fillArgs(args);
		    return term;
		}

		// Selecting data
		Term.prototype.db = function(db) {
		    this._noPrefix(this, 'db');
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'db', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.DB)
		    var args = [new Term(this._r).expr(db)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.table = function(table, options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 1, 2, 'table', self);
		    }

		    var term = new Term(self._r);
		    term._query.push(termTypes.TABLE)

		    var args = [];
		    if (Array.isArray(self._query) && (self._query.length > 0)) {
		        args.push(self);
		    }
		    args.push(new Term(self._r).expr(table))
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if (key !== 'readMode') {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `table`', self._query, 'Available option is readMode <string>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}
		Term.prototype.get = function(primaryKey) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'get', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.GET);
		    var args = [this, new Term(this._r).expr(primaryKey)]
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.getAll = function() {
		    // We explicitly _args here, so fastArityRange is not useful
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'getAll', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.GET_ALL);

		    var args = [];
		    args.push(this);
		    for(var i=0; i<_args.length-1; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    if ((_args.length > 1) && (helper.isPlainObject(_args[_args.length-1])) && (_args[_args.length-1].index !== undefined)) {
		        term._fillArgs(args);
		        term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);
		    }
		    else {
		        args.push(new Term(this._r).expr(_args[_args.length-1]))
		        term._fillArgs(args);
		    }
		    return term;
		}
		Term.prototype.between = function(start, end, options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 2, 3) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 2, 3, 'between', self);
		    }

		    var term = new Term(self._r);
		    term._query.push(termTypes.BETWEEN);
		    var args = [self, new Term(self._r).expr(start), new Term(self._r).expr(end)]
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'index') && (key !== 'leftBound') && (key !== 'rightBound')){
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `between`', self._query, 'Available options are index <string>, leftBound <string>, rightBound <string>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}
		Term.prototype.minval = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.MINVAL);
		    return term;
		}
		Term.prototype.maxval = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.MAXVAL);
		    return term;
		}

		Term.prototype.filter = function(filter, options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 1, 2, 'filter', self);
		    }

		    var term = new Term(self._r);
		    term._query.push(termTypes.FILTER);
		    var args = [self, new Term(self._r).expr(filter)._wrap()]
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if (key !== 'default') {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `filter`', self._query, 'Available option is filter');
		            }
		        })
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}

		// Joins
		Term.prototype.innerJoin = function(sequence, predicate) {
		    if (this._fastArity(arguments.length, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 2, 'innerJoin', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.INNER_JOIN);
		    var args = [this._query];
		    args.push(new Term(this._r).expr(sequence)._query);
		    args.push(new Term(this._r).expr(predicate)._wrap()._query);
		    term._fillArgs(args);

		    return term;
		}
		Term.prototype.outerJoin = function(sequence, predicate) {
		    if (this._fastArity(arguments.length, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 2, 'outerJoin', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.OUTER_JOIN);
		    var args = [this];
		    args.push(new Term(this._r).expr(sequence));
		    args.push(new Term(this._r).expr(predicate)._wrap());
		    term._fillArgs(args);

		    return term;
		}
		Term.prototype.eqJoin = function(rightKey, sequence, options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 2, 3) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 2, 3, 'eqJoin', self);
		    }

		    var term = new Term(self._r);
		    term._query.push(termTypes.EQ_JOIN);
		    var args = [self];
		    args.push(new Term(self._r).expr(rightKey)._wrap());
		    args.push(new Term(self._r).expr(sequence));
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if (key !== 'index') {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `eqJoin`', self._query, 'Available option is index <string>');
		            }
		        })
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}
		Term.prototype.zip = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'zip', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.ZIP);
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}



		// Transformation
		Term.prototype.map = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'map', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.MAP);
		    var args = [];
		    if (Array.isArray(this._query) && (this._query.length > 0)) {
		        args.push(this);
		    }
		    for(var i=0; i<_args.length-1; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    // Make sure that we don't push undefined if no argument is passed to map,
		    // in which case the server will handle the case and return an error.
		    if (_args.length> 0) {
		        args.push(new Term(this._r).expr(_args[_args.length-1])._wrap())
		    }
		    term._fillArgs(args);

		    return term;
		}
		Term.prototype.withFields = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'withFields', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.WITH_FIELDS);
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);

		    return term;
		}
		Term.prototype.concatMap = function(transformation) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'concatMap', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.CONCAT_MAP);
		    var args = [this];
		    args.push(new Term(this._r).expr(transformation)._wrap())
		    term._fillArgs(args);

		    return term;
		}
		Term.prototype.orderBy = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'orderBy', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.ORDER_BY);

		    var args = [this];
		    for(var i=0; i<_args.length-1; i++) {
		        if ((_args[i] instanceof Term) &&
		                ((_args[i]._query[0] === termTypes.DESC) || (_args[i]._query[0] === termTypes.ASC))) {
		            args.push(new Term(this._r).expr(_args[i]))
		        }
		        else {
		            args.push(new Term(this._r).expr(_args[i])._wrap())
		        }
		    }
		    // We actually don't need to make the difference here, but...
		    if ((_args.length > 0) && (helper.isPlainObject(_args[_args.length-1])) && (_args[_args.length-1].index !== undefined)) {
		        term._fillArgs(args);
		        term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);
		    }
		    else {
		        if ((_args[_args.length-1] instanceof Term) &&
		            ((_args[_args.length-1]._query[0] === termTypes.DESC) || (_args[_args.length-1]._query[0] === termTypes.ASC))) {
		            args.push(new Term(this._r).expr(_args[_args.length-1]))
		        }
		        else {
		            args.push(new Term(this._r).expr(_args[_args.length-1])._wrap())
		        }
		        term._fillArgs(args);
		    }
		    return term;

		}
		Term.prototype.desc = function(field) {
		    this._noPrefix(this, 'desc');
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'desc', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.DESC)
		    var args = [new Term(this._r).expr(field)._wrap()];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.asc = function(field) {
		    this._noPrefix(this, 'asc');
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'asc', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.ASC)
		    var args = [new Term(this._r).expr(field)._wrap()];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.skip = function(value) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'skip', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.SKIP)
		    var args = [this, new Term(this._r).expr(value)]
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.limit = function(value) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'limit', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.LIMIT)
		    var args = [this, new Term(this._r).expr(value)]
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.slice = function(start, end, options) {
		    if (this._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 1, 3, 'slice', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.SLICE);

		    var args = [];
		    args.push(this);
		    args.push(new Term(this._r).expr(start));

		    if ((end !== undefined) && (options !== undefined)) {
		        args.push(new Term(this._r).expr(end));
		        term._fillArgs(args);
		        term._query.push(new Term(this._r).expr(translateOptions(options))._query);
		    }
		    else if ((end !== undefined) && (options === undefined)) {
		        if (helper.isPlainObject(end) === false) {
		            args.push(new Term(this._r).expr(end));
		            term._fillArgs(args);
		        }
		        else {
		            term._fillArgs(args);
		            term._query.push(new Term(this._r).expr(translateOptions(end))._query);
		        }
		    }
		    else { // end and options are both undefined
		        term._fillArgs(args);
		    }
		    return term;
		}
		Term.prototype.nth = function(value) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'nth', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.NTH)
		    var args = [this._query, new Term(this._r).expr(value)]
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.offsetsOf = function(predicate) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'indexesOf', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.OFFSETS_OF)
		    var args = [this, new Term(this._r).expr(predicate)._wrap()];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.indexesOf = Term.prototype.offsetsOf;

		Term.prototype.isEmpty = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'isEmpty', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.IS_EMPTY)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.union = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}

		    var term = new Term(this._r);
		    term._query.push(termTypes.UNION)
		    var args = [];
		    if (Array.isArray(this._query) && (this._query.length > 0)) {
		        args.push(this);
		    }

		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.sample = function(size) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'sample', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.SAMPLE)
		    var args = [this, new Term(this._r).expr(size)];
		    term._fillArgs(args);
		    return term;
		}

		// Aggregations
		Term.prototype.reduce = function(func) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'reduce', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.REDUCE)
		    var args = [this, new Term(this._r).expr(func)._wrap()];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.count = function(filter) {
		    if (this._fastArityRange(arguments.length, 0, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 0, 1, 'count', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.COUNT);
		    var args = [];
		    args.push(this);
		    if (filter !== undefined) {
		        args.push(new Term(this._r).expr(filter)._wrap())
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.distinct = function(options) {
		    var self= this;
		    if (self._fastArityRange(arguments.length, 0, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 0, 1, 'distinct', self);
		    }

		    var term = new Term(self._r);
		    term._query.push(termTypes.DISTINCT)
		    var args = [self];
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        var keepGoing = true;
		        helper.loopKeys(options, function(obj, key) {
		            if ((keepGoing === true) && (key !== 'index')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distinct`', self._query, 'Available option is index: <string>');
		                keepGoing = false;
		            }
		        });
		        if (keepGoing === true) {
		            term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		        }
		    }

		    return term;
		}
		Term.prototype.group = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    var self = this;
		    self._arityRange(_args, 1, Infinity, 'group', self);

		    var term = new Term(self._r);
		    term._query.push(termTypes.GROUP);
		    var args = [self];
		    for(var i=0; i<_args.length-1; i++) {
		        args.push(new Term(self._r).expr(_args[i])._wrap())
		    }
		    if (_args.length > 0) {
		        if (helper.isPlainObject(_args[_args.length-1])) {
		            helper.loopKeys(_args[_args.length-1], function(obj, key) {
		               if ((key !== 'index')
		                && (key !==  'multi')) {
		                    throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `group`', self._query, 'Available options are index: <string>, multi <boolean>');
		                }
		            });
		            term._fillArgs(args);
		            term._query.push(new Term(self._r).expr(translateOptions(_args[_args.length-1]))._query);
		        }
		        else {
		            args.push(new Term(self._r).expr(_args[_args.length-1])._wrap())
		            term._fillArgs(args);
		        }
		    }
		    else {
		        term._fillArgs(args);
		    }

		    return term;
		}
		Term.prototype.split = function(separator, max) {
		    if (this._fastArityRange(arguments.length, 0, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 0, 2, 'split', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.SPLIT)
		    var args = [this];
		    if (separator !== undefined) {
		        args.push(new Term(this._r).expr(separator))
		        if (max !== undefined) {
		            args.push(new Term(this._r).expr(max))
		        }
		    }
		    term._fillArgs(args);

		    return term;
		}

		Term.prototype.ungroup = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'ungroup', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.UNGROUP)
		    var args = [this._query];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.contains = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'contains', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.CONTAINS)
		    var args = [this._query];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i])._wrap())
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.sum = function(field) {
		    if (this._fastArityRange(arguments.length, 0, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 0, 1, 'sum', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.SUM);
		    var args = [this];
		    if (field !== undefined) {
		        args.push(new Term(this._r).expr(field)._wrap())
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.avg = function(field) {
		    if (this._fastArityRange(arguments.length, 0, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 0, 1, 'avg', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.AVG)
		    var args = [this];
		    if (field !== undefined) {
		        args.push(new Term(this._r).expr(field)._wrap())
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.min = function(field) {
		    if (this._fastArityRange(arguments.length, 0, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 0, 1, 'min', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.MIN)
		    var args = [this];
		    if (field !== undefined) {
		        if (helper.isPlainObject(field)) {
		          term._fillArgs(args);
		          term._query.push(new Term(this._r).expr(translateOptions(field))._query);
		        }
		        else {
		          args.push(new Term(this._r).expr(field)._wrap());
		          term._fillArgs(args);
		        }
		    }
		    else {
		      term._fillArgs(args);
		    }
		    return term;
		}
		Term.prototype.max = function(field) {
		    if (this._fastArityRange(arguments.length, 0, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 0, 1, 'max', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.MAX)
		    var args = [this];
		    if (field !== undefined) {
		        if (helper.isPlainObject(field)) {
		          term._fillArgs(args);
		          term._query.push(new Term(this._r).expr(translateOptions(field))._query);
		        }
		        else {
		          args.push(new Term(this._r).expr(field)._wrap())
		          term._fillArgs(args);
		        }
		    }
		    else {
		      term._fillArgs(args);
		    }
		    return term;
		}



		// Document manipulation
		Term.prototype.row = function() {
		    this._noPrefix(this, 'row');
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'r.row', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.IMPLICIT_VAR)
		    return term;
		}
		Term.prototype.pluck = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'pluck', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.PLUCK)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.without = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'without', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.WITHOUT)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.merge = function(arg) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'merge', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.MERGE)
		    var args = [this, new Term(this._r).expr(arg)._wrap()];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.literal = function(obj) {
		    this._noPrefix(this, 'literal');
		    // The test for arity is performed in r.literal

		    var term = new Term(this._r);
		    term._query.push(termTypes.LITERAL);
		    if (arguments.length > 0) {
		        var args = [new Term(this._r).expr(obj)];
		        term._fillArgs(args);
		    }
		    return term;
		}
		Term.prototype.append = function(value) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'append', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.APPEND)
		    var args = [this, new Term(this._r).expr(value)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.prepend = function(value) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'prepend', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.PREPEND)
		    var args = [this, new Term(this._r).expr(value)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.difference = function(other) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'difference', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.DIFFERENCE)
		    var args = [this, new Term(this._r).expr(other)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.setInsert = function(other) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'setInsert', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.SET_INSERT)
		    var args = [this, new Term(this._r).expr(other)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.setUnion = function(other) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'setUnion', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.SET_UNION)
		    var args = [this, new Term(this._r).expr(other)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.setIntersection = function(other) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'setIntersection', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.SET_INTERSECTION)
		    var args = [this, new Term(this._r).expr(other)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.setDifference = function(other) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'setDifference', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.SET_DIFFERENCE)
		    var args = [this, new Term(this._r).expr(other)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.getField = function(field) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, '(...)', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.GET_FIELD)
		    var args = [this, new Term(this._r).expr(field)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.bracket = function(field) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, '(...)', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.BRACKET)
		    var args = [this, new Term(this._r).expr(field)];
		    term._fillArgs(args);
		    return term;
		}

		Term.prototype.hasFields = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'hasFields', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.HAS_FIELDS)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;

		}
		Term.prototype.insertAt = function(index, value) {
		    if (this._fastArity(arguments.length, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 2, 'insertAt', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.INSERT_AT)
		    var args = [this, new Term(this._r).expr(index), new Term(this._r).expr(value)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.spliceAt = function(index, array) {
		    if (this._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 1, 2, 'spliceAt', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.SPLICE_AT)
		    var args = [this, new Term(this._r).expr(index), new Term(this._r).expr(array)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.deleteAt = function(start, end) {
		    if (this._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 1, 2, 'deleteAt', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.DELETE_AT);
		    var args = [this, new Term(this._r).expr(start)];
		    if (end !== undefined) {
		        args.push(new Term(this._r).expr(end))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.changeAt = function(index, value) {
		    if (this._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 1, 2, 'changeAt', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.CHANGE_AT);
		    var args = [this];
		    args.push(new Term(this._r).expr(index))
		    args.push(new Term(this._r).expr(value))
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.keys = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'keys', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.KEYS)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.object = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._noPrefix(this, 'object');
		    this._arityRange(_args, 0, Infinity, 'object', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.OBJECT)
		    var args = [];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}



		// String
		Term.prototype.match = function(regex) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'match', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.MATCH)
		    var args = [this, new Term(this._r).expr(regex)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.upcase = function(regex) {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'upcase', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.UPCASE)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.downcase = function(regex) {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'upcase', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.DOWNCASE)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}




		// Math and Logic
		Term.prototype.add = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'add', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.ADD)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.sub = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'sub', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.SUB)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.mul = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'mul', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.MUL)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.div = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'div', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.DIV)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.mod = function(b) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'mod', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.MOD)
		    var args = [this, new Term(this._r).expr(b)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.and = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}

		    var term = new Term(this._r);
		    term._query.push(termTypes.AND)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.or = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}

		    var term = new Term(this._r);
		    term._query.push(termTypes.OR)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.eq = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'eq', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.EQ)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.ne = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'ne', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.NE)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.gt = function(other) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'gt', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.GT)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.ge = function(other) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'ge', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.GE)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.lt = function(other) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'lt', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.LT)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.le = function(other) {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'le', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.LE)
		    var args = [this];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.not = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'not', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.NOT)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.random = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    var self = this;
		    self._noPrefix(this, 'random');
		    self._arityRange(_args, 0, 3, 'random', self);

		    var term = new Term(self._r);
		    term._query.push(termTypes.RANDOM);

		    var args = [];
		    for(var i=0; i<_args.length-1; i++) {
		        args.push(new Term(self._r).expr(_args[i]))
		    }
		    if (_args.length > 0) {
		        if (helper.isPlainObject(_args[_args.length-1])) {
		            helper.loopKeys(_args[_args.length-1], function(obj, key) {
		                if (key !== 'float') {
		                    throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `random`', self._query, 'Available option is float: <boolean>');
		                }
		            });
		            term._fillArgs(args);
		            term._query.push(new Term(self._r).expr(translateOptions(_args[_args.length-1]))._query);
		        }
		        else {
		            args.push(new Term(self._r).expr(_args[_args.length-1]))
		            term._fillArgs(args);
		        }
		    }
		    else {
		        term._fillArgs(args);
		    }
		    return term;
		}
		Term.prototype.floor = function() {
		    if (this._fastArityRange(arguments.length, 0, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 0, 1, 'floor', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.FLOOR)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.ceil = function() {
		    if (this._fastArityRange(arguments.length, 0, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 0, 1, 'ceil', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.CEIL)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.round = function() {
		    if (this._fastArityRange(arguments.length, 0, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 0, 1, 'round', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.ROUND)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}

		// Dates and times
		Term.prototype.now = function() {
		    this._noPrefix(this, 'now');

		    var term = new Term(this._r);
		    term._query.push(termTypes.NOW)
		    return term;
		}
		Term.prototype.time = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._noPrefix(this, 'time');
		    // Special check for arity
		    var foundArgs = false;
		    for(var i=0; i<_args.length; i++) {
		        if ((_args[i] instanceof Term) && (_args[i]._query[0] === termTypes.ARGS)) {
		            foundArgs = true;
		            break;
		        }
		    }
		    if (foundArgs === false) {
		        if ((_args.length !== 4) && (_args.length !== 7)) {
		            throw new Error.ReqlDriverError('`r.time` called with '+_args.length+' argument'+((_args.length>1)?'s':''), null, '`r.time` takes 4 or 7 arguments');
		        }
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.TIME)
		    var args = [];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.epochTime = function(epochTime) {
		    this._noPrefix(this, 'epochTime');

		    var term = new Term(this._r);
		    term._query.push(termTypes.EPOCH_TIME)
		    var args = [new Term(this._r).expr(epochTime)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.ISO8601 = function(isoTime, options) {
		    this._noPrefix(this, 'ISO8601');
		    if (this._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 1, 2, 'ISO8601', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.ISO8601)
		    var args = [new Term(this._r).expr(isoTime)._query];
		    term._fillArgs(args);
		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if (key !== 'defaultTimezone') {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `ISO8601`. Available options are primaryKey <string>, durability <string>, datancenter <string>');
		            }
		        });
		        term._query.push(new Term(this._r).expr(translateOptions(options))._query);
		    }

		    return term;

		    return new ISO8601(this._r, isoTime, options);
		}
		Term.prototype.inTimezone = function(timezone) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'inTimezone', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.IN_TIMEZONE)
		    var args = [this, new Term(this._r).expr(timezone)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.timezone = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'timezone', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.TIMEZONE)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.during = function(left, right, options) {
		    if (this._fastArityRange(arguments.length, 2, 3) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 2, 3, 'during', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.DURING);
		    var args = [];
		    args.push(this);
		    args.push(new Term(this._r).expr(left));
		    args.push(new Term(this._r).expr(right));

		    term._fillArgs(args);
		    if (helper.isPlainObject(options)) {
		        term._query.push(new Term(this._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}
		Term.prototype.date = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'date', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.DATE)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.timeOfDay = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'timeOfDay', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.TIME_OF_DAY)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.year = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'year', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.YEAR)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.month = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'month', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.MONTH)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.day = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'day', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.DAY)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.dayOfYear = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'dayOfYear', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.DAY_OF_YEAR)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.dayOfWeek = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'dayOfWeek', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.DAY_OF_WEEK)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.hours = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'hours', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.HOURS)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.minutes = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'minutes', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.MINUTES)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.seconds = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'seconds', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.SECONDS)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.toISO8601 = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'toISO8601', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.TO_ISO8601)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.toEpochTime = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'toEpochTime', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.TO_EPOCH_TIME)
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.monday = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.MONDAY);
		    return term;
		}
		Term.prototype.tuesday = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.TUESDAY);
		    return term;
		}
		Term.prototype.wednesday = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.WEDNESDAY);
		    return term;
		}
		Term.prototype.thursday = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.THURSDAY);
		    return term;
		}
		Term.prototype.friday = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.FRIDAY);
		    return term;
		}
		Term.prototype.saturday = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.SATURDAY);
		    return term;
		}
		Term.prototype.sunday = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.SUNDAY);
		    return term;
		}

		Term.prototype.january = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.JANUARY);
		    return term;
		}
		Term.prototype.february = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.FEBRUARY);
		    return term;
		}
		Term.prototype.march = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.MARCH);
		    return term;
		}
		Term.prototype.april = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.APRIL);
		    return term;
		}
		Term.prototype.may = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.MAY);
		    return term;
		}
		Term.prototype.june = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.JUNE);
		    return term;
		}
		Term.prototype.july = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.JULY);
		    return term;
		}
		Term.prototype.august = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.AUGUST);
		    return term;
		}
		Term.prototype.september = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.SEPTEMBER);
		    return term;
		}
		Term.prototype.october = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.OCTOBER);
		    return term;
		}
		Term.prototype.november = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.NOVEMBER);
		    return term;
		}
		Term.prototype.december = function() {
		    var term = new Term(this._r);
		    term._query.push(termTypes.DECEMBER);
		    return term;
		}


		Term.prototype.args = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._noPrefix(this, 'args');

		    var term = new Term(this._r);
		    term._query.push(termTypes.ARGS);
		    var args = [];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.do = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    this._arityRange(_args, 1, Infinity, 'do', this);

		    var term = new Term(this._r);
		    term._query.push(termTypes.FUNCALL);
		    var args = [new Term(this._r).expr(_args[_args.length-1])._wrap()._query];
		    args.push(this);
		    for(var i=0; i<_args.length-1; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}


		Term.prototype.branch = function(trueBranch, falseBranch) {
		    if (this._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 2, 3, 'branch', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.BRANCH)
		    var args = [];
		    args.push(this)
		    args.push(new Term(this._r).expr(trueBranch))
		    args.push(new Term(this._r).expr(falseBranch))
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.forEach = function(func) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'forEach', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.FOR_EACH);
		    var args = [this, new Term(this._r).expr(func)._wrap()];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.default = function(expression) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'default', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.DEFAULT);
		    var args = [this, new Term(this._r).expr(expression)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.expr = function(expression, nestingLevel) {
		    var self = this;
		    self._noPrefix(self, 'expr');
		    if (self._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 1, 2, 'expr', self);
		    }

		    // undefined will be caught in the last else
		    var ar, obj;

		    if (expression === undefined) {
		        var error = 'Cannot convert `undefined` with r.expr()';
		        return new Term(self._r, expression, error);
		    }

		    var _nestingLevel = nestingLevel;
		    if (_nestingLevel == null) {
		      _nestingLevel = self._r.nestingLevel;
		    }
		    //if (nestingLevel == null) nestingLevel = self._r.nestingLevel;
		    if (_nestingLevel < 0) throw new Error.ReqlDriverError('Nesting depth limit exceeded.\nYou probably have a circular reference somewhere')

		    if (expression instanceof Term) {
		        return expression;
		    }
		    else if (expression instanceof Function) {
		        return new Func(self._r, expression);
		    }
		    else if (expression instanceof Date) {
		        return new Term(self._r).ISO8601(expression.toISOString())
		    }
		    else if (Array.isArray(expression)) {
		        var term = new Term(self._r);
		        term._query.push(termTypes.MAKE_ARRAY);

		        var args = [];
		        for(var i=0; i<expression.length; i++) {
		            args.push(new Term(self._r).expr(expression[i], _nestingLevel-1))
		        }
		        term._fillArgs(args);
		        return term;
		    }
		    else if (expression instanceof Buffer) {
		        return self._r.binary(expression);
		    }
		    else if (helper.isPlainObject(expression)) {
		        var term = new Term(self._r);
		        var optArgs = {};
		        var foundError = false;
		        helper.loopKeys(expression, function(expression, key) {
		            if (expression[key] !== undefined) {
		                var optArg = new Term(self._r).expr(expression[key], _nestingLevel-1);
		                if (optArg instanceof Term && !foundError && optArg._error != null) {
		                    foundError = true;
		                    term._error = optArg._error;
		                    term._frames = [key].concat(optArg._frames);
		                }
		                optArgs[key] = optArg._query;
		            }
		        });
		        term._query = optArgs;
		        return term;
		    }
		    else { // Primitive
		        if (expression === null) {
		            return new Term(self._r, null, expression);
		        }
		        else if (typeof expression === 'string') {
		            return new Term(self._r, expression);
		        }
		        else if (typeof expression === 'number') {
		            if (expression !== expression) {
		                var error = 'Cannot convert `NaN` to JSON';
		                return new Term(self._r, expression, error);
		            }
		            else if (!isFinite(expression)) {
		                var error = 'Cannot convert `Infinity` to JSON';
		                return new Term(self._r, expression, error);
		            }
		            return new Term(self._r, expression);
		        }
		        else if (typeof expression === 'boolean') {
		            return new Term(self._r, expression);
		        }
		        else {
		            //TODO
		            self._error = new Error.ReqlDriverError('Cannot convert `'+expression+'` to datum.')
		        }
		    }
		    return self;
		}

		Term.prototype.binary = function(bin) {
		    this._noPrefix(this, 'binary');
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'binary', this);
		    }

		    var term;
		    if (bin instanceof Buffer) {
		        // We could use BINARY, and coerce `bin` to an ASCII string, but that
		        // will break if there is a null char
		        term = new Term(this._r, {
		            $reql_type$: 'BINARY',
		            data: bin.toString('base64')
		        });
		    }
		    else {
		        term = new Term(this._r);
		        term._query.push(termTypes.BINARY)
		        var args = [new Term(this._r).expr(bin)];
		        term._fillArgs(args);
		    }
		    return term;
		}

		Term.prototype.js = function(arg, options) {
		    this._noPrefix(this, 'js');
		    if (this._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 1, 2, 'js', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.JAVASCRIPT)
		    var args = [new Term(this._r).expr(arg)];
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        term._query.push(new Term(this._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}
		Term.prototype.coerceTo = function(type) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'coerceTo', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.COERCE_TO)
		    var args = [this, new Term(this._r).expr(type)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.typeOf = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'typeOf', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.TYPE_OF);
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.info = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'info', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.INFO);
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.json = function(json) {
		    this._noPrefix(this, 'json');
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'info', this);
		    }
		    /*
		    if ((/\\u0000/.test(json)) || (/\0/.test(json))) {
		        this._error = new Error.ReqlDriverError('The null character is currently not supported by RethinkDB');
		    }
		    */
		    var term = new Term(this._r);
		    term._query.push(termTypes.JSON);

		    var args = [new Term(this._r).expr(json)];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.http = function(url, options) {
		    this._noPrefix(this, 'http');
		    if (this._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 1, 2, 'http', this);
		    }

		    var term = new Term(this._r);
		    term._query.push(termTypes.HTTP);
		    var args = [new Term(this._r).expr(url)];
		    term._fillArgs(args);
		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'timeout')
		                && (key !==  'reattempts')
		                && (key !==  'redirects')
		                && (key !==  'verify')
		                && (key !==  'resultFormat')
		                && (key !==  'method')
		                && (key !==  'auth')
		                && (key !==  'params')
		                && (key !==  'header')
		                && (key !==  'data')
		                && (key !==  'page')
		                && (key !==  'pageLimit')
		                && (key !==  '')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `http`. Available options are reattemps <number>, redirects <number>, verify <boolean>, resultFormat: <string>, method: <string>, auth: <object>, params: <object>, header: <string>, data: <string>, page: <string/function>, pageLimit: <number>');
		            }
		        });

		        term._query.push(new Term(this._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}
		Term.prototype.uuid = function() {
		    this._noPrefix(this, 'uuid');

		    var term = new Term(this._r);
		    term._query.push(termTypes.UUID)
		    return term;
		}


		Term.prototype.circle = function(center, radius, options) {
		    var self = this;

		    // Arity check is done by r.circle
		    self._noPrefix(self, 'circle');
		    var term = new Term(self._r);
		    term._query.push(termTypes.CIRCLE);
		    var args = [new Term(self._r).expr(center), new Term(self._r).expr(radius)];
		    term._fillArgs(args);

		    if (helper.isPlainObject(options)) {
		        // There is no need to translate here
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'numVertices') && (key !== 'geoSystem') && (key !== 'unit') && (key !== 'fill')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `circle`', self._query, 'Available options are numVertices <number>, geoSsystem <string>, unit <string> and fill <bool>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }

		    return term;
		}
		Term.prototype.distance = function(geometry, options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 1, 2, 'distance', self);
		    }
		    var term = new Term(self._r);
		    term._query.push(termTypes.DISTANCE);
		    var args = [self, new Term(self._r).expr(geometry)];
		    term._fillArgs(args);
		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'geoSystem') && (key !== 'unit')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distance`', self._query, 'Available options are geoSystem <string>, unit <string>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}
		Term.prototype.fill = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'fill', this);
		    }
		    var term = new Term(this._r);
		    term._query.push(termTypes.FILL);
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}

		Term.prototype.geojson = function(geometry) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'geojson', this);
		    }
		    this._noPrefix(this, 'geojson');
		    var term = new Term(this._r);
		    term._query.push(termTypes.GEOJSON);
		    var args = [new Term(this._r).expr(geometry)];
		    term._fillArgs(args);
		    return term;
		}

		Term.prototype.toGeojson = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'toGeojson', this);
		    }
		    var term = new Term(this._r);
		    term._query.push(termTypes.TO_GEOJSON);
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}

		Term.prototype.getIntersecting = function(geometry, options) {
		    if (this._fastArity(arguments.length, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 2, 'getIntersecting', this);
		    }
		    var term = new Term(this._r);
		    term._query.push(termTypes.GET_INTERSECTING);
		    var args = [this, new Term(this._r).expr(geometry)];
		    term._fillArgs(args);
		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if (key !== 'index') {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distance`', self._query, 'Available options are index <string>');
		            }
		        });
		        term._query.push(new Term(this._r).expr(translateOptions(options))._query);
		    }
		    return term;
		}

		Term.prototype.getNearest = function(geometry, options) {
		    var self = this;
		    if (self._fastArity(arguments.length, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arity(_args, 2, 'getNearest', self);
		    }
		    var term = new Term(self._r);
		    term._query.push(termTypes.GET_NEAREST);
		    var args = [self, new Term(self._r).expr(geometry)];
		    term._fillArgs(args);
		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'index') && (key !== 'maxResults') && (key !== 'maxDist') && (key !== 'unit') && (key !== 'geoSystem')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `getNearest`', self._query, 'Available options are index <string>, maxResults <number>, maxDist <number>, unit <string>, geoSystem <string>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }
		    return term;

		}

		Term.prototype.includes = function(geometry) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'includes', this);
		    }
		    var term = new Term(this._r);
		    term._query.push(termTypes.INCLUDES);
		    var args = [this, new Term(this._r).expr(geometry)];
		    term._fillArgs(args);
		    return term;
		}

		Term.prototype.intersects = function(geometry) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'intersects', this);
		    }
		    var term = new Term(this._r);
		    term._query.push(termTypes.INTERSECTS);
		    var args = [this, new Term(this._r).expr(geometry)];
		    term._fillArgs(args);
		    return term;
		}

		Term.prototype.line = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    // Arity check is done by r.line
		    this._noPrefix(this, 'line');

		    var term = new Term(this._r);
		    term._query.push(termTypes.LINE);

		    var args = [];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);
		    return term;
		}

		Term.prototype.point = function(longitude, latitude) {
		    // Arity check is done by r.point
		    this._noPrefix(this, 'point');

		    var term = new Term(this._r);
		    term._query.push(termTypes.POINT);
		    var args = [new Term(this._r).expr(longitude), new Term(this._r).expr(latitude)];
		    term._fillArgs(args);
		    return term;
		}

		Term.prototype.polygon = function() {
		    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		    // Arity check is done by r.polygon
		    this._noPrefix(this, 'polygon');

		    var term = new Term(this._r);
		    term._query.push(termTypes.POLYGON);

		    var args = [];
		    for(var i=0; i<_args.length; i++) {
		        args.push(new Term(this._r).expr(_args[i]))
		    }
		    term._fillArgs(args);

		    return term;
		}

		Term.prototype.polygonSub = function(geometry) {
		    if (this._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 1, 'polygonSub', this);
		    }
		    var term = new Term(this._r);
		    term._query.push(termTypes.POLYGON_SUB);
		    var args = [this, new Term(this._r).expr(geometry)];
		    term._fillArgs(args);
		    return term;
		}

		Term.prototype.range = function(start, end) {
		    this._noPrefix(this, 'range');
		    if (this._fastArityRange(arguments.length, 1, 2) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arityRange(_args, 1, 2, 'r.range', this);
		    }
		    var term = new Term(this._r);
		    term._query.push(termTypes.RANGE);
		    var args = [];
		    args.push(new Term(this._r).expr(start));
		    if (end !== undefined) {
		      args.push(new Term(this._r).expr(end));
		    }
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.toJsonString = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'toJSON', this);
		    }
		    var term = new Term(this._r);
		    term._query.push(termTypes.TO_JSON_STRING);
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}
		Term.prototype.toJSON = Term.prototype.toJsonString;

		Term.prototype.config = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'config', this);
		    }
		    var term = new Term(this._r);
		    term._query.push(termTypes.CONFIG);
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}

		Term.prototype.status = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'status', this);
		    }
		    var term = new Term(this._r);
		    term._query.push(termTypes.STATUS);
		    var args = [this];
		    term._fillArgs(args);
		    return term;
		}

		Term.prototype.wait = function(options) {
		    var self = this;
		    if (self._fastArityRange(arguments.length, 0, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arityRange(_args, 0, 1, 'wait', self);
		    }
		    var term = new Term(self._r);
		    term._query.push(termTypes.WAIT);
		    if (Array.isArray(self._query) && (self._query.length > 0)) {
		        var args = [self];
		        term._fillArgs(args);
		    }
		    if (helper.isPlainObject(options)) {
		        helper.loopKeys(options, function(obj, key) {
		            if ((key !== 'waitFor') && (key !== 'timeout')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `reconfigure`', self._query, 'Available options are waitFor: <string>, timeout: <number>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(options))._query);
		    }

		    return term;
		}

		Term.prototype.reconfigure = function(config) {
		    var self = this;
		    if (self._fastArity(arguments.length, 1) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        self._arity(_args, 1, 'reconfigure', self);
		    }
		    var term = new Term(self._r);
		    term._query.push(termTypes.RECONFIGURE);

		    if (Array.isArray(this._query) && (this._query.length > 0)) {
		        var args = [this];
		        term._fillArgs(args);
		    }
		    else{
		        term._query.push([]);
		    }
		    if (helper.isPlainObject(config)) {
		        helper.loopKeys(config, function(obj, key) {
		            if ((key !== 'shards') && (key !== 'replicas') &&
		                    (key !== 'dryRun') && (key !== 'primaryReplicaTag')) {
		                throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `reconfigure`', self._query, 'Available options are shards: <number>, replicas: <number>, primaryReplicaTag: <object>, dryRun <boolean>');
		            }
		        });
		        term._query.push(new Term(self._r).expr(translateOptions(config))._query);
		    }
		    else {
		        throw new Error.ReqlDriverError('First argument of `reconfigure` must be an object');
		    }
		    return term;
		}

		Term.prototype.rebalance = function() {
		    if (this._fastArity(arguments.length, 0) === false) {
		        var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
		        this._arity(_args, 0, 'rebalance', this);
		    }
		    var term = new Term(this._r);
		    term._query.push(termTypes.REBALANCE);
		    if (Array.isArray(this._query) && (this._query.length > 0)) {
		        var args = [this];
		        term._fillArgs(args);
		    }
		    return term;
		}


		Term.prototype.then = function(resolve, reject) {
		    return this.run().then(resolve, reject);
		}
		Term.prototype.error = function(reject) {
		    return this.run().error(reject);
		}
		Term.prototype.catch = function(reject) {
		    return this.run().catch(reject);
		}
		Term.prototype.finally = function(handler) {
		    return this.run().finally(handler);
		}


		Term.prototype.toString = function() {
		    return Error.generateBacktrace(this._query, 0, null, [], {indent: 0, extra: 0}).str;
		}

		Term.prototype._wrap = function() {
		    var self = this;
		    if (helper.hasImplicit(this._query)) {
		        if (this._query[0] === termTypes.ARGS) {
		            throw new Error.ReqlDriverError('Implicit variable `r.row` cannot be used inside `r.args`')
		        }
		        //Must pass at least one variable to the function or it won't accept r.row
		        return new Term(this._r).expr(function(doc) { return self; })
		    }
		    else {
		        return self;
		    }
		}

		Term.prototype._fillArgs = function(args) {
		  var foundError = false;
		  var internalArgs = [];
		  for(var i=0; i<args.length; i++) {
		    if (args[i] instanceof Term) {
		      internalArgs.push(args[i]._query);
		      if (!foundError && (args[i]._error != null)) {
		        this._error = args[i]._error;
		        this._frames = args[i]._frames;
		        this._frames.unshift(i);
		        foundError = true;
		      }
		    }
		    else {
		      internalArgs.push(args[i]);
		    }
		  }
		  this._query.push(internalArgs);
		  return this;
		}

		Term.prototype._translateArgs = {
		    returnChanges: 'return_changes',
		    primaryKey: 'primary_key',
		    readMode: 'read_mode',
		    nonAtomic: 'non_atomic',
		    leftBound: 'left_bound',
		    rightBound: 'right_bound',
		    defaultTimezone: 'default_timezone',
		    noReply: 'noreply',
		    resultFormat: 'result_format',
		    pageLimit: 'page_limit',
		    arrayLimit: 'array_limit',
		    numVertices: 'num_vertices',
		    geoSystem: 'geo_system',
		    maxResults: 'max_results',
		    maxDist: 'max_dist',
		    dryRun: 'dry_run',
		    waitFor: 'wait_for',
		    includeStates: 'include_states',
		    primaryReplicaTag: 'primary_replica_tag'
		}
		function translateOptions(options) {
		    var translatedOpt = {};
		    helper.loopKeys(options, function(options, key) {
		        var keyServer = Term.prototype._translateArgs[key] || key;
		        translatedOpt[keyServer] = options[key];
		    });
		    return translatedOpt;
		}
		Term.prototype._setNestingLevel = function(nestingLevel) {
		    Term.prototype._nestingLevel = nestingLevel;
		}
		Term.prototype._setArrayLimit = function(arrayLimit) {
		    Term.prototype._arrayLimit = arrayLimit;
		}


		Term.prototype._noPrefix = function(term, method) {
		    if ((!Array.isArray(term._query)) || (term._query.length > 0)) {
		        throw new Error.ReqlDriverError('`'+method+'` is not defined', term._query);
		    }
		}
		Term.prototype._arityRange = function(args, min, max, method, term) {
		    var foundArgs = false;
		    if (args.length < min) {
		        for(var i=0; i<args.length; i++) {
		            if ((args[i] instanceof Term) && (args[i]._query[0] === termTypes.ARGS)) {
		                foundArgs = true;
		                break;
		            }
		        }
		        if (foundArgs === false) {
		            throw new Error.ReqlDriverError('`'+method+'` takes at least '+min+' argument'+((min>1)?'s':'')+', '+args.length+' provided', term._query);
		        }
		    }
		    else if (args.length > max) {
		        for(var i=0; i<args.length; i++) {
		            if ((args[i] instanceof Term) && (args[i]._query[0] === termTypes.ARGS)) {
		                foundArgs = true;
		                break;
		            }
		        }
		        if (foundArgs === false) {
		            throw new Error.ReqlDriverError('`'+method+'` takes at most '+max+' argument'+((max>1)?'s':'')+', '+args.length+' provided', term._query);
		        }
		    }
		}
		Term.prototype._arity = function(args, num, method, term) {
		    var foundArgs = false;
		    for(var i=0; i<args.length; i++) {
		        if ((args[i] instanceof Term) && (args[i]._query[0] === termTypes.ARGS)) {
		            foundArgs = true;
		            break;
		        }
		    }
		    if (foundArgs === false) {
		        throw new Error.ReqlDriverError('`'+method+'` takes '+num+' argument'+((num>1)?'s':'')+', '+args.length+' provided', term._query);
		    }
		}
		// Cheap arity check. If it fails, return false, and then we are expected to call _arity/_arityRange
		Term.prototype._fastArity = function(len, num) {
		    return (len === num);
		}
		Term.prototype._fastArityRange = function(len, min, max) {
		    return ((len >= min) && (len <= max));
		}


		// Datums
		function Func(r, func) {
		    // We can retrieve the names of the arguments with
		    // func.toString().match(/\(([^\)]*)\)/)[1].split(/\s*,\s*/)

		    var term = new Term(r);
		    term._query.push(termTypes.FUNC);
		    var args = [];
		    var argVars = [];
		    var argNums = [];

		    for(var i=0; i<func.length; i++) {
		        argVars.push(new Var(r, r.nextVarId));
		        argNums.push(r.nextVarId);

		        if (r.nextVarId === 9007199254740992) { // That seems like overdoing it... but well maybe...
		            r.nextVarId = 0;
		        }
		        else {
		            r.nextVarId++;
		        }
		    }

		    var body = func.apply(func, argVars)
		    if (body === undefined) throw new Error.ReqlDriverError('Annonymous function returned `undefined`. Did you forget a `return`? In:\n'+func.toString(), this._query);
		    body = new Term(r).expr(body);
		    args.push(new Term(r).expr(argNums));
		    args.push(body);

		    term._fillArgs(args);

		    return term;
		}
		Func.prototype.nextVarId = 1;

		function Var(r, id) {
		    var term = new Term(r);
		    term._query.push(termTypes.VAR)
		    term._query.push([new Term(r).expr(id)._query])
		    return term;
		}

		module.exports = Term;


	/***/ },
	/* 58 */
	/***/ function(module, exports, __webpack_require__) {

		var Writable = __webpack_require__(55).Writable;
		var Cursor = __webpack_require__(53);
		var util = __webpack_require__(51);

		// Experimental, but should work fine.
		function WritableStream(table, options, connection) {
		  this._table = table;
		  this._options = options;
		  this._cache = [];
		  this._pendingCallback = null;
		  this._inserting = false;
		  this._delayed = false;
		  this._connection = connection;
		  this._highWaterMark = options.highWaterMark || 100;

		  this._insertOptions = {};
		  this._insertOptions.durability = options.durability || 'hard';
		  this._insertOptions.conflict = options.conflict || 'error';

		  // Internal option to run some tests
		  if (options.debug === true) {
		    this._sequence = [];
		  }

		  Writable.call(this, {
		    objectMode: true,
		    highWaterMark: this._highWaterMark
		  });
		  this._i = 0;
		};
		util.inherits(WritableStream, Writable);

		WritableStream.prototype._write = function(value, encoding, done) {
		  this._i++;
		  this._cache.push(value);
		  this._next(value, encoding, done);
		}

		// Everytime we want to insert but do not have a full buffer,
		// we recurse with setImmediate to give a chance to the input
		// stream to push a few more elements
		WritableStream.prototype._next = function(value, encoding, done) {
		  if ((this._writableState.lastBufferedRequest != null) && (this._writableState.lastBufferedRequest.chunk !== value)) {
		    // There's more data to buffer
		    if (this._cache.length < this._highWaterMark) {
		      this._delayed = false;
		      // Call done now, and more data will be put in the cache
		      done();
		    }
		    else {
		      if (this._inserting === false) {
		        if (this._delayed === true) {
		          this._delayed = false;
		          // We have to flush
		          this._insert();
		          // Fill the buffer while we are inserting data
		          done();
		        }
		        else {
		          var self = this;
		          this._delayed = true;
		          setImmediate(function() {
		            self._next(value, encoding, done);
		          })
		        }

		      }
		      else {
		        this._delayed = false;
		        // to call when we are dong inserting to keep buffering
		        this._pendingCallback = done;
		      }
		    }
		  }
		  else { // We just pushed the last element in the internal buffer
		    if (this._inserting === false) {
		      if (this._delayed === true) {
		        this._delayed = false;
		        // to call when we are dong inserting to maybe flag the end
		        // We cannot call done here as we may be inserting the last batch
		        this._pendingCallback = done;
		        this._insert();
		      }
		      else {
		        var self = this;
		        this._delayed = true;
		        setImmediate(function() {
		          self._next(value, encoding, done);
		        })
		      }
		    }
		    else {
		      this._delayed = false;
		      // We cannot call done here as we may be inserting the last batch
		      this._pendingCallback = done;
		    }
		  }
		}

		WritableStream.prototype._insert = function() {
		  var self = this;
		  self._inserting = true;

		  var cache = self._cache;
		  self._cache = [];

		  if (Array.isArray(self._sequence)) {
		    self._sequence.push(cache.length);
		  }

		  self._table.insert(cache, self._insertOptions).run(self._connection).then(function(result) {
		    self._inserting = false;
		    if (result.errors > 0) {
		      self._inserting = false;
		      self.emit('error', new Error('Failed to insert some documents:'+JSON.stringify(result, null, 2)));
		    }
		    if (typeof self._pendingCallback === 'function') {
		      var pendingCallback = self._pendingCallback;
		      self._pendingCallback = null;
		      pendingCallback();
		    }

		  }).error(function(error) {
		    self._inserting = false;
		    self.emit('error', error);
		  });
		}


		module.exports = WritableStream;


	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {

		var Transform = __webpack_require__(55).Transform;
		var Cursor = __webpack_require__(53);
		var util = __webpack_require__(51);

		// Experimental, but should work fine.
		function TransformStream(table, options, connection) {
		  this._table = table;
		  this._r = table._r;
		  this._options = options;
		  this._cache = [];
		  this._pendingCallback = null;
		  this._ended = false;
		  this._inserting = false;
		  this._delayed = false;
		  this._connection = connection;
		  this._highWaterMark = options.highWaterMark || 100;
		  this._insertOptions = {};
		  this._insertOptions.durability = options.durability || 'hard';
		  this._insertOptions.conflict = options.conflict || 'error';
		  this._insertOptions.returnChanges = options.returnChanges || true;

		  // Internal option to run some tests
		  if (options.debug === true) {
		    this._sequence = [];
		  }

		  Transform.call(this, {
		    objectMode: true,
		    highWaterMark: this._highWaterMark
		  });
		};
		util.inherits(TransformStream, Transform);

		TransformStream.prototype._transform = function(value, encoding, done) {
		  this._cache.push(value);
		  this._next(value, encoding, done);
		}

		// Everytime we want to insert but do not have a full buffer,
		// we recurse with setImmediate to give a chance to the input
		// stream to push a few more elements
		TransformStream.prototype._next = function(value, encoding, done) {
		  if ((this._writableState.lastBufferedRequest != null) && (this._writableState.lastBufferedRequest.chunk !== value)) {
		    // There's more data to buffer
		    if (this._cache.length < this._highWaterMark) {
		      this._delayed = false;
		      // Call done now, and more data will be put in the cache
		      done();
		    }
		    else {
		      if (this._inserting === false) {
		        if (this._delayed === true) {
		          // We have to flush
		          this._delayed = false;
		          this._insert();
		          // Fill the buffer while we are inserting data
		          done();
		        }
		        else {
		          var self = this;
		          this._delayed = true;
		          setImmediate(function() {
		            self._next(value, encoding, done);
		          })
		        }

		      }
		      else {
		        // to call when we are dong inserting to keep buffering
		        this._pendingCallback = done;
		      }
		    }
		  }
		  else { // We just pushed the last element in the internal buffer
		    if (this._inserting === false) {
		      if (this._delayed === true) {
		        this._delayed = false;
		        // to call when we are dong inserting to maybe flag the end
		        this._insert();
		        // We can call done now, because we have _flush to close the stream
		        done();
		      }
		      else {
		        var self = this;
		        this._delayed = true;
		        setImmediate(function() {
		          self._next(value, encoding, done);
		        })
		      }
		    }
		    else {
		      this._delayed = false;
		      // There is nothing left in the internal buffer
		      // But something is already inserting stuff.
		      if (this._cache.length < this._highWaterMark-1) {
		        // Call done, to attempt to buffer more
		        // This may trigger _flush
		        //this._pendingCallback = done;
		        done();
		      }
		      else {
		        this._pendingCallback = done;
		      }
		    }
		  }
		}

		TransformStream.prototype._insert = function() {
		  var self = this;
		  self._inserting = true;

		  var cache = self._cache;
		  self._cache = [];

		  if (Array.isArray(self._sequence)) {
		    self._sequence.push(cache.length);
		  }

		  var pendingCallback = self._pendingCallback;
		  self._pendingCallback = null;
		  if (typeof pendingCallback === 'function') {
		    pendingCallback();
		  }

		  var query = self._table.insert(cache, self._insertOptions);
		  if (self._options.format === 'primaryKey') {
		    query = query.do(function(result) {
		      return self._r.branch(
		        result('errors').eq(0),
		        self._table.config()('primary_key').do(function(primaryKey) {
		          return result('changes')('new_val')(primaryKey)
		        }),
		        result(self._r.error(result('errors').coerceTo('STRING').add(' errors returned. First error:\n').add(result('first_error'))))
		      )
		    })
		  }

		  query.run(self._connection).then(function(result) {
		    self._inserting = false;
		    if (self._options.format === 'primaryKey') {
		      for(var i=0; i<result.length; i++) {
		        self.push(result[i]);
		      }
		    }
		    else {
		      if (result.errors > 0) {
		        self._inserting = false;
		        self.emit('error', new Error('Failed to insert some documents:'+JSON.stringify(result, null, 2)));
		      }
		      else {
		        if (self._insertOptions.returnChanges === true) {
		          for(var i=0; i<result.changes.length; i++) {
		            self.push(result.changes[i].new_val);
		          }
		        }
		      }
		    }

		    pendingCallback = self._pendingCallback
		    self._pendingCallback = null;
		    if (typeof pendingCallback === 'function') {
		      // Mean that we can buffer more
		      pendingCallback();
		    }
		    else if (self._ended !== true) {
		      if (((((self._writableState.lastBufferedRequest === null) ||
		          self._writableState.lastBufferedRequest.chunk === self._cache[self._cache.length-1])))
		        && (self._cache.length > 0)) {
		          self._insert();
		      }
		    }
		    else if (self._ended === true) {
		      if (self._cache.length > 0) {
		        self._insert();
		      }
		      else {
		        if (typeof self._flushCallback === 'function') {
		          self._flushCallback();
		        }
		        self.push(null);
		      }
		    }
		  }).error(function(error) {
		    self._inserting = false;
		    self.emit('error', error);
		  });
		}

		TransformStream.prototype._flush = function(done) {
		  this._ended = true;
		  if ((this._cache.length === 0) && (this._inserting === false)) {
		    done();
		  }
		  else { // this._inserting === true
		    if (this._inserting === false) {
		      this._flushCallback = done;
		      this._insert();
		    }
		    else {
		      this._flushCallback = done;
		    }
		  }
		}


		module.exports = TransformStream;


	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {

		var util = __webpack_require__(51);
		var events = __webpack_require__(50);
		var Promise = __webpack_require__(3);
		var Dequeue = __webpack_require__(61);
		var Pool = __webpack_require__(62);
		var helper = __webpack_require__(41);
		var Err = __webpack_require__(52);
		var UNKNOWN_POOLS = 'unknownPools';
		var SEPARATOR = 'feedSeparator';
		function PoolMaster(r, options) {
		  var self = this;
		  var options = options || {};
		  var lineLength = options.buffer || 50;

		  self._r = r;
		  self._line = new Dequeue(lineLength);
		  self._pools = {};
		  self._pools[UNKNOWN_POOLS] = []; // pools for which we do not know the server'id
		  self._healthyPools = [];
		  self._healthy = false;
		  self._init = false;
		  self._index = 0; // next pool to used
		  self._indexUnknown =  0 // next unknown pool to used
		  self._discovery = (typeof options.discovery === 'boolean') ? options.discovery: false; // Whether the pool master is in discovery mode or not
		  //self._refresh = (typeof options.refresh === 'number') ? options.refresh: 1000*60*60; // Refresh rate for the list of servers
		  self._options = options;
		  self._options.buffer = options.buffer || 50;
		  self._options.max = options.max || 1000;
		  self._log = helper.createLogger(self, options.silent || false);
		  self._draining = false;
		  self._numConnections = 0;
		  self._numAvailableConnections = 0;
		  self._hasPrintWarningLocalhost = false;
		  self._feed = null;
		  self._consecutiveFails = -1;
		  self._timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?
		  self._maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError

		  //TODO
		  //self._usingPool = true; // If we have used the pool
		  self._seed = 0;

		  var pool;
		  if (Array.isArray(options.servers) && options.servers.length > 0) {
		    self._servers = options.servers;
		    for(var i=0; i<options.servers.length; i++) {
		      var settings = self.createPoolSettings(options, options.servers[i], self._log);
		      pool = new Pool(self._r, settings);
		      self._pools[UNKNOWN_POOLS].push(pool);
		      // A pool is considered healthy by default such that people can do
		      // var = require(...)(); query.run();
		      self._healthyPools.push(pool);
		      self.emitStatus()
		    }
		  }
		  else {
		    self._servers = [{
		      host: options.host || 'localhost',
		      port: options.port || 28015
		    }]
		    var settings = self.createPoolSettings(options, {}, self._log);
		    pool = new Pool(self._r, settings);
		    self._pools[UNKNOWN_POOLS].push(pool);
		    self._healthyPools.push(pool);
		    self.emitStatus()
		  }

		  // Initialize all the pools - bind listeners
		  for(var i=0; i<self._pools[UNKNOWN_POOLS].length; i++) {
		    self.initPool(self._pools[UNKNOWN_POOLS][i]);
		  }
		  if ((self._discovery === true)) {
		    self._timeout = setTimeout(function() { self.fetchServers() }, 0);
		  }
		}
		util.inherits(PoolMaster, events.EventEmitter);

		PoolMaster.prototype.getPools = function() {
		  var result = [];
		  helper.loopKeys(this._pools, function(pools, key) {
		    if (key === UNKNOWN_POOLS) {
		      for(var i=0;i<pools[key].length; i++) {
		        result.push(pools[key][i]);
		      }
		    }
		    else {
		      result.push(pools[key]);
		    }
		  });
		  return result;
		}

		// Reject all promises in this._line
		PoolMaster.prototype._flushErrors = function() {
		  while(this._line.getLength() > 0) {
		    this._line.shift().reject(new Err.ReqlDriverError('None of the pools have an opened connection and failed to open a new one'));
		    this.emit('queueing', this._line.getLength())
		  }
		}

		PoolMaster.prototype.getConnection = function() {
		  var self = this;
		  // Find a pool with available connections
		  var result;
		  for(var i=0; i<self._healthyPools.length; i++) {
		    if (self._index >= self._healthyPools.length) {
		      self._index = 0;
		    }
		    if (self._healthyPools[self._index].getAvailableLength() > 0) {
		      result = self._healthyPools[self._index].getConnection();
		    }
		    self._index++;
		    if (self._index === self._healthyPools.length) {
		      self._index = 0;
		    }
		    if (result) {
		      return result;
		    }
		  }
		  if (self._healthyPools.length === 0) {
		    return new Promise(function(resolve, reject) {
		      reject(new Err.ReqlDriverError('None of the pools have an opened connection and failed to open a new one'));
		    });
		  }
		  else {
		    // All pool are busy, buffer the request
		    return new Promise(function(resolve, reject) {
		      self._line.push({
		        resolve: resolve,
		        reject: reject
		      });

		      self.emit('queueing', self._line.getLength())
		      // We could add a condition to be less greedy (for early start)
		      self._expandAll();
		    });

		  }
		}
		PoolMaster.prototype._expandAll = function() {
		  for(var i=0; i<this._healthyPools.length; i++) {
		    this._healthyPools[i]._expandBuffer();
		  }
		}

		// Fetch all the servers once
		PoolMaster.prototype.handleAllServersResponse = function(servers) {
		  var self = this;
		  // Fill all the known server from RethinkDB
		  var knownServer = {};
		  for(var i=0; i<servers.length; i++) {
		    var server = servers[i];
		    knownServer[server.id] = {count: 0, server: server};
		    if (self._pools[server.id] === undefined) {
		      // We potentially have a new server in the cluster, or we already have a pool for this server
		      // in one of the UNKNOWN_POOLS
		      var found = false;
		      for(var j=0; j<self._pools[UNKNOWN_POOLS].length; j++) {
		        if (found) break;
		        var pool = self._pools[UNKNOWN_POOLS][j];
		        // If a pool is created with localhost, it will probably match the first server even though it may not the the one
		        // So it gets an id
		        for(var k=0; k<server.network.canonical_addresses.length; k++) {
		          // Check for the same host (or if they are both localhost) and port
		          if (((server.network.canonical_addresses[k].host === pool.options.connection.host) ||
		               (server.network.hostname === pool.options.connection.host) ||
		            (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) &&
		            helper.localhostAliases.hasOwnProperty(pool.options.connection.host))) &&
		            (server.network.reql_port === pool.options.connection.port)) {

		            self._pools[server.id] = self._pools[UNKNOWN_POOLS].splice(j, 1)[0];
		            // We may assign the wrong pool to this server if it's maching on localhost
		            if (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host)) {
		              self._pools[server.id].options.connection.host = helper.getCanonicalAddress(server.network.canonical_addresses).host;
		              if (!helper.getCanonicalAddress(self._pools[server.id].options.connection.host)) {
		                self._pools[server.id].drainLocalhost();
		              }
		            }
		            found = true;
		            break;
		          }
		        }
		      }
		      if (found === false) {
		        // We just found a new server, let's extract the canonical address and connect to it
		        self.createPool(server);
		      }
		    }
		  } // Each server know has a pool

		  // Check if we need to remove pools
		  helper.loopKeys(self._pools, function(pools, key) { // among the pools with a server id
		    if (key !== UNKNOWN_POOLS) {
		      if (knownServer.hasOwnProperty(key) === false) {
		        self.deletePool(key); // We just found a pool that doesn't map to any known RethinkDB server
		      }
		      else {
		        knownServer[key].count++;
		      }
		    }
		  });
		  for(var i=0;i<self._pools[UNKNOWN_POOLS].length; i++) {
		    // These pools does not match any server returned by RethinkDB.
		    var pool = self._pools[UNKNOWN_POOLS].splice(i, 1)[0];
		    self._log('Removing pool connected to: '+pool.getAddress())
		    pool.drain().then(function() {
		      pool.removeAllListeners();
		    }).error(function(error) {
		      self._log('Pool connected to: '+self._pools[UNKNOWN_POOLS][i].getAddress()+' could not be properly drained.')
		      self._log(error.message);
		      self._log(error.stack);
		    });
		  }
		}

		// Create the settings for a given pool. Merge the global options + the servers's one.
		PoolMaster.prototype.createPoolSettings = function(globalOptions, serverOptions, log) {
		  var settings = {};
		  var numServers = Array.isArray(globalOptions.servers) ? globalOptions.servers.length: 1;
		  helper.loopKeys(globalOptions, function(options, key) {
		    if ((key === 'buffer') || (key === 'max')) {
		      settings[key] = Math.ceil(options[key]/numServers);
		      settings[key] = Math.ceil(options[key]/numServers);
		    }
		    else if (key !== 'servers') {
		      settings[key] = options[key];
		    }
		  });
		  if (serverOptions) {
		    helper.loopKeys(serverOptions, function(options, key) {
		      settings[key] = options[key];
		    });
		  }
		  settings._log = log;
		  return settings;
		}

		// Create a new pool
		PoolMaster.prototype.createPool = function(server) {
		  var self = this;
		  var address = helper.getCanonicalAddress(server.network.canonical_addresses);
		  var settings = self.createPoolSettings(self._options, {
		    port: server.network.reql_port,
		    host: address.host
		  }, self._log);
		  var pool = new Pool(self._r, settings);
		  self._pools[server.id] = pool
		  self.initPool(pool);
		  self._healthyPools.push(pool);
		  self.emitStatus()
		  self.resetBufferParameters();
		}

		// Delete a known pool
		PoolMaster.prototype.deletePool = function(key) {
		  var self = this;
		  var pool = self._pools[key];
		  self._log('Removing pool connected to: '+pool.getAddress())
		  pool.drain().then(function() {
		    pool.removeAllListeners();
		  }).error(function(error) {
		    self._log('Pool connected to: '+self._pools[key].getAddress()+' could not be properly drained.')
		    self._log(error.message);
		    self._log(error.stack);
		  });
		  delete self._pools[key];
		  self.resetBufferParameters();
		}

		//  Create the feed on server_status and bind the listener to the feed
		PoolMaster.prototype.fetchServers = function(useSeeds) {
		  var self = this;
		  var query = self._r.db('rethinkdb').table('server_status')
		      .union([SEPARATOR])
		      .union(self._r.db('rethinkdb').table('server_status').changes())
		  // In case useSeeds is true, we rotate through all the seeds + the pool master
		  if (!useSeeds || self._seed === self._servers.length) {
		    if (useSeeds && self._seed === self._servers.length) {
		      // We increase the back off only when we went through all the seeds
		      self._consecutiveFails++;
		    }

		    self._seed = 0;
		    var promise = query.run({cursor: true})
		  }
		  else {
		    var settings = self._servers[self._seed];
		    self._seed++;
		    var promise = self._r.connect(settings).then(function(connection) {
		      return query.run(connection, {cursor: true})
		    });
		  }
		  promise.then(function(feed) {
		    self._feed = feed;
		    var initializing = true;
		    var servers = [];
		    feed.each(function(err, change) {
		      if (err) {
		        self._log('The changefeed on server_status returned an error: '+err.toString());
		        // We have to refetch everything as the server that was serving the feed may
		        // have died.
		        if (!self._draining) {
		          setTimeout(function() {
		            self.fetchServers();
		          }, 0); // Give a timeout to let the driver clean the pools
		        }
		        return;
		      }
		      if (initializing === true) {
		        if (change === SEPARATOR) {
		          initializing = false;
		          self.handleAllServersResponse(servers);
		          // Rerun the whole query after to make sure that a change did not skip/sneak between the union. As long
		          // as RethinkDB does not provide initial results
		          setTimeout(function() {
		            self._r.db('rethinkdb').table('server_status').run({cursor: false}).then(function(servers) {
		              self.handleAllServersResponse(servers);
		            }).error(function(error) {
		              self._log('Fail to retrieve a second copy of server_status');
		              //TODO Retry
		            });
		          }, 1000);
		        }
		        else {
		          servers.push(change);
		        }
		        return;
		      }

		      if (change.new_val !== null && change.old_val === null) {
		        // New server
		        self.createPool(change.new_val);
		      }
		      else if (change.new_val === null && change.old_val !== null) {
		        // A server was removed
		        var server = change.old_val;
		        if (self._pools[server.id] != null) {
		          self.deletePool(server.id);
		        }
		        else {
		          var found = false;
		          for(var i=0; i<self._pools[UNKNOWN_POOLS].length; i++) {
		            if (((server.network.canonical_addresses[k].host === self._pools[UNKNOWN_POOLS][i].options.connection.host) ||
		              (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) && (helper.localhostAliases.hasOwnProperty(self._pools[UNKNOWN_POOLS][i].options.connection.host)))) &&
		              (server.network.reql_port === self._pools[UNKNOWN_POOLS][i].options.connection.port)) {
		              found = true;

		              (function (pool) {
		                self._log('Removing pool connected to: '+pool.getAddress())
		                var pool = self._pools[UNKNOWN_POOLS].splice(i, 1)[0];
		                pool.drain().then(function() {
		                  pool.removeAllListeners();
		                }).error(function(error) {
		                  if (self._options.silent !== true) {
		                    self._log('Pool connected to: '+pool.getAddress()+' could not be properly drained.')
		                    self._log(error.message);
		                    self._log(error.stack);
		                  }
		                });
		              })(self._pools[UNKNOWN_POOLS][i]);
		              break;
		            }
		          }
		        }
		        if (found === false) {
		          self._log('A server was removed but no pool for this server exists...')
		        }
		      }
		      // We ignore this change since this it doesn't affect whether the server
		      // is available or not.
		      // else if (change.new_val !== null && change.old_val !== null) {}
		    });
		  }).error(function(error) {
		    self._log('Could not retrieve the data from server_status: '+JSON.stringify(error));

		    var timeout;
		    if (self._consecutiveFails === -1) {
		      timeout = 0;
		    }
		    else {
		      timeout = (1<<Math.min(self._maxExponent, self._consecutiveFails))*self._timeoutError;
		    }
		    setTimeout(function() {
		      self.fetchServers(true);
		    }, timeout);
		  });
		}

		// Bind listeners on the pools
		PoolMaster.prototype.initPool = function(pool) {
		  var self = this;

		  pool.on('size-diff', function(diff) {
		    self._numConnections += diff;
		    self.emit('size', self._numConnections)
		  });
		  pool.on('available-size-diff', function(diff) {
		    self._numAvailableConnections += diff;
		    self.emit('available-size', self._numAvailableConnections)
		  });

		  pool.on('new-connection', function() {
		    if (self._line.getLength() > 0) {
		      var p = self._line.shift();
		      this.getConnection().then(p.resolve).error(p.reject);
		      self.emit('queueing', self._line.getLength())
		    }
		  });
		  pool.on('not-empty', function() {
		    if (self._draining === false) {
		      var found = false;
		      for(var i=0; i<self._healthyPools.length; i++) {
		        if (self._healthyPools[i] === this) {
		          self._healthyPools.length;
		          found = true;
		          break;
		        }
		      }
		      if (found === false) {
		        self._healthyPools.push(this);
		        self.emitStatus()
		        self.resetBufferParameters();
		      }
		    }
		  });
		  pool.on('empty', function() {
		    // A pool that become empty is considered unhealthy
		    for(var i=0; i<self._healthyPools.length; i++) {
		      if (self._healthyPools[i] === this) {
		        self._healthyPools.splice(i, 1);
		        self.emitStatus()
		        break;
		      }
		    }
		    if (self._healthyPools.length === 0) {
		      self._flushErrors();
		    }

		    self.resetBufferParameters();
		  });
		  pool.on('draining', function() {
		    for(var i=0; i<self._healthyPools.length; i++) {
		      if (self._healthyPools[i] === this) {
		        self._healthyPools.splice(i, 1);
		        self.emitStatus()
		        break;
		      }
		    }

		    if (self._healthyPools === 0) {
		      self._flushErrors();
		    }
		  });
		}

		PoolMaster.prototype.getNumConnections = function() {
		  var sum = 0;
		  for(var i=0; i<this._healthyPools.length; i++) {
		    sum += this._healthyPools[i].getLength();
		  }
		  return sum;
		}
		PoolMaster.prototype.getNumAvailableConnections = function() {
		  var sum = 0;
		  for(var i=0; i<this._healthyPools.length; i++) {
		    sum += this._healthyPools[i].getAvailableLength();
		  }
		  return sum;
		}

		// Reset buffer and max for each pool
		PoolMaster.prototype.resetBufferParameters = function() {
		  var max = Math.floor(this._options.max/this._healthyPools.length)
		  var buffer = Math.floor(this._options.buffer/this._healthyPools.length)
		  for(var i=0; i<this._healthyPools.length; i++) {
		    if (this._healthyPools[i].getLength() > max) {
		      this._healthyPools[i]._extraConnections = this._healthyPools[i].getLength()-max;
		    }
		    else {
		      this._healthyPools[i]._extraConnections = 0;
		    }
		    this._healthyPools[i].options.max = max
		    this._healthyPools[i].options.buffer = buffer;
		  }
		}

		PoolMaster.prototype.getLength = function() {
		  return this._numConnections;
		}
		PoolMaster.prototype.getAvailableLength = function() {
		  return this._numAvailableConnections;
		}

		PoolMaster.prototype.drain = function() {
		  this.emit('draining');
		  if (this._discovery === true) {
		    this._discovery = false;
		    this._feed.close();
		  }
		  this._draining = true;
		  var promises = [];
		  var pools = this.getPools();
		  for(var i=0; i<pools.length; i++) {
		    promises.push(pools[i].drain());
		  }
		  this._healthyPools = [];
		  var self = this;
		  return Promise.all(promises).then(function() {
		    for(var i=0; i<pools.length; i++) {
		      pools[i].removeAllListeners();
		    }
		  }).error(function(error) {
		    if (self._options.silent !== true) {
		      self._log('Failed to drain all the pools:');
		      self._log(error.message);
		      self._log(error.stack);
		    }
		  });
		}

		// Emit the healthy event with a boolean indicating whether the pool master
		// is healthy or not
		PoolMaster.prototype.emitStatus = function() {
		  var healthy = this._healthyPools.length !== 0;
		  if (this._healthy !== healthy) {
		    this._healthy = healthy;
		    this.emit('healthy', healthy)
		  }
		}

		module.exports = PoolMaster;


	/***/ },
	/* 61 */
	/***/ function(module, exports) {

		// Implement a dequeue with a circular buffer
		// The buffer can expand but currently doesn't automatically shrink
		// as it is not a desired behavior. We may want to explicitly resize it though.
		function Dequeue(size) {
		  this.start = 0;
		  this.end = 0;

		  size = size || 50;
		  this.buffer = new Array(size);
		}
		Dequeue.prototype.get = function(index) {
		  if (this.start+index > this.buffer.length) {
		    return this.buffer[this.start+index-this.buffer.length]
		  }
		  else {
		    return this.buffer[this.start+index]
		  }
		}

		Dequeue.prototype.toArray = function(index) {
		  var result = [];
		  for(var i=0; i<this.getLength(); i++) {
		    result.push(this.get(i));
		  }
		  return result;
		}

		Dequeue.prototype.delete = function(index) {
		  var current, next;
		  if (this.start+index >= this.buffer.length) {
		    current = this.start+index-this.buffer.length;
		    next = this.start+index-this.buffer.length+1;
		  }
		  else {
		    current = this.start+index;
		    next = this.start+index+1;
		  }

		  for(var i=index; i<(this.buffer.length-index); i++) {
		    if (next === this.buffer.length) next = 0;
		    if (current === this.buffer.length) current = 0;

		    this.buffer[current] = this.buffer[next];
		    current++;
		    next++;
		  }

		  this.end--;
		  if (this.end < 0) this.end = this.buffer.length-1
		}

		Dequeue.prototype.push = function(element) {
		  // push on this.end and then increase this.end
		  // this.end should NEVER be equal to this.buffer.length
		  this.buffer[this.end] = element;
		  this.end++;
		  if (this.end === this.buffer.length) this.end = 0;

		  if (this.start === this.end) {
		    // Resize
		    var previousBuffer = this.buffer;

		    this.buffer = new Array(previousBuffer.length*2);

		    var i, k = 0;
		    for(i=this.start; i<previousBuffer.length; i++) {
		      this.buffer[k++] = previousBuffer[i];
		    }
		    for(i=0; i<this.start; i++) {
		      this.buffer[k++] = previousBuffer[i];
		    }
		    this.start = 0;
		    this.end = previousBuffer.length;
		  }
		}

		Dequeue.prototype.pop = function(element) {
		  //TODO: Decrease size when possible/needed? This may not be
		  //something we really need/want
		  // Return the element in this.end-1
		  if (this.getLength() > 0) {
		    var pos = this.end-1;
		    if (pos < 0) pos = this.buffer.length-1;
		    this.end = pos;
		    return this.buffer[pos];
		  }
		  else {
		    return undefined
		  }
		  var pos = this.end-1;
		  if (pos < 0) pos = this.buffer.length-1;

		  if (this.end !== this.start) {
		    this.end = pos;
		    return this.buffer[pos];
		  }
		  else {
		    return undefined
		  }
		}

		Dequeue.prototype.unshift = function(element) {
		  // push on this.start-1 and then decrease this.start.
		  // this.end should NEVER be equal to this.buffer.length

		  var pos = this.start-1;
		  if (pos < 0) pos = this.buffer.length-1;

		  this.buffer[pos] = element;
		  this.start = pos;

		  if (this.start === this.end) {
		    //Resize
		    var previousBuffer = this.buffer;

		    this.buffer = new Array(previousBuffer.length*2);

		    var i, k = 0;
		    for(i=this.start; i<previousBuffer.length; i++) {
		      this.buffer[k++] = previousBuffer[i];
		    }
		    for(i=0; i<this.start; i++) {
		      this.buffer[k++] = previousBuffer[i];
		    }
		    this.start = 0;
		    this.end = previousBuffer.length;
		  }
		}

		Dequeue.prototype.shift = function() {
		  // Return the element in this.start

		  if (this.getLength() > 0) {
		    var result = this.buffer[this.start];
		    this.start++;
		    if (this.start === this.buffer.length) this.start = 0;
		    return result;
		  }
		}

		Dequeue.prototype.getLength = function() {
		  if (this.start <= this.end) {
		    return this.end-this.start;
		  }
		  else {
		    return this.buffer.length-(this.start-this.end);
		  }
		}

		module.exports = Dequeue;


	/***/ },
	/* 62 */
	/***/ function(module, exports, __webpack_require__) {

		var Promise = __webpack_require__(3);
		var Dequeue = __webpack_require__(61);
		var helper = __webpack_require__(41);
		var Err = __webpack_require__(52);
		var events = __webpack_require__(50);
		var util = __webpack_require__(51);

		function Pool(r, options) {
		  this._r = r;

		  if (!helper.isPlainObject(options)) options = {};
		  this.options = {};
		  this.options.max = options.max || 1000; // 4000 is about the maximum the kernel can take
		  var buffer = (typeof options.buffer === 'number') ? options.buffer : 50;
		  this.options.buffer = (buffer < this.options.max) ? buffer : this.options.max;
		  this.options.timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?
		  this.options.timeoutGb = options.timeoutGb || 60*60*1000; // Default timeout for TCP connection is 2 hours on Linux, we time out after one hour.
		  this.options.maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError

		  this.options.silent = options.silent || false;

		  this.options.connection = {
		    host: options.host || this._r._host,
		    port: options.port || this._r._port,
		    db: options.db || this._r._db,
		    timeout: options.timeout || this._r._timeoutConnect,
		    authKey: options.authKey || this._r._authKey,
		    cursor: options.cursor || false,
		    stream: options.stream || false,
		    ssl: options.ssl || false
		  }
		  this._log = options._log;

		  this._pool = new Dequeue(this.options.buffer+1);
		  this._draining = null;
		  this._localhostToDrain = 0; // number of connections to "localhost" to remove
		  this._connectionToReplace = 0; // number of connections to "localhost" to remove

		  this._numConnections = 0;
		  this._openingConnections = 0; // Number of connections being opened
		  this._consecutiveFails = 0;   // In slow growth, the number of consecutive failures to open a connection
		  this._slowGrowth = false;     // Opening one connection at a time
		  this._slowlyGrowing = false;  // The next connection to be returned is one opened in slowGrowth mode
		  this._extraConnections = 0; // Number of extra connections being opened that we should eventually close

		  this._empty = true;

		  var self = this;
		  // So we can let the pool master bind listeners
		  setTimeout(function() {
		    for(var i=0; i<self.options.buffer; i++) {
		      if (self.getLength() < self.options.max) {
		        self.createConnection();
		      }
		    }
		  }, 0);
		  this.id = Math.floor(Math.random()*100000);
		  this._log('Creating a pool connected to '+this.getAddress());
		}

		util.inherits(Pool, events.EventEmitter);
		/*
		 * Events:
		 *  - draining // when `drain` is called
		 *  - queueing(size of the queue) // the number of queries being beffered changed
		 *  - size(number of connections) // the size of the pool changed
		 *  - available-size(available size) // the number of AVAILABLE conncetions of the pool changed
		 */

		Pool.prototype.getConnection = function() {
		  var self = this;
		  var p = new Promise(function(resolve, reject) {
		    if (self._draining !== null) {
		      return reject(new Err.ReqlDriverError('The pool is being drained'));
		    }

		    var connection = self._pool.pop();
		    self.emit('available-size', self._pool.getLength());
		    self.emit('available-size-diff', -1);

		    if (connection) {
		      clearTimeout(connection.timeout);
		      resolve(connection);
		    }
		    else {
		      if ((self._numConnections === 0) && (self._slowGrowth === true)) {
		        // If the server is down we do not want to buffer the queries
		        return reject(new Err.ReqlDriverError('The pool does not have any opened connections and failed to open a new one'));
		      }
		    }

		    if (self._slowGrowth === false) {
		      self._expandBuffer();
		    }

		  });
		  return p;
		};

		Pool.prototype._decreaseNumConnections = function() {
		  this._numConnections--;
		  this.emit('size', this._numConnections)
		  this.emit('size-diff', -1)
		  if ((this._draining !== null) && (this._numConnections === 0)) {
		    this._draining.resolve();
		  }
		  // We do not check for this._empty === false because we want to emit empty if the pool
		  // tries to connect to an unavailable server (such that the master can remove it from the
		  // healthy pool
		  if (this._numConnections === 0) {
		    this._empty = true;
		    this.emit('empty');
		  }
		}
		Pool.prototype._increaseNumConnections = function() {
		  this._numConnections++;
		  this.emit('size', this._numConnections)
		  this.emit('size-diff', 1)
		}


		Pool.prototype.putConnection = function(connection) {
		  var self = this;
		  if (self._empty === true) {
		    self._empty = false;
		    // We emit not-empty only we have at least one opened connection
		    self.emit('not-empty');
		  }
		  if ((self._localhostToDrain > 0) && (helper.localhostAliases.hasOwnProperty(connection.host))) {
		    self._localhostToDrain--;
		    connection.close();
		    clearTimeout(connection.timeout);
		    self.createConnection();
		  }
		  else if (self._draining !== null) {
		    connection.close();
		    clearTimeout(connection.timeout);
		    if (self.getLength() === 0) {
		      self._draining.resolve();
		    }
		  }
		  else if (self._extraConnections > 0) {
		    self._extraConnections--;
		    connection.close().error(function(error) {
		      self._log('Fail to properly close a connection. Error:'+JSON.stringify(error));
		    });
		    clearTimeout(connection.timeout);
		  }
		  /*
		  // We let the pool garbage collect these connections
		  else if (self.getAvailableLength()+1 > self.options.buffer) { // +1 for the connection we may put back
		    // Note that because we have available connections here, the pool master has no pending
		    // queries.
		    connection.close().error(function(error) {
		      self._log('Fail to properly close a connection. Error:'+JSON.stringify(error));
		    });
		    clearTimeout(connection.timeout);
		  }
		  */
		  else {
		    self._pool.push(connection);
		    self.emit('available-size', self._pool.getLength());
		    self.emit('available-size-diff', 1);
		    self.emit('new-connection', connection);

		    clearTimeout(connection.timeout);
		    var timeoutCb = function() {
		      if (self._pool.get(0) === connection) {
		        if (self._pool.getLength() > self.options.buffer) {
		          self._pool.shift().close();
		          self.emit('available-size', self._pool.getLength());
		          self.emit('available-size-diff', -1);
		        }
		        else {
		          connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
		        }
		      }
		      else {
		        // This should technically never happens
		        connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
		      }
		    }
		    connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
		  }
		};

		Pool.prototype.createConnection = function() {
		  var self = this;
		  self._increaseNumConnections();
		  self._openingConnections++;

		  self.emit('creating-connection', self);
		  if (self._draining) {
		    return; // Do not create a new connection if we are draining the pool.
		  }

		  return self._r.connect(self.options.connection).then(function(connection) {
		    self.emit('created-connection', self);

		    self._openingConnections--;

		    if ((self._slowlyGrowing === false) && (self._slowGrowth === true) && (self._openingConnections === 0)) {
		      self._consecutiveFails++;
		      self._slowlyGrowing = true;
		      self.timeoutReconnect = setTimeout(function() {
		        self.createConnection();
		        //self._expandBuffer();
		      }, (1<<Math.min(self.options.maxExponent, self._consecutiveFails))*self.options.timeoutError);
		    }
		    // Need another flag
		    else if ((self._slowlyGrowing === true) && (self._slowGrowth === true) && (self._consecutiveFails > 0)) {
		      self._log('Exiting slow growth mode');
		      self._consecutiveFails = 0;
		      self._slowGrowth = false;
		      self._slowlyGrowing = false;
		      self._aggressivelyExpandBuffer();
		    }



		    connection.on('error', function(e) {
		      // We are going to close connection, but we don't want another process to use it before
		      // So we remove it from the pool now (if it's inside)
		      self._log('Error emitted by a connection: '+JSON.stringify(error));
		      for(var i=0; i<self.getAvailableLength(); i++) {
		        if (self._pool.get(i) === this) {
		          self._pool.delete(i);
		          self.emit('available-size', self._pool.getLength());
		          self.emit('available-size-diff', -1);
		          break;
		        }
		      }
		      // We want to make sure that it's not going to try to reconnect
		      clearTimeout(connection.timeout);

		      // Not sure what happened here, so let's be safe and close this connection.
		      connection.close().then(function() {
		        self._expandBuffer();
		      }).error(function(e) {
		        // We failed to close this connection, but we removed it from the pool... so err, let's just ignore that.
		        self._expandBuffer();
		      });
		      clearTimeout(connection.timeout);
		    });
		    connection.on('end', function(e) {
		      // The connection was closed by the server, let's clean...
		      for(var i=0; i<self.getAvailableLength(); i++) {
		        if (self._pool.get(i) === this) {
		          self._pool.delete(i);
		          self.emit('available-size', self._pool.getLength());
		          self.emit('available-size-diff', -1);
		          break;
		        }
		      }

		      clearTimeout(connection.timeout);
		      self._decreaseNumConnections();
		      self._expandBuffer();
		    });
		    connection.on('timeout', function() {
		      for(var i=0; i<self.getAvailableLength(); i++) {
		        if (self._pool.get(i) === this) {
		          self._pool.delete(i);
		          self.emit('available-size', self._pool.getLength());
		          self.emit('available-size-diff', -1);
		          break;
		        }
		      }

		      clearTimeout(connection.timeout);
		      self._decreaseNumConnections();
		      self._expandBuffer();
		    });
		    connection.on('release', function() {
		      if (this._isOpen()) self.putConnection(this);
		    });
		    self.putConnection(connection);
		  }).error(function(error) {
		    // We failed to create a connection, we are now going to create connections one by one
		    self._openingConnections--;
		    self._decreaseNumConnections();

		    self._slowGrowth = true;
		    if (self._slowlyGrowing === false) {
		      self._log('Entering slow growth mode');
		    }
		    self._slowlyGrowing = true;

		    // Log an error
		    self._log('Fail to create a new connection for the connection pool. Error:'+JSON.stringify(error));

		    if (self._openingConnections === 0) {
		      self._consecutiveFails++;
		      self.timeoutReconnect = setTimeout(function() {
		        //self._expandBuffer();
		        self.createConnection();
		      }, (1<<Math.min(self.options.maxExponent, self._consecutiveFails))*self.options.timeoutError);
		    }
		  })
		};

		Pool.prototype._aggressivelyExpandBuffer = function() {
		  for(var i=0; i<this.options.buffer; i++) {
		    this._expandBuffer();
		  }
		}
		Pool.prototype._expandBuffer = function() {
		  if ((this._draining === null) &&
		      (this._pool.getLength() < this.options.buffer+this._localhostToDrain) &&
		      (this._numConnections < this.options.max+this._localhostToDrain)) {
		    this.createConnection();
		  }
		}

		Pool.prototype.getLength = function() {
		  return this._numConnections;
		}
		Pool.prototype.getAvailableLength = function() {
		  return this._pool.getLength();
		}

		Pool.prototype.setOptions = function(options) {
		  if (helper.isPlainObject(options)) {
		    for(var key in options) {
		      this.options[key] = options[key];
		    }
		  }
		  return this.options;
		}
		Pool.prototype.drainLocalhost = function() {
		  var self = this;
		  // All the connections are to localhost, let's create new ones (not to localhost)
		  self._connectionToReplace = self._numConnections;
		  ;
		  for(var i=0, numConnections=self._numConnections; i<numConnections; i++) {
		    self.createConnection().finally(function() {
		      self._localhostToDrain++;
		      self._connectionToReplace--;
		      if ((self._connectionToReplace === 0) && (self._localhostToDrain > 0)) {
		        var len = self._pool.getLength();
		        for(var j=0; j<len; j++) {
		          if (self._localhostToDrain === 0) {
		            break;
		          }
		          var _connection = self._pool.shift();
		          if (helper.localhostAliases.hasOwnProperty(_connection.host)) {
		            self._localhostToDrain--;
		            _connection.close();
		            clearTimeout(_connection.timeout);
		          }
		          else {
		            self._pool.push(_connection);
		          }
		        }
		      }

		    });
		  }
		}

		Pool.prototype.drain = function() {
		  var self = this;
		  self._log('Draining the pool connected to '+this.getAddress());
		  self.emit('draining');
		  var p = new Promise(function(resolve, reject) {
		    var connection = self._pool.pop();
		    self.emit('available-size', self._pool.getLength());
		    self.emit('available-size-diff', -1);
		    while(connection) {
		      connection.close();
		      clearTimeout(connection.timeout);
		      connection = self._pool.pop();
		    }
		    if (self.timeoutReconnect !== undefined) {
		      clearTimeout(self.timeoutReconnect);
		      self.timeoutReconnect = null;
		    }
		    if (self.getLength() === 0) {
		      resolve();
		    }
		    else {
		      self._draining = {
		        resolve: resolve,
		        reject: reject
		      }
		    }
		  });
		  return p;
		}


		Pool.prototype.getAddress = function() {
		  return this.options.connection.host+':'+this.options.connection.port;
		}
		module.exports = Pool;


	/***/ },
	/* 63 */
	/***/ function(module, exports) {

		/* eslint-disable no-unused-vars */
		'use strict';
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		var propIsEnumerable = Object.prototype.propertyIsEnumerable;

		function toObject(val) {
			if (val === null || val === undefined) {
				throw new TypeError('Object.assign cannot be called with null or undefined');
			}

			return Object(val);
		}

		module.exports = Object.assign || function (target, source) {
			var from;
			var to = toObject(target);
			var symbols;

			for (var s = 1; s < arguments.length; s++) {
				from = Object(arguments[s]);

				for (var key in from) {
					if (hasOwnProperty.call(from, key)) {
						to[key] = from[key];
					}
				}

				if (Object.getOwnPropertySymbols) {
					symbols = Object.getOwnPropertySymbols(from);
					for (var i = 0; i < symbols.length; i++) {
						if (propIsEnumerable.call(from, symbols[i])) {
							to[symbols[i]] = from[symbols[i]];
						}
					}
				}
			}

			return to;
		};


	/***/ }
	/******/ ])
	});
	;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), (function() { return this; }()), __webpack_require__(3).setImmediate, __webpack_require__(4).Buffer))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            currentQueue[queueIndex].run();
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(2).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate, __webpack_require__(3).clearImmediate))

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	var base64 = __webpack_require__(5)
	var ieee754 = __webpack_require__(6)
	var isArray = __webpack_require__(7)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = (function () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	})()

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  this.length = 0
	  this.parent = undefined

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	// pre-set for values that may exist in the future
	Buffer.prototype.length = undefined
	Buffer.prototype.parent = undefined

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var firstByte
	  var secondByte
	  var thirdByte
	  var fourthByte
	  var bytesPerSequence
	  var tempCodePoint
	  var codePoint
	  var res = []
	  var i = start

	  for (; i < end; i += bytesPerSequence) {
	    firstByte = buf[i]
	    codePoint = 0xFFFD

	    if (firstByte > 0xEF) {
	      bytesPerSequence = 4
	    } else if (firstByte > 0xDF) {
	      bytesPerSequence = 3
	    } else if (firstByte > 0xBF) {
	      bytesPerSequence = 2
	    } else {
	      bytesPerSequence = 1
	    }

	    if (i + bytesPerSequence <= end) {
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === 0xFFFD) {
	      // we generated an invalid codePoint so make sure to only advance by 1 byte
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	  }

	  return String.fromCharCode.apply(String, res)
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = value
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = value
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = value
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue

	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000

	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 6 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 7 */
/***/ function(module, exports) {


	/**
	 * isArray
	 */

	var isArray = Array.isArray;

	/**
	 * toString
	 */

	var str = Object.prototype.toString;

	/**
	 * Whether or not the given `val`
	 * is an array.
	 *
	 * example:
	 *
	 *        isArray([]);
	 *        // > true
	 *        isArray(arguments);
	 *        // > false
	 *        isArray('');
	 *        // > false
	 *
	 * @param {mixed} val
	 * @return {bool}
	 */

	module.exports = isArray || function (val) {
	  return !! val && '[object Array]' == str.call(val);
	};


/***/ },
/* 8 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];

	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(10);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(11);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2)))

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 11 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(8).EventEmitter;
	var inherits = __webpack_require__(13);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(14);
	Stream.Writable = __webpack_require__(25);
	Stream.Duplex = __webpack_require__(26);
	Stream.Transform = __webpack_require__(27);
	Stream.PassThrough = __webpack_require__(28);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 13 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(15);
	exports.Stream = __webpack_require__(12);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(21);
	exports.Duplex = __webpack_require__(20);
	exports.Transform = __webpack_require__(23);
	exports.PassThrough = __webpack_require__(24);


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(16);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(4).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(8).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(12);

	/*<replacement>*/
	var util = __webpack_require__(17);
	util.inherits = __webpack_require__(18);
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = __webpack_require__(19);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(20);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(22).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(20);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(22).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 18 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 19 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(17);
	util.inherits = __webpack_require__(18);
	/*</replacement>*/

	var Readable = __webpack_require__(15);
	var Writable = __webpack_require__(21);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(4).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(17);
	util.inherits = __webpack_require__(18);
	/*</replacement>*/

	var Stream = __webpack_require__(12);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(20);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(20);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(4).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(20);

	/*<replacement>*/
	var util = __webpack_require__(17);
	util.inherits = __webpack_require__(18);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(23);

	/*<replacement>*/
	var util = __webpack_require__(17);
	util.inherits = __webpack_require__(18);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(21)


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(20)


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(23)


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(24)


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	var Promise = __webpack_require__(30)();
	module.exports = Promise;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict(bluebird) {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	module.exports = function() {
	var util = __webpack_require__(31);
	var async = __webpack_require__(33);
	var errors = __webpack_require__(36);

	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {e: null};

	var cast = __webpack_require__(37)(Promise, INTERNAL);
	var PromiseArray = __webpack_require__(38)(Promise, INTERNAL, cast);
	var CapturedTrace = __webpack_require__(39)();
	var CatchFilter = __webpack_require__(40)(NEXT_FILTER);
	var PromiseResolver = __webpack_require__(41);

	var isArray = util.isArray;

	var errorObj = util.errorObj;
	var tryCatch1 = util.tryCatch1;
	var tryCatch2 = util.tryCatch2;
	var tryCatchApply = util.tryCatchApply;
	var RangeError = errors.RangeError;
	var TypeError = errors.TypeError;
	var CancellationError = errors.CancellationError;
	var TimeoutError = errors.TimeoutError;
	var OperationalError = errors.OperationalError;
	var originatesFromRejection = errors.originatesFromRejection;
	var markAsOriginatingFromRejection = errors.markAsOriginatingFromRejection;
	var canAttach = errors.canAttach;
	var thrower = util.thrower;
	var apiRejection = __webpack_require__(42)(Promise);


	var makeSelfResolutionError = function Promise$_makeSelfResolutionError() {
	    return new TypeError("circular promise resolution chain");
	};

	function Promise(resolver) {
	    if (typeof resolver !== "function") {
	        throw new TypeError("the promise constructor requires a resolver function");
	    }
	    if (this.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly");
	    }
	    this._bitField = 0;
	    this._fulfillmentHandler0 = void 0;
	    this._rejectionHandler0 = void 0;
	    this._promise0 = void 0;
	    this._receiver0 = void 0;
	    this._settledValue = void 0;
	    this._boundTo = void 0;
	    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
	}

	Promise.prototype.bind = function Promise$bind(thisArg) {
	    var ret = new Promise(INTERNAL);
	    ret._follow(this);
	    ret._propagateFrom(this, 2 | 1);
	    ret._setBoundTo(thisArg);
	    return ret;
	};

	Promise.prototype.toString = function Promise$toString() {
	    return "[object Promise]";
	};

	Promise.prototype.caught = Promise.prototype["catch"] =
	function Promise$catch(fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (typeof item === "function") {
	                catchInstances[j++] = item;
	            } else {
	                var catchFilterTypeError =
	                    new TypeError(
	                        "A catch filter must be an error constructor "
	                        + "or a filter function");

	                this._attachExtraTrace(catchFilterTypeError);
	                async.invoke(this._reject, this, catchFilterTypeError);
	                return;
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];

	        this._resetTrace();
	        var catchFilter = new CatchFilter(catchInstances, fn, this);
	        return this._then(void 0, catchFilter.doFilter, void 0,
	            catchFilter, void 0);
	    }
	    return this._then(void 0, fn, void 0, void 0, void 0);
	};

	Promise.prototype.then =
	function Promise$then(didFulfill, didReject, didProgress) {
	    return this._then(didFulfill, didReject, didProgress,
	        void 0, void 0);
	};


	Promise.prototype.done =
	function Promise$done(didFulfill, didReject, didProgress) {
	    var promise = this._then(didFulfill, didReject, didProgress,
	        void 0, void 0);
	    promise._setIsFinal();
	};

	Promise.prototype.spread = function Promise$spread(didFulfill, didReject) {
	    return this._then(didFulfill, didReject, void 0,
	        APPLY, void 0);
	};

	Promise.prototype.isCancellable = function Promise$isCancellable() {
	    return !this.isResolved() &&
	        this._cancellable();
	};

	Promise.prototype.toJSON = function Promise$toJSON() {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: void 0,
	        rejectionReason: void 0
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this._settledValue;
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this._settledValue;
	        ret.isRejected = true;
	    }
	    return ret;
	};

	Promise.prototype.all = function Promise$all() {
	    return new PromiseArray(this).promise();
	};


	Promise.is = function Promise$Is(val) {
	    return val instanceof Promise;
	};

	Promise.all = function Promise$All(promises) {
	    return new PromiseArray(promises).promise();
	};

	Promise.prototype.error = function Promise$_error(fn) {
	    return this.caught(originatesFromRejection, fn);
	};

	Promise.prototype._resolveFromSyncValue =
	function Promise$_resolveFromSyncValue(value) {
	    if (value === errorObj) {
	        this._cleanValues();
	        this._setRejected();
	        this._settledValue = value.e;
	        this._ensurePossibleRejectionHandled();
	    } else {
	        var maybePromise = cast(value, void 0);
	        if (maybePromise instanceof Promise) {
	            this._follow(maybePromise);
	        } else {
	            this._cleanValues();
	            this._setFulfilled();
	            this._settledValue = value;
	        }
	    }
	};

	Promise.method = function Promise$_Method(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("fn must be a function");
	    }
	    return function Promise$_method() {
	        var value;
	        switch(arguments.length) {
	        case 0: value = tryCatch1(fn, this, void 0); break;
	        case 1: value = tryCatch1(fn, this, arguments[0]); break;
	        case 2: value = tryCatch2(fn, this, arguments[0], arguments[1]); break;
	        default:
	            var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
	            value = tryCatchApply(fn, args, this); break;
	        }
	        var ret = new Promise(INTERNAL);
	        ret._setTrace(void 0);
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};

	Promise.attempt = Promise["try"] = function Promise$_Try(fn, args, ctx) {
	    if (typeof fn !== "function") {
	        return apiRejection("fn must be a function");
	    }
	    var value = isArray(args)
	        ? tryCatchApply(fn, args, ctx)
	        : tryCatch1(fn, ctx, args);

	    var ret = new Promise(INTERNAL);
	    ret._setTrace(void 0);
	    ret._resolveFromSyncValue(value);
	    return ret;
	};

	Promise.defer = Promise.pending = function Promise$Defer() {
	    var promise = new Promise(INTERNAL);
	    promise._setTrace(void 0);
	    return new PromiseResolver(promise);
	};

	Promise.bind = function Promise$Bind(thisArg) {
	    var ret = new Promise(INTERNAL);
	    ret._setTrace(void 0);
	    ret._setFulfilled();
	    ret._setBoundTo(thisArg);
	    return ret;
	};

	Promise.cast = function Promise$_Cast(obj) {
	    var ret = cast(obj, void 0);
	    if (!(ret instanceof Promise)) {
	        var val = ret;
	        ret = new Promise(INTERNAL);
	        ret._setTrace(void 0);
	        ret._setFulfilled();
	        ret._cleanValues();
	        ret._settledValue = val;
	    }
	    return ret;
	};

	Promise.resolve = Promise.fulfilled = Promise.cast;

	Promise.reject = Promise.rejected = function Promise$Reject(reason) {
	    var ret = new Promise(INTERNAL);
	    ret._setTrace(void 0);
	    markAsOriginatingFromRejection(reason);
	    ret._cleanValues();
	    ret._setRejected();
	    ret._settledValue = reason;
	    if (!canAttach(reason)) {
	        var trace = new Error(reason + "");
	        ret._setCarriedStackTrace(trace);
	    }
	    ret._ensurePossibleRejectionHandled();
	    return ret;
	};

	Promise.onPossiblyUnhandledRejection =
	function Promise$OnPossiblyUnhandledRejection(fn) {
	        CapturedTrace.possiblyUnhandledRejection = typeof fn === "function"
	                                                    ? fn : void 0;
	};

	var unhandledRejectionHandled;
	Promise.onUnhandledRejectionHandled =
	function Promise$onUnhandledRejectionHandled(fn) {
	    unhandledRejectionHandled = typeof fn === "function" ? fn : void 0;
	};

	var debugging = false || !!(
	    typeof process !== "undefined" &&
	    typeof process.execPath === "string" &&
	    typeof process.env === "object" &&
	    (process.env["BLUEBIRD_DEBUG"] ||
	        process.env["NODE_ENV"] === "development")
	);


	Promise.longStackTraces = function Promise$LongStackTraces() {
	    if (async.haveItemsQueued() &&
	        debugging === false
	   ) {
	        throw new Error("cannot enable long stack traces after promises have been created");
	    }
	    debugging = CapturedTrace.isSupported();
	};

	Promise.hasLongStackTraces = function Promise$HasLongStackTraces() {
	    return debugging && CapturedTrace.isSupported();
	};

	Promise.prototype._then =
	function Promise$_then(
	    didFulfill,
	    didReject,
	    didProgress,
	    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== void 0;
	    var ret = haveInternalData ? internalData : new Promise(INTERNAL);

	    if (!haveInternalData) {
	        if (debugging) {
	            var haveSameContext = this._peekContext() === this._traceParent;
	            ret._traceParent = haveSameContext ? this._traceParent : this;
	        }
	        ret._propagateFrom(this, 7);
	    }

	    var callbackIndex =
	        this._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);

	    if (this.isResolved()) {
	        async.invoke(this._queueSettleAt, this, callbackIndex);
	    }

	    return ret;
	};

	Promise.prototype._length = function Promise$_length() {
	    return this._bitField & 262143;
	};

	Promise.prototype._isFollowingOrFulfilledOrRejected =
	function Promise$_isFollowingOrFulfilledOrRejected() {
	    return (this._bitField & 939524096) > 0;
	};

	Promise.prototype._isFollowing = function Promise$_isFollowing() {
	    return (this._bitField & 536870912) === 536870912;
	};

	Promise.prototype._setLength = function Promise$_setLength(len) {
	    this._bitField = (this._bitField & -262144) |
	        (len & 262143);
	};

	Promise.prototype._setFulfilled = function Promise$_setFulfilled() {
	    this._bitField = this._bitField | 268435456;
	};

	Promise.prototype._setRejected = function Promise$_setRejected() {
	    this._bitField = this._bitField | 134217728;
	};

	Promise.prototype._setFollowing = function Promise$_setFollowing() {
	    this._bitField = this._bitField | 536870912;
	};

	Promise.prototype._setIsFinal = function Promise$_setIsFinal() {
	    this._bitField = this._bitField | 33554432;
	};

	Promise.prototype._isFinal = function Promise$_isFinal() {
	    return (this._bitField & 33554432) > 0;
	};

	Promise.prototype._cancellable = function Promise$_cancellable() {
	    return (this._bitField & 67108864) > 0;
	};

	Promise.prototype._setCancellable = function Promise$_setCancellable() {
	    this._bitField = this._bitField | 67108864;
	};

	Promise.prototype._unsetCancellable = function Promise$_unsetCancellable() {
	    this._bitField = this._bitField & (~67108864);
	};

	Promise.prototype._setRejectionIsUnhandled =
	function Promise$_setRejectionIsUnhandled() {
	    this._bitField = this._bitField | 2097152;
	};

	Promise.prototype._unsetRejectionIsUnhandled =
	function Promise$_unsetRejectionIsUnhandled() {
	    this._bitField = this._bitField & (~2097152);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};

	Promise.prototype._isRejectionUnhandled =
	function Promise$_isRejectionUnhandled() {
	    return (this._bitField & 2097152) > 0;
	};

	Promise.prototype._setUnhandledRejectionIsNotified =
	function Promise$_setUnhandledRejectionIsNotified() {
	    this._bitField = this._bitField | 524288;
	};

	Promise.prototype._unsetUnhandledRejectionIsNotified =
	function Promise$_unsetUnhandledRejectionIsNotified() {
	    this._bitField = this._bitField & (~524288);
	};

	Promise.prototype._isUnhandledRejectionNotified =
	function Promise$_isUnhandledRejectionNotified() {
	    return (this._bitField & 524288) > 0;
	};

	Promise.prototype._setCarriedStackTrace =
	function Promise$_setCarriedStackTrace(capturedTrace) {
	    this._bitField = this._bitField | 1048576;
	    this._fulfillmentHandler0 = capturedTrace;
	};

	Promise.prototype._unsetCarriedStackTrace =
	function Promise$_unsetCarriedStackTrace() {
	    this._bitField = this._bitField & (~1048576);
	    this._fulfillmentHandler0 = void 0;
	};

	Promise.prototype._isCarryingStackTrace =
	function Promise$_isCarryingStackTrace() {
	    return (this._bitField & 1048576) > 0;
	};

	Promise.prototype._getCarriedStackTrace =
	function Promise$_getCarriedStackTrace() {
	    return this._isCarryingStackTrace()
	        ? this._fulfillmentHandler0
	        : void 0;
	};

	Promise.prototype._receiverAt = function Promise$_receiverAt(index) {
	    var ret = index === 0
	        ? this._receiver0
	        : this[(index << 2) + index - 5 + 4];
	    if (this._isBound() && ret === void 0) {
	        return this._boundTo;
	    }
	    return ret;
	};

	Promise.prototype._promiseAt = function Promise$_promiseAt(index) {
	    return index === 0
	        ? this._promise0
	        : this[(index << 2) + index - 5 + 3];
	};

	Promise.prototype._fulfillmentHandlerAt =
	function Promise$_fulfillmentHandlerAt(index) {
	    return index === 0
	        ? this._fulfillmentHandler0
	        : this[(index << 2) + index - 5 + 0];
	};

	Promise.prototype._rejectionHandlerAt =
	function Promise$_rejectionHandlerAt(index) {
	    return index === 0
	        ? this._rejectionHandler0
	        : this[(index << 2) + index - 5 + 1];
	};

	Promise.prototype._addCallbacks = function Promise$_addCallbacks(
	    fulfill,
	    reject,
	    progress,
	    promise,
	    receiver
	) {
	    var index = this._length();

	    if (index >= 262143 - 5) {
	        index = 0;
	        this._setLength(0);
	    }

	    if (index === 0) {
	        this._promise0 = promise;
	        if (receiver !== void 0) this._receiver0 = receiver;
	        if (typeof fulfill === "function" && !this._isCarryingStackTrace())
	            this._fulfillmentHandler0 = fulfill;
	        if (typeof reject === "function") this._rejectionHandler0 = reject;
	        if (typeof progress === "function") this._progressHandler0 = progress;
	    } else {
	        var base = (index << 2) + index - 5;
	        this[base + 3] = promise;
	        this[base + 4] = receiver;
	        this[base + 0] = typeof fulfill === "function"
	                                            ? fulfill : void 0;
	        this[base + 1] = typeof reject === "function"
	                                            ? reject : void 0;
	        this[base + 2] = typeof progress === "function"
	                                            ? progress : void 0;
	    }
	    this._setLength(index + 1);
	    return index;
	};

	Promise.prototype._setProxyHandlers =
	function Promise$_setProxyHandlers(receiver, promiseSlotValue) {
	    var index = this._length();

	    if (index >= 262143 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	    if (index === 0) {
	        this._promise0 = promiseSlotValue;
	        this._receiver0 = receiver;
	    } else {
	        var base = (index << 2) + index - 5;
	        this[base + 3] = promiseSlotValue;
	        this[base + 4] = receiver;
	        this[base + 0] =
	        this[base + 1] =
	        this[base + 2] = void 0;
	    }
	    this._setLength(index + 1);
	};

	Promise.prototype._proxyPromiseArray =
	function Promise$_proxyPromiseArray(promiseArray, index) {
	    this._setProxyHandlers(promiseArray, index);
	};

	Promise.prototype._proxyPromise = function Promise$_proxyPromise(promise) {
	    promise._setProxied();
	    this._setProxyHandlers(promise, -1);
	};

	Promise.prototype._setBoundTo = function Promise$_setBoundTo(obj) {
	    if (obj !== void 0) {
	        this._bitField = this._bitField | 8388608;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~8388608);
	    }
	};

	Promise.prototype._isBound = function Promise$_isBound() {
	    return (this._bitField & 8388608) === 8388608;
	};

	Promise.prototype._resolveFromResolver =
	function Promise$_resolveFromResolver(resolver) {
	    var promise = this;
	    this._setTrace(void 0);
	    this._pushContext();

	    function Promise$_resolver(val) {
	        if (promise._tryFollow(val)) {
	            return;
	        }
	        promise._fulfill(val);
	    }
	    function Promise$_rejecter(val) {
	        var trace = canAttach(val) ? val : new Error(val + "");
	        promise._attachExtraTrace(trace);
	        markAsOriginatingFromRejection(val);
	        promise._reject(val, trace === val ? void 0 : trace);
	    }
	    var r = tryCatch2(resolver, void 0, Promise$_resolver, Promise$_rejecter);
	    this._popContext();

	    if (r !== void 0 && r === errorObj) {
	        var e = r.e;
	        var trace = canAttach(e) ? e : new Error(e + "");
	        promise._reject(e, trace);
	    }
	};

	Promise.prototype._spreadSlowCase =
	function Promise$_spreadSlowCase(targetFn, promise, values, boundTo) {
	    var promiseForAll = new PromiseArray(values).promise();
	    var promise2 = promiseForAll._then(function() {
	        return targetFn.apply(boundTo, arguments);
	    }, void 0, void 0, APPLY, void 0);
	    promise._follow(promise2);
	};

	Promise.prototype._callSpread =
	function Promise$_callSpread(handler, promise, value) {
	    var boundTo = this._boundTo;
	    if (isArray(value)) {
	        for (var i = 0, len = value.length; i < len; ++i) {
	            if (cast(value[i], void 0) instanceof Promise) {
	                this._spreadSlowCase(handler, promise, value, boundTo);
	                return;
	            }
	        }
	    }
	    promise._pushContext();
	    return tryCatchApply(handler, value, boundTo);
	};

	Promise.prototype._callHandler =
	function Promise$_callHandler(
	    handler, receiver, promise, value) {
	    var x;
	    if (receiver === APPLY && !this.isRejected()) {
	        x = this._callSpread(handler, promise, value);
	    } else {
	        promise._pushContext();
	        x = tryCatch1(handler, receiver, value);
	    }
	    promise._popContext();
	    return x;
	};

	Promise.prototype._settlePromiseFromHandler =
	function Promise$_settlePromiseFromHandler(
	    handler, receiver, value, promise
	) {
	    if (!(promise instanceof Promise)) {
	        handler.call(receiver, value, promise);
	        return;
	    }
	    var x = this._callHandler(handler, receiver, promise, value);
	    if (promise._isFollowing()) return;

	    if (x === errorObj || x === promise || x === NEXT_FILTER) {
	        var err = x === promise
	                    ? makeSelfResolutionError()
	                    : x.e;
	        var trace = canAttach(err) ? err : new Error(err + "");
	        if (x !== NEXT_FILTER) promise._attachExtraTrace(trace);
	        promise._rejectUnchecked(err, trace);
	    } else {
	        var castValue = cast(x, promise);
	        if (castValue instanceof Promise) {
	            if (castValue.isRejected() &&
	                !castValue._isCarryingStackTrace() &&
	                !canAttach(castValue._settledValue)) {
	                var trace = new Error(castValue._settledValue + "");
	                promise._attachExtraTrace(trace);
	                castValue._setCarriedStackTrace(trace);
	            }
	            promise._follow(castValue);
	            promise._propagateFrom(castValue, 1);
	        } else {
	            promise._fulfillUnchecked(x);
	        }
	    }
	};

	Promise.prototype._follow =
	function Promise$_follow(promise) {
	    this._setFollowing();

	    if (promise.isPending()) {
	        this._propagateFrom(promise, 1);
	        promise._proxyPromise(this);
	    } else if (promise.isFulfilled()) {
	        this._fulfillUnchecked(promise._settledValue);
	    } else {
	        this._rejectUnchecked(promise._settledValue,
	            promise._getCarriedStackTrace());
	    }

	    if (promise._isRejectionUnhandled()) promise._unsetRejectionIsUnhandled();

	    if (debugging &&
	        promise._traceParent == null) {
	        promise._traceParent = this;
	    }
	};

	Promise.prototype._tryFollow =
	function Promise$_tryFollow(value) {
	    if (this._isFollowingOrFulfilledOrRejected() ||
	        value === this) {
	        return false;
	    }
	    var maybePromise = cast(value, void 0);
	    if (!(maybePromise instanceof Promise)) {
	        return false;
	    }
	    this._follow(maybePromise);
	    return true;
	};

	Promise.prototype._resetTrace = function Promise$_resetTrace() {
	    if (debugging) {
	        this._trace = new CapturedTrace(this._peekContext() === void 0);
	    }
	};

	Promise.prototype._setTrace = function Promise$_setTrace(parent) {
	    if (debugging) {
	        var context = this._peekContext();
	        this._traceParent = context;
	        var isTopLevel = context === void 0;
	        if (parent !== void 0 &&
	            parent._traceParent === context) {
	            this._trace = parent._trace;
	        } else {
	            this._trace = new CapturedTrace(isTopLevel);
	        }
	    }
	    return this;
	};

	Promise.prototype._attachExtraTrace =
	function Promise$_attachExtraTrace(error) {
	    if (debugging) {
	        var promise = this;
	        var stack = error.stack;
	        stack = typeof stack === "string"
	            ? stack.split("\n") : [];
	        var headerLineCount = 1;
	        var combinedTraces = 1;
	        while(promise != null &&
	            promise._trace != null) {
	            stack = CapturedTrace.combine(
	                stack,
	                promise._trace.stack.split("\n")
	            );
	            promise = promise._traceParent;
	            combinedTraces++;
	        }

	        var stackTraceLimit = Error.stackTraceLimit || 10;
	        var max = (stackTraceLimit + headerLineCount) * combinedTraces;
	        var len = stack.length;
	        if (len  > max) {
	            stack.length = max;
	        }
	        if (stack.length <= headerLineCount) {
	            error.stack = "(No stack trace)";
	        } else {
	            error.stack = stack.join("\n");
	        }
	    }
	};

	Promise.prototype._cleanValues = function Promise$_cleanValues() {
	    if (this._cancellable()) {
	        this._cancellationParent = void 0;
	    }
	};

	Promise.prototype._propagateFrom =
	function Promise$_propagateFrom(parent, flags) {
	    if ((flags & 1) > 0 && parent._cancellable()) {
	        this._setCancellable();
	        this._cancellationParent = parent;
	    }
	    if ((flags & 4) > 0) {
	        this._setBoundTo(parent._boundTo);
	    }
	    if ((flags & 2) > 0) {
	        this._setTrace(parent);
	    }
	};

	Promise.prototype._fulfill = function Promise$_fulfill(value) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._fulfillUnchecked(value);
	};

	Promise.prototype._reject =
	function Promise$_reject(reason, carriedStackTrace) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._rejectUnchecked(reason, carriedStackTrace);
	};

	Promise.prototype._settlePromiseAt = function Promise$_settlePromiseAt(index) {
	    var handler = this.isFulfilled()
	        ? this._fulfillmentHandlerAt(index)
	        : this._rejectionHandlerAt(index);

	    var value = this._settledValue;
	    var receiver = this._receiverAt(index);
	    var promise = this._promiseAt(index);

	    if (typeof handler === "function") {
	        this._settlePromiseFromHandler(handler, receiver, value, promise);
	    } else {
	        var done = false;
	        var isFulfilled = this.isFulfilled();
	        if (receiver !== void 0) {
	            if (receiver instanceof Promise &&
	                receiver._isProxied()) {
	                receiver._unsetProxied();

	                if (isFulfilled) receiver._fulfillUnchecked(value);
	                else receiver._rejectUnchecked(value,
	                    this._getCarriedStackTrace());
	                done = true;
	            } else if (receiver instanceof PromiseArray) {
	                if (isFulfilled) receiver._promiseFulfilled(value, promise);
	                else receiver._promiseRejected(value, promise);
	                done = true;
	            }
	        }

	        if (!done) {
	            if (isFulfilled) promise._fulfill(value);
	            else promise._reject(value, this._getCarriedStackTrace());
	        }
	    }

	    if (index >= 256) {
	        this._queueGC();
	    }
	};

	Promise.prototype._isProxied = function Promise$_isProxied() {
	    return (this._bitField & 4194304) === 4194304;
	};

	Promise.prototype._setProxied = function Promise$_setProxied() {
	    this._bitField = this._bitField | 4194304;
	};

	Promise.prototype._unsetProxied = function Promise$_unsetProxied() {
	    this._bitField = this._bitField & (~4194304);
	};

	Promise.prototype._isGcQueued = function Promise$_isGcQueued() {
	    return (this._bitField & -1073741824) === -1073741824;
	};

	Promise.prototype._setGcQueued = function Promise$_setGcQueued() {
	    this._bitField = this._bitField | -1073741824;
	};

	Promise.prototype._unsetGcQueued = function Promise$_unsetGcQueued() {
	    this._bitField = this._bitField & (~-1073741824);
	};

	Promise.prototype._queueGC = function Promise$_queueGC() {
	    if (this._isGcQueued()) return;
	    this._setGcQueued();
	    async.invokeLater(this._gc, this, void 0);
	};

	Promise.prototype._gc = function Promise$gc() {
	    var len = this._length() * 5;
	    for (var i = 0; i < len; i++) {
	        delete this[i];
	    }
	    this._setLength(0);
	    this._unsetGcQueued();
	};

	Promise.prototype._queueSettleAt = function Promise$_queueSettleAt(index) {
	    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
	    async.invoke(this._settlePromiseAt, this, index);
	};

	Promise.prototype._fulfillUnchecked =
	function Promise$_fulfillUnchecked(value) {
	    if (!this.isPending()) return;
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err, void 0);
	    }
	    this._cleanValues();
	    this._setFulfilled();
	    this._settledValue = value;
	    var len = this._length();

	    if (len > 0) {
	        async.invoke(this._settlePromises, this, len);
	    }
	};

	Promise.prototype._rejectUncheckedCheckError =
	function Promise$_rejectUncheckedCheckError(reason) {
	    var trace = canAttach(reason) ? reason : new Error(reason + "");
	    this._rejectUnchecked(reason, trace === reason ? void 0 : trace);
	};

	Promise.prototype._rejectUnchecked =
	function Promise$_rejectUnchecked(reason, trace) {
	    if (!this.isPending()) return;
	    if (reason === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err);
	    }
	    this._cleanValues();
	    this._setRejected();
	    this._settledValue = reason;

	    if (this._isFinal()) {
	        async.invokeLater(thrower, void 0, trace === void 0 ? reason : trace);
	        return;
	    }
	    var len = this._length();

	    if (trace !== void 0) this._setCarriedStackTrace(trace);

	    if (len > 0) {
	        async.invoke(this._rejectPromises, this, null);
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};

	Promise.prototype._rejectPromises = function Promise$_rejectPromises() {
	    this._settlePromises();
	    this._unsetCarriedStackTrace();
	};

	Promise.prototype._settlePromises = function Promise$_settlePromises() {
	    var len = this._length();
	    for (var i = 0; i < len; i++) {
	        this._settlePromiseAt(i);
	    }
	};

	Promise.prototype._ensurePossibleRejectionHandled =
	function Promise$_ensurePossibleRejectionHandled() {
	    this._setRejectionIsUnhandled();
	    if (CapturedTrace.possiblyUnhandledRejection !== void 0) {
	        async.invokeLater(this._notifyUnhandledRejection, this, void 0);
	    }
	};

	Promise.prototype._notifyUnhandledRejectionIsHandled =
	function Promise$_notifyUnhandledRejectionIsHandled() {
	    if (typeof unhandledRejectionHandled === "function") {
	        async.invokeLater(unhandledRejectionHandled, void 0, this);
	    }
	};

	Promise.prototype._notifyUnhandledRejection =
	function Promise$_notifyUnhandledRejection() {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._settledValue;
	        var trace = this._getCarriedStackTrace();

	        this._setUnhandledRejectionIsNotified();

	        if (trace !== void 0) {
	            this._unsetCarriedStackTrace();
	            reason = trace;
	        }
	        if (typeof CapturedTrace.possiblyUnhandledRejection === "function") {
	            CapturedTrace.possiblyUnhandledRejection(reason, this);
	        }
	    }
	};

	var contextStack = [];
	Promise.prototype._peekContext = function Promise$_peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return void 0;

	};

	Promise.prototype._pushContext = function Promise$_pushContext() {
	    if (!debugging) return;
	    contextStack.push(this);
	};

	Promise.prototype._popContext = function Promise$_popContext() {
	    if (!debugging) return;
	    contextStack.pop();
	};

	Promise.noConflict = function Promise$NoConflict() {
	    return noConflict(Promise);
	};

	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function");
	    async._schedule = fn;
	};

	if (!CapturedTrace.isSupported()) {
	    Promise.longStackTraces = function(){};
	    debugging = false;
	}

	Promise._makeSelfResolutionError = makeSelfResolutionError;
	__webpack_require__(43)(Promise, NEXT_FILTER, cast);
	__webpack_require__(44)(Promise);
	__webpack_require__(45)(Promise);
	__webpack_require__(46)(Promise, PromiseArray, cast, INTERNAL);
	Promise.RangeError = RangeError;
	Promise.CancellationError = CancellationError;
	Promise.TimeoutError = TimeoutError;
	Promise.TypeError = TypeError;
	Promise.OperationalError = OperationalError;
	Promise.RejectionError = OperationalError;
	Promise.AggregateError = errors.AggregateError;

	util.toFastProperties(Promise);
	util.toFastProperties(Promise.prototype);
	Promise.Promise = Promise;
	__webpack_require__(47)(Promise,INTERNAL,cast);
	__webpack_require__(48)(Promise,INTERNAL,cast);
	__webpack_require__(49)(Promise);
	__webpack_require__(50)(Promise,apiRejection,INTERNAL,cast);
	__webpack_require__(51)(Promise,PromiseArray,apiRejection,cast,INTERNAL);
	__webpack_require__(52)(Promise);
	__webpack_require__(53)(Promise,INTERNAL);
	__webpack_require__(54)(Promise,PromiseArray,cast);
	__webpack_require__(55)(Promise,PromiseArray,apiRejection,cast,INTERNAL);
	__webpack_require__(56)(Promise,PromiseArray);
	__webpack_require__(57)(Promise,PromiseArray,apiRejection);
	__webpack_require__(58)(Promise,PromiseArray);
	__webpack_require__(59)(Promise,INTERNAL);
	__webpack_require__(60)(Promise,INTERNAL);
	__webpack_require__(61)(Promise,PromiseArray);
	__webpack_require__(62)(Promise,INTERNAL);
	__webpack_require__(63)(Promise,apiRejection,cast);

	Promise.prototype = Promise.prototype;
	return Promise;

	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	var es5 = __webpack_require__(32);
	var haveGetters = (function(){
	    try {
	        var o = {};
	        es5.defineProperty(o, "f", {
	            get: function () {
	                return 3;
	            }
	        });
	        return o.f === 3;
	    }
	    catch (e) {
	        return false;
	    }

	})();
	var canEvaluate = typeof navigator == "undefined";
	var errorObj = {e: {}};
	function tryCatch1(fn, receiver, arg) {
	    try { return fn.call(receiver, arg); }
	    catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}

	function tryCatch2(fn, receiver, arg, arg2) {
	    try { return fn.call(receiver, arg, arg2); }
	    catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}

	function tryCatch3(fn, receiver, arg, arg2, arg3) {
	    try { return fn.call(receiver, arg, arg2, arg3); }
	    catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}

	function tryCatch4(fn, receiver, arg, arg2, arg3, arg4) {
	    try { return fn.call(receiver, arg, arg2, arg3, arg4); }
	    catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}

	function tryCatchApply(fn, args, receiver) {
	    try { return fn.apply(receiver, args); }
	    catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}

	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;

	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};

	function asString(val) {
	    return typeof val === "string" ? val : ("" + val);
	}

	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";

	}

	function isObject(value) {
	    return !isPrimitive(value);
	}

	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;

	    return new Error(asString(maybeError));
	}

	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}

	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);
	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
	    }
	}

	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}


	var wrapsPrimitiveReceiver = (function() {
	    return this !== "string";
	}).call("string");

	function thrower(r) {
	    throw r;
	}

	var inheritedDataKeys = (function() {
	    if (es5.isES5) {
	        return function(obj, opts) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            var getKeys = Object(opts).includeHidden
	                ? Object.getOwnPropertyNames
	                : Object.keys;
	            while (obj != null) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        return function(obj) {
	            var ret = [];
	            /*jshint forin:false */
	            for (var key in obj) {
	                ret.push(key);
	            }
	            return ret;
	        };
	    }

	})();

	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.keys(fn.prototype);
	            return keys.length > 0 &&
	                   !(keys.length === 1 && keys[0] === "constructor");
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}

	function toFastProperties(obj) {
	    /*jshint -W027*/
	    function f() {}
	    f.prototype = obj;
	    return f;
	    eval(obj);
	}

	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}

	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}

	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    haveGetters: haveGetters,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch1: tryCatch1,
	    tryCatch2: tryCatch2,
	    tryCatch3: tryCatch3,
	    tryCatch4: tryCatch4,
	    tryCatchApply: tryCatchApply,
	    inherits: inherits,
	    withAppended: withAppended,
	    asString: asString,
	    maybeWrapAsError: maybeWrapAsError,
	    wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange
	};

	module.exports = ret;


/***/ },
/* 32 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	var isES5 = (function(){
	    "use strict";
	    return this === void 0;
	})();

	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        keys: Object.keys,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;

	    var ObjectKeys = function ObjectKeys(o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    }

	    var ObjectDefineProperty = function ObjectDefineProperty(o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    }

	    var ObjectFreeze = function ObjectFreeze(obj) {
	        return obj;
	    }

	    var ObjectGetPrototypeOf = function ObjectGetPrototypeOf(obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    }

	    var ArrayIsArray = function ArrayIsArray(obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    }

	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5
	    };
	}


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	var schedule = __webpack_require__(34);
	var Queue = __webpack_require__(35);
	var errorObj = __webpack_require__(31).errorObj;
	var tryCatch1 = __webpack_require__(31).tryCatch1;
	var _process = typeof process !== "undefined" ? process : void 0;

	function Async() {
	    this._isTickUsed = false;
	    this._schedule = schedule;
	    this._length = 0;
	    this._lateBuffer = new Queue(16);
	    this._functionBuffer = new Queue(65536);
	    var self = this;
	    this.consumeFunctionBuffer = function Async$consumeFunctionBuffer() {
	        self._consumeFunctionBuffer();
	    };
	}

	Async.prototype.haveItemsQueued = function Async$haveItemsQueued() {
	    return this._length > 0;
	};

	Async.prototype.invokeLater = function Async$invokeLater(fn, receiver, arg) {
	    if (_process !== void 0 &&
	        _process.domain != null &&
	        !fn.domain) {
	        fn = _process.domain.bind(fn);
	    }
	    this._lateBuffer.push(fn, receiver, arg);
	    this._queueTick();
	};

	Async.prototype.invoke = function Async$invoke(fn, receiver, arg) {
	    if (_process !== void 0 &&
	        _process.domain != null &&
	        !fn.domain) {
	        fn = _process.domain.bind(fn);
	    }
	    var functionBuffer = this._functionBuffer;
	    functionBuffer.push(fn, receiver, arg);
	    this._length = functionBuffer.length();
	    this._queueTick();
	};

	Async.prototype._consumeFunctionBuffer =
	function Async$_consumeFunctionBuffer() {
	    var functionBuffer = this._functionBuffer;
	    while (functionBuffer.length() > 0) {
	        var fn = functionBuffer.shift();
	        var receiver = functionBuffer.shift();
	        var arg = functionBuffer.shift();
	        fn.call(receiver, arg);
	    }
	    this._reset();
	    this._consumeLateBuffer();
	};

	Async.prototype._consumeLateBuffer = function Async$_consumeLateBuffer() {
	    var buffer = this._lateBuffer;
	    while(buffer.length() > 0) {
	        var fn = buffer.shift();
	        var receiver = buffer.shift();
	        var arg = buffer.shift();
	        var res = tryCatch1(fn, receiver, arg);
	        if (res === errorObj) {
	            this._queueTick();
	            if (fn.domain != null) {
	                fn.domain.emit("error", res.e);
	            } else {
	                throw res.e;
	            }
	        }
	    }
	};

	Async.prototype._queueTick = function Async$_queue() {
	    if (!this._isTickUsed) {
	        this._schedule(this.consumeFunctionBuffer);
	        this._isTickUsed = true;
	    }
	};

	Async.prototype._reset = function Async$_reset() {
	    this._isTickUsed = false;
	    this._length = 0;
	};

	module.exports = new Async();

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	var schedule;
	var _MutationObserver;
	if (typeof process === "object" && typeof process.version === "string") {
	    schedule = function Promise$_Scheduler(fn) {
	        process.nextTick(fn);
	    };
	}
	else if ((typeof MutationObserver !== "undefined" &&
	         (_MutationObserver = MutationObserver)) ||
	         (typeof WebKitMutationObserver !== "undefined" &&
	         (_MutationObserver = WebKitMutationObserver))) {
	    schedule = (function() {
	        var div = document.createElement("div");
	        var queuedFn = void 0;
	        var observer = new _MutationObserver(
	            function Promise$_Scheduler() {
	                var fn = queuedFn;
	                queuedFn = void 0;
	                fn();
	            }
	       );
	        observer.observe(div, {
	            attributes: true
	        });
	        return function Promise$_Scheduler(fn) {
	            queuedFn = fn;
	            div.setAttribute("class", "foo");
	        };

	    })();
	}
	else if (typeof setTimeout !== "undefined") {
	    schedule = function Promise$_Scheduler(fn) {
	        setTimeout(fn, 0);
	    };
	}
	else throw new Error("no async scheduler available");
	module.exports = schedule;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 35 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	function arrayCopy(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	    }
	}

	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	    this._makeCapacity();
	}

	Queue.prototype._willBeOverCapacity =
	function Queue$_willBeOverCapacity(size) {
	    return this._capacity < size;
	};

	Queue.prototype._pushOne = function Queue$_pushOne(arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};

	Queue.prototype.push = function Queue$push(fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};

	Queue.prototype.shift = function Queue$shift() {
	    var front = this._front,
	        ret = this[front];

	    this[front] = void 0;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};

	Queue.prototype.length = function Queue$length() {
	    return this._length;
	};

	Queue.prototype._makeCapacity = function Queue$_makeCapacity() {
	    var len = this._capacity;
	    for (var i = 0; i < len; ++i) {
	        this[i] = void 0;
	    }
	};

	Queue.prototype._checkCapacity = function Queue$_checkCapacity(size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 3);
	    }
	};

	Queue.prototype._resizeTo = function Queue$_resizeTo(capacity) {
	    var oldFront = this._front;
	    var oldCapacity = this._capacity;
	    var oldQueue = new Array(oldCapacity);
	    var length = this.length();

	    arrayCopy(this, 0, oldQueue, 0, oldCapacity);
	    this._capacity = capacity;
	    this._makeCapacity();
	    this._front = 0;
	    if (oldFront + length <= oldCapacity) {
	        arrayCopy(oldQueue, oldFront, this, 0, length);
	    } else {        var lengthBeforeWrapping =
	            length - ((oldFront + length) & (oldCapacity - 1));

	        arrayCopy(oldQueue, oldFront, this, 0, lengthBeforeWrapping);
	        arrayCopy(oldQueue, 0, this, lengthBeforeWrapping,
	                    length - lengthBeforeWrapping);
	    }
	};

	module.exports = Queue;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	var Objectfreeze = __webpack_require__(32).freeze;
	var util = __webpack_require__(31);
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;

	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}

	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof OperationalError) ||
	        e["isOperational"] === true);
	}

	function isError(obj) {
	    return obj instanceof Error;
	}

	function canAttach(obj) {
	    return isError(obj);
	}

	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        this.message = typeof message === "string" ? message : defaultMessage;
	        this.name = nameProperty;
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}

	var _TypeError, _RangeError;
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}

	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}

	AggregateError.prototype.length = 0;
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};

	function OperationalError(message) {
	    this.name = "OperationalError";
	    this.message = message;
	    this.cause = message;
	    this["isOperational"] = true;

	    if (message instanceof Error) {
	        this.message = message.message;
	        this.stack = message.stack;
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }

	}
	inherits(OperationalError, Error);

	var key = "__BluebirdErrorTypes__";
	var errorTypes = Error[key];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    notEnumerableProp(Error, key, errorTypes);
	}

	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    canAttach: canAttach
	};


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = __webpack_require__(31);
	var canAttach = __webpack_require__(36).canAttach;
	var errorObj = util.errorObj;
	var isObject = util.isObject;

	function getThen(obj) {
	    try {
	        return obj.then;
	    }
	    catch(e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}

	function Promise$_Cast(obj, originalPromise) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) {
	            return obj;
	        }
	        else if (isAnyBluebirdPromise(obj)) {
	            var ret = new Promise(INTERNAL);
	            ret._setTrace(void 0);
	            obj._then(
	                ret._fulfillUnchecked,
	                ret._rejectUncheckedCheckError,
	                ret._progressUnchecked,
	                ret,
	                null
	            );
	            ret._setFollowing();
	            return ret;
	        }
	        var then = getThen(obj);
	        if (then === errorObj) {
	            if (originalPromise !== void 0 && canAttach(then.e)) {
	                originalPromise._attachExtraTrace(then.e);
	            }
	            return Promise.reject(then.e);
	        } else if (typeof then === "function") {
	            return Promise$_doThenable(obj, then, originalPromise);
	        }
	    }
	    return obj;
	}

	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    return hasProp.call(obj, "_promise0");
	}

	function Promise$_doThenable(x, then, originalPromise) {
	    var resolver = Promise.defer();
	    var called = false;
	    try {
	        then.call(
	            x,
	            Promise$_resolveFromThenable,
	            Promise$_rejectFromThenable,
	            Promise$_progressFromThenable
	        );
	    } catch(e) {
	        if (!called) {
	            called = true;
	            var trace = canAttach(e) ? e : new Error(e + "");
	            if (originalPromise !== void 0) {
	                originalPromise._attachExtraTrace(trace);
	            }
	            resolver.promise._reject(e, trace);
	        }
	    }
	    return resolver.promise;

	    function Promise$_resolveFromThenable(y) {
	        if (called) return;
	        called = true;

	        if (x === y) {
	            var e = Promise._makeSelfResolutionError();
	            if (originalPromise !== void 0) {
	                originalPromise._attachExtraTrace(e);
	            }
	            resolver.promise._reject(e, void 0);
	            return;
	        }
	        resolver.resolve(y);
	    }

	    function Promise$_rejectFromThenable(r) {
	        if (called) return;
	        called = true;
	        var trace = canAttach(r) ? r : new Error(r + "");
	        if (originalPromise !== void 0) {
	            originalPromise._attachExtraTrace(trace);
	        }
	        resolver.promise._reject(r, trace);
	    }

	    function Promise$_progressFromThenable(v) {
	        if (called) return;
	        var promise = resolver.promise;
	        if (typeof promise._progress === "function") {
	            promise._progress(v);
	        }
	    }
	}

	return Promise$_Cast;
	};


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, INTERNAL, cast) {
	var canAttach = __webpack_require__(36).canAttach;
	var util = __webpack_require__(31);
	var isArray = util.isArray;

	function toResolutionValue(val) {
	    switch(val) {
	    case -1: return void 0;
	    case -2: return [];
	    case -3: return {};
	    }
	}

	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    var parent = void 0;
	    if (values instanceof Promise) {
	        parent = values;
	        promise._propagateFrom(parent, 1 | 4);
	    }
	    promise._setTrace(parent);
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(void 0, -2);
	}
	PromiseArray.prototype.length = function PromiseArray$length() {
	    return this._length;
	};

	PromiseArray.prototype.promise = function PromiseArray$promise() {
	    return this._promise;
	};

	PromiseArray.prototype._init =
	function PromiseArray$_init(_, resolveValueIfEmpty) {
	    var values = cast(this._values, void 0);
	    if (values instanceof Promise) {
	        this._values = values;
	        values._setBoundTo(this._promise._boundTo);
	        if (values.isFulfilled()) {
	            values = values._settledValue;
	            if (!isArray(values)) {
	                var err = new Promise.TypeError("expecting an array, a promise or a thenable");
	                this.__hardReject__(err);
	                return;
	            }
	        } else if (values.isPending()) {
	            values._then(
	                PromiseArray$_init,
	                this._reject,
	                void 0,
	                this,
	                resolveValueIfEmpty
	           );
	            return;
	        } else {
	            values._unsetRejectionIsUnhandled();
	            this._reject(values._settledValue);
	            return;
	        }
	    } else if (!isArray(values)) {
	        var err = new Promise.TypeError("expecting an array, a promise or a thenable");
	        this.__hardReject__(err);
	        return;
	    }

	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    var len = this.getActualLength(values.length);
	    var newLen = len;
	    var newValues = this.shouldCopyValues() ? new Array(len) : this._values;
	    var isDirectScanNeeded = false;
	    for (var i = 0; i < len; ++i) {
	        var maybePromise = cast(values[i], void 0);
	        if (maybePromise instanceof Promise) {
	            if (maybePromise.isPending()) {
	                maybePromise._proxyPromiseArray(this, i);
	            } else {
	                maybePromise._unsetRejectionIsUnhandled();
	                isDirectScanNeeded = true;
	            }
	        } else {
	            isDirectScanNeeded = true;
	        }
	        newValues[i] = maybePromise;
	    }
	    this._values = newValues;
	    this._length = newLen;
	    if (isDirectScanNeeded) {
	        this._scanDirectValues(len);
	    }
	};

	PromiseArray.prototype._settlePromiseAt =
	function PromiseArray$_settlePromiseAt(index) {
	    var value = this._values[index];
	    if (!(value instanceof Promise)) {
	        this._promiseFulfilled(value, index);
	    } else if (value.isFulfilled()) {
	        this._promiseFulfilled(value._settledValue, index);
	    } else if (value.isRejected()) {
	        this._promiseRejected(value._settledValue, index);
	    }
	};

	PromiseArray.prototype._scanDirectValues =
	function PromiseArray$_scanDirectValues(len) {
	    for (var i = 0; i < len; ++i) {
	        if (this._isResolved()) {
	            break;
	        }
	        this._settlePromiseAt(i);
	    }
	};

	PromiseArray.prototype._isResolved = function PromiseArray$_isResolved() {
	    return this._values === null;
	};

	PromiseArray.prototype._resolve = function PromiseArray$_resolve(value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};

	PromiseArray.prototype.__hardReject__ =
	PromiseArray.prototype._reject = function PromiseArray$_reject(reason) {
	    this._values = null;
	    var trace = canAttach(reason) ? reason : new Error(reason + "");
	    this._promise._attachExtraTrace(trace);
	    this._promise._reject(reason, trace);
	};

	PromiseArray.prototype._promiseProgressed =
	function PromiseArray$_promiseProgressed(progressValue, index) {
	    if (this._isResolved()) return;
	    this._promise._progress({
	        index: index,
	        value: progressValue
	    });
	};


	PromiseArray.prototype._promiseFulfilled =
	function PromiseArray$_promiseFulfilled(value, index) {
	    if (this._isResolved()) return;
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};

	PromiseArray.prototype._promiseRejected =
	function PromiseArray$_promiseRejected(reason, index) {
	    if (this._isResolved()) return;
	    this._totalResolved++;
	    this._reject(reason);
	};

	PromiseArray.prototype.shouldCopyValues =
	function PromiseArray$_shouldCopyValues() {
	    return true;
	};

	PromiseArray.prototype.getActualLength =
	function PromiseArray$getActualLength(len) {
	    return len;
	};

	return PromiseArray;
	};


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function() {
	var inherits = __webpack_require__(31).inherits;
	var defineProperty = __webpack_require__(32).defineProperty;

	var rignore = new RegExp(
	    "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|" +
	    "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|" +
	    "\\w*PromiseArray\\.\\w*PromiseArray|" +
	    "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|" +
	    "process._tickCallback|nextTick|Async\\$\\w+)\\b"
	);

	var rtraceline = null;
	var formatStack = null;

	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj.toString();
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {

	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}

	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}

	function CapturedTrace(ignoreUntil, isTopLevel) {
	    this.captureStackTrace(CapturedTrace, isTopLevel);

	}
	inherits(CapturedTrace, Error);

	CapturedTrace.prototype.captureStackTrace =
	function CapturedTrace$captureStackTrace(ignoreUntil, isTopLevel) {
	    captureStackTrace(this, ignoreUntil, isTopLevel);
	};

	CapturedTrace.possiblyUnhandledRejection =
	function CapturedTrace$PossiblyUnhandledRejection(reason) {
	    if (typeof console === "object") {
	        var message;
	        if (typeof reason === "object" || typeof reason === "function") {
	            var stack = reason.stack;
	            message = "Possibly unhandled " + formatStack(stack, reason);
	        } else {
	            message = "Possibly unhandled " + String(reason);
	        }
	        if (typeof console.error === "function" ||
	            typeof console.error === "object") {
	            console.error(message);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	};

	CapturedTrace.combine = function CapturedTrace$Combine(current, prev) {
	    var curLast = current.length - 1;
	    for (var i = prev.length - 1; i >= 0; --i) {
	        var line = prev[i];
	        if (current[curLast] === line) {
	            current.pop();
	            curLast--;
	        } else {
	            break;
	        }
	    }

	    current.push("From previous event:");
	    var lines = current.concat(prev);

	    var ret = [];

	    for (var i = 0, len = lines.length; i < len; ++i) {

	        if ((rignore.test(lines[i]) ||
	            (i > 0 && !rtraceline.test(lines[i])) &&
	            lines[i] !== "From previous event:")
	       ) {
	            continue;
	        }
	        ret.push(lines[i]);
	    }
	    return ret;
	};

	CapturedTrace.isSupported = function CapturedTrace$IsSupported() {
	    return typeof captureStackTrace === "function";
	};

	var captureStackTrace = (function stackDetection() {
	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        rtraceline = /^\s*at\s*/;
	        formatStack = function(stack, error) {
	            if (typeof stack === "string") return stack;

	            if (error.name !== void 0 &&
	                error.message !== void 0) {
	                return error.name + ". " + error.message;
	            }
	            return formatNonError(error);


	        };
	        var captureStackTrace = Error.captureStackTrace;
	        return function CapturedTrace$_captureStackTrace(
	            receiver, ignoreUntil) {
	            captureStackTrace(receiver, ignoreUntil);
	        };
	    }
	    var err = new Error();

	    if (typeof err.stack === "string" &&
	        typeof "".startsWith === "function" &&
	        (err.stack.startsWith("stackDetection@")) &&
	        stackDetection.name === "stackDetection") {

	        defineProperty(Error, "stackTraceLimit", {
	            writable: true,
	            enumerable: false,
	            configurable: false,
	            value: 25
	        });
	        rtraceline = /@/;
	        var rline = /[@\n]/;

	        formatStack = function(stack, error) {
	            if (typeof stack === "string") {
	                return (error.name + ". " + error.message + "\n" + stack);
	            }

	            if (error.name !== void 0 &&
	                error.message !== void 0) {
	                return error.name + ". " + error.message;
	            }
	            return formatNonError(error);
	        };

	        return function captureStackTrace(o) {
	            var stack = new Error().stack;
	            var split = stack.split(rline);
	            var len = split.length;
	            var ret = "";
	            for (var i = 0; i < len; i += 2) {
	                ret += split[i];
	                ret += "@";
	                ret += split[i + 1];
	                ret += "\n";
	            }
	            o.stack = ret;
	        };
	    } else {
	        formatStack = function(stack, error) {
	            if (typeof stack === "string") return stack;

	            if ((typeof error === "object" ||
	                typeof error === "function") &&
	                error.name !== void 0 &&
	                error.message !== void 0) {
	                return error.name + ". " + error.message;
	            }
	            return formatNonError(error);
	        };

	        return null;
	    }
	})();

	return CapturedTrace;
	};


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = __webpack_require__(31);
	var errors = __webpack_require__(36);
	var tryCatch1 = util.tryCatch1;
	var errorObj = util.errorObj;
	var keys = __webpack_require__(32).keys;
	var TypeError = errors.TypeError;

	function CatchFilter(instances, callback, promise) {
	    this._instances = instances;
	    this._callback = callback;
	    this._promise = promise;
	}

	function CatchFilter$_safePredicate(predicate, e) {
	    var safeObject = {};
	    var retfilter = tryCatch1(predicate, safeObject, e);

	    if (retfilter === errorObj) return retfilter;

	    var safeKeys = keys(safeObject);
	    if (safeKeys.length) {
	        errorObj.e = new TypeError(
	            "Catch filter must inherit from Error "
	          + "or be a simple predicate function");
	        return errorObj;
	    }
	    return retfilter;
	}

	CatchFilter.prototype.doFilter = function CatchFilter$_doFilter(e) {
	    var cb = this._callback;
	    var promise = this._promise;
	    var boundTo = promise._boundTo;
	    for (var i = 0, len = this._instances.length; i < len; ++i) {
	        var item = this._instances[i];
	        var itemIsErrorType = item === Error ||
	            (item != null && item.prototype instanceof Error);

	        if (itemIsErrorType && e instanceof item) {
	            var ret = tryCatch1(cb, boundTo, e);
	            if (ret === errorObj) {
	                NEXT_FILTER.e = ret.e;
	                return NEXT_FILTER;
	            }
	            return ret;
	        } else if (typeof item === "function" && !itemIsErrorType) {
	            var shouldHandle = CatchFilter$_safePredicate(item, e);
	            if (shouldHandle === errorObj) {
	                var trace = errors.canAttach(errorObj.e)
	                    ? errorObj.e
	                    : new Error(errorObj.e + "");
	                this._promise._attachExtraTrace(trace);
	                e = errorObj.e;
	                break;
	            } else if (shouldHandle) {
	                var ret = tryCatch1(cb, boundTo, e);
	                if (ret === errorObj) {
	                    NEXT_FILTER.e = ret.e;
	                    return NEXT_FILTER;
	                }
	                return ret;
	            }
	        }
	    }
	    NEXT_FILTER.e = e;
	    return NEXT_FILTER;
	};

	return CatchFilter;
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	var util = __webpack_require__(31);
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = __webpack_require__(36);
	var TimeoutError = errors.TimeoutError;
	var OperationalError = errors.OperationalError;
	var async = __webpack_require__(33);
	var haveGetters = util.haveGetters;
	var es5 = __webpack_require__(32);

	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}

	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	    } else {
	        ret = obj;
	    }
	    errors.markAsOriginatingFromRejection(ret);
	    return ret;
	}

	function nodebackForPromise(promise) {
	    function PromiseResolver$_callback(err, value) {
	        if (promise === null) return;

	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (arguments.length > 2) {
	            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	            promise._fulfill(args);
	        } else {
	            promise._fulfill(value);
	        }

	        promise = null;
	    }
	    return PromiseResolver$_callback;
	}


	var PromiseResolver;
	if (!haveGetters) {
	    PromiseResolver = function PromiseResolver(promise) {
	        this.promise = promise;
	        this.asCallback = nodebackForPromise(promise);
	        this.callback = this.asCallback;
	    };
	}
	else {
	    PromiseResolver = function PromiseResolver(promise) {
	        this.promise = promise;
	    };
	}
	if (haveGetters) {
	    var prop = {
	        get: function() {
	            return nodebackForPromise(this.promise);
	        }
	    };
	    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
	    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
	}

	PromiseResolver._nodebackForPromise = nodebackForPromise;

	PromiseResolver.prototype.toString = function PromiseResolver$toString() {
	    return "[object PromiseResolver]";
	};

	PromiseResolver.prototype.resolve =
	PromiseResolver.prototype.fulfill = function PromiseResolver$resolve(value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.");
	    }

	    var promise = this.promise;
	    if (promise._tryFollow(value)) {
	        return;
	    }
	    async.invoke(promise._fulfill, promise, value);
	};

	PromiseResolver.prototype.reject = function PromiseResolver$reject(reason) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.");
	    }

	    var promise = this.promise;
	    errors.markAsOriginatingFromRejection(reason);
	    var trace = errors.canAttach(reason) ? reason : new Error(reason + "");
	    promise._attachExtraTrace(trace);
	    async.invoke(promise._reject, promise, reason);
	    if (trace !== reason) {
	        async.invoke(this._setCarriedStackTrace, this, trace);
	    }
	};

	PromiseResolver.prototype.progress =
	function PromiseResolver$progress(value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.");
	    }
	    async.invoke(this.promise._progress, this.promise, value);
	};

	PromiseResolver.prototype.cancel = function PromiseResolver$cancel() {
	    async.invoke(this.promise.cancel, this.promise, void 0);
	};

	PromiseResolver.prototype.timeout = function PromiseResolver$timeout() {
	    this.reject(new TimeoutError("timeout"));
	};

	PromiseResolver.prototype.isResolved = function PromiseResolver$isResolved() {
	    return this.promise.isResolved();
	};

	PromiseResolver.prototype.toJSON = function PromiseResolver$toJSON() {
	    return this.promise.toJSON();
	};

	PromiseResolver.prototype._setCarriedStackTrace =
	function PromiseResolver$_setCarriedStackTrace(trace) {
	    if (this.promise.isRejected()) {
	        this.promise._setCarriedStackTrace(trace);
	    }
	};

	module.exports = PromiseResolver;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise) {
	var TypeError = __webpack_require__(36).TypeError;

	function apiRejection(msg) {
	    var error = new TypeError(msg);
	    var ret = Promise.rejected(error);
	    var parent = ret._peekContext();
	    if (parent != null) {
	        parent._attachExtraTrace(error);
	    }
	    return ret;
	}

	return apiRejection;
	};


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, NEXT_FILTER, cast) {
	var util = __webpack_require__(31);
	var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
	var isPrimitive = util.isPrimitive;
	var thrower = util.thrower;

	function returnThis() {
	    return this;
	}
	function throwThis() {
	    throw this;
	}
	function return$(r) {
	    return function Promise$_returner() {
	        return r;
	    };
	}
	function throw$(r) {
	    return function Promise$_thrower() {
	        throw r;
	    };
	}
	function promisedFinally(ret, reasonOrValue, isFulfilled) {
	    var then;
	    if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {
	        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
	    } else {
	        then = isFulfilled ? returnThis : throwThis;
	    }
	    return ret._then(then, thrower, void 0, reasonOrValue, void 0);
	}

	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;

	    var ret = promise._isBound()
	                    ? handler.call(promise._boundTo)
	                    : handler();

	    if (ret !== void 0) {
	        var maybePromise = cast(ret, void 0);
	        if (maybePromise instanceof Promise) {
	            return promisedFinally(maybePromise, reasonOrValue,
	                                    promise.isFulfilled());
	        }
	    }

	    if (promise.isRejected()) {
	        NEXT_FILTER.e = reasonOrValue;
	        return NEXT_FILTER;
	    } else {
	        return reasonOrValue;
	    }
	}

	function tapHandler(value) {
	    var promise = this.promise;
	    var handler = this.handler;

	    var ret = promise._isBound()
	                    ? handler.call(promise._boundTo, value)
	                    : handler(value);

	    if (ret !== void 0) {
	        var maybePromise = cast(ret, void 0);
	        if (maybePromise instanceof Promise) {
	            return promisedFinally(maybePromise, value, true);
	        }
	    }
	    return value;
	}

	Promise.prototype._passThroughHandler =
	function Promise$_passThroughHandler(handler, isFinally) {
	    if (typeof handler !== "function") return this.then();

	    var promiseAndHandler = {
	        promise: this,
	        handler: handler
	    };

	    return this._then(
	            isFinally ? finallyHandler : tapHandler,
	            isFinally ? finallyHandler : void 0, void 0,
	            promiseAndHandler, void 0);
	};

	Promise.prototype.lastly =
	Promise.prototype["finally"] = function Promise$finally(handler) {
	    return this._passThroughHandler(handler, true);
	};

	Promise.prototype.tap = function Promise$tap(handler) {
	    return this._passThroughHandler(handler, false);
	};
	};


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	var util = __webpack_require__(31);
	var isPrimitive = util.isPrimitive;
	var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;

	module.exports = function(Promise) {
	var returner = function Promise$_returner() {
	    return this;
	};
	var thrower = function Promise$_thrower() {
	    throw this;
	};

	var wrapper = function Promise$_wrapper(value, action) {
	    if (action === 1) {
	        return function Promise$_thrower() {
	            throw value;
	        };
	    } else if (action === 2) {
	        return function Promise$_returner() {
	            return value;
	        };
	    }
	};


	Promise.prototype["return"] =
	Promise.prototype.thenReturn =
	function Promise$thenReturn(value) {
	    if (wrapsPrimitiveReceiver && isPrimitive(value)) {
	        return this._then(
	            wrapper(value, 2),
	            void 0,
	            void 0,
	            void 0,
	            void 0
	       );
	    }
	    return this._then(returner, void 0, void 0, value, void 0);
	};

	Promise.prototype["throw"] =
	Promise.prototype.thenThrow =
	function Promise$thenThrow(reason) {
	    if (wrapsPrimitiveReceiver && isPrimitive(reason)) {
	        return this._then(
	            wrapper(reason, 1),
	            void 0,
	            void 0,
	            void 0,
	            void 0
	       );
	    }
	    return this._then(thrower, void 0, void 0, reason, void 0);
	};
	};


/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== void 0) {
	        this._bitField = promise._bitField;
	        this._settledValue = promise.isResolved()
	            ? promise._settledValue
	            : void 0;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValue = void 0;
	    }
	}

	PromiseInspection.prototype.isFulfilled =
	Promise.prototype.isFulfilled = function Promise$isFulfilled() {
	    return (this._bitField & 268435456) > 0;
	};

	PromiseInspection.prototype.isRejected =
	Promise.prototype.isRejected = function Promise$isRejected() {
	    return (this._bitField & 134217728) > 0;
	};

	PromiseInspection.prototype.isPending =
	Promise.prototype.isPending = function Promise$isPending() {
	    return (this._bitField & 402653184) === 0;
	};

	PromiseInspection.prototype.value =
	Promise.prototype.value = function Promise$value() {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise");
	    }
	    return this._settledValue;
	};

	PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason =
	Promise.prototype.reason = function Promise$reason() {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise");
	    }
	    return this._settledValue;
	};

	PromiseInspection.prototype.isResolved =
	Promise.prototype.isResolved = function Promise$isResolved() {
	    return (this._bitField & 402653184) > 0;
	};

	Promise.PromiseInspection = PromiseInspection;
	};


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports =
	function(Promise, PromiseArray, cast, INTERNAL) {
	var util = __webpack_require__(31);
	var canEvaluate = util.canEvaluate;
	var tryCatch1 = util.tryCatch1;
	var errorObj = util.errorObj;


	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };

	    var caller = function(count) {
	        var values = [];
	        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
	        return new Function("holder", "                                      \n\
	            'use strict';                                                    \n\
	            var callback = holder.fn;                                        \n\
	            return callback(values);                                         \n\
	            ".replace(/values/g, values.join(", ")));
	    };
	    var thenCallbacks = [];
	    var callers = [void 0];
	    for (var i = 1; i <= 5; ++i) {
	        thenCallbacks.push(thenCallback(i));
	        callers.push(caller(i));
	    }

	    var Holder = function(total, fn) {
	        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
	        this.fn = fn;
	        this.total = total;
	        this.now = 0;
	    };

	    Holder.prototype.callers = callers;
	    Holder.prototype.checkFulfillment = function(promise) {
	        var now = this.now;
	        now++;
	        var total = this.total;
	        if (now >= total) {
	            var handler = this.callers[total];
	            var ret = tryCatch1(handler, void 0, this);
	            if (ret === errorObj) {
	                promise._rejectUnchecked(ret.e);
	            } else if (!promise._tryFollow(ret)) {
	                promise._fulfillUnchecked(ret);
	            }
	        } else {
	            this.now = now;
	        }
	    };
	}




	Promise.join = function Promise$Join() {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (last < 6 && canEvaluate) {
	            var ret = new Promise(INTERNAL);
	            ret._setTrace(void 0);
	            var holder = new Holder(last, fn);
	            var reject = ret._reject;
	            var callbacks = thenCallbacks;
	            for (var i = 0; i < last; ++i) {
	                var maybePromise = cast(arguments[i], void 0);
	                if (maybePromise instanceof Promise) {
	                    if (maybePromise.isPending()) {
	                        maybePromise._then(callbacks[i], reject,
	                                           void 0, ret, holder);
	                    } else if (maybePromise.isFulfilled()) {
	                        callbacks[i].call(ret,
	                                          maybePromise._settledValue, holder);
	                    } else {
	                        ret._reject(maybePromise._settledValue);
	                        maybePromise._unsetRejectionIsUnhandled();
	                    }
	                } else {
	                    callbacks[i].call(ret, maybePromise, holder);
	                }
	            }
	            return ret;
	        }
	    }
	    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
	    var ret = new PromiseArray(args).promise();
	    return fn !== void 0 ? ret.spread(fn) : ret;
	};

	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	var _setTimeout = function(fn, ms) {
	    var len = arguments.length;
	    var arg0 = arguments[2];
	    var arg1 = arguments[3];
	    var arg2 = len >= 5 ? arguments[4] : void 0;
	    setTimeout(function() {
	        fn(arg0, arg1, arg2);
	    }, ms);
	};

	module.exports = function(Promise, INTERNAL, cast) {
	var util = __webpack_require__(31);
	var errors = __webpack_require__(36);
	var apiRejection = __webpack_require__(42)(Promise);
	var TimeoutError = Promise.TimeoutError;

	var afterTimeout = function Promise$_afterTimeout(promise, message, ms) {
	    if (!promise.isPending()) return;
	    if (typeof message !== "string") {
	        message = "operation timed out after" + " " + ms + " ms"
	    }
	    var err = new TimeoutError(message);
	    errors.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._cancel(err);
	};

	var afterDelay = function Promise$_afterDelay(value, promise) {
	    promise._fulfill(value);
	};

	var delay = Promise.delay = function Promise$Delay(value, ms) {
	    if (ms === void 0) {
	        ms = value;
	        value = void 0;
	    }
	    ms = +ms;
	    var maybePromise = cast(value, void 0);
	    var promise = new Promise(INTERNAL);

	    if (maybePromise instanceof Promise) {
	        promise._propagateFrom(maybePromise, 7);
	        promise._follow(maybePromise);
	        return promise.then(function(value) {
	            return Promise.delay(value, ms);
	        });
	    } else {
	        promise._setTrace(void 0);
	        _setTimeout(afterDelay, ms, value, promise);
	    }
	    return promise;
	};

	Promise.prototype.delay = function Promise$delay(ms) {
	    return delay(this, ms);
	};

	Promise.prototype.timeout = function Promise$timeout(ms, message) {
	    ms = +ms;

	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 7);
	    ret._follow(this);
	    _setTimeout(afterTimeout, ms, ret, message, ms);
	    return ret.cancellable();
	};

	};


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, INTERNAL, cast) {
	var apiRejection = __webpack_require__(42)(Promise);
	var isArray = __webpack_require__(31).isArray;

	var raceLater = function Promise$_raceLater(promise) {
	    return promise.then(function(array) {
	        return Promise$_Race(array, promise);
	    });
	};

	var hasOwn = {}.hasOwnProperty;
	function Promise$_Race(promises, parent) {
	    var maybePromise = cast(promises, void 0);

	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else if (!isArray(promises)) {
	        return apiRejection("expecting an array, a promise or a thenable");
	    }

	    var ret = new Promise(INTERNAL);
	    if (parent !== void 0) {
	        ret._propagateFrom(parent, 7);
	    } else {
	        ret._setTrace(void 0);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];

	        if (val === void 0 && !(hasOwn.call(promises, i))) {
	            continue;
	        }

	        Promise.cast(val)._then(fulfill, reject, void 0, ret, null);
	    }
	    return ret;
	}

	Promise.race = function Promise$Race(promises) {
	    return Promise$_Race(promises, void 0);
	};

	Promise.prototype.race = function Promise$race() {
	    return Promise$_Race(this, void 0);
	};

	};


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	var cr = Object.create;
	var callerCache = cr && cr(null);
	var getterCache = cr && cr(null);
	callerCache[" size"] = getterCache[" size"] = 0;
	module.exports = function(Promise) {
	var util = __webpack_require__(31);
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;

	function makeMethodCaller (methodName) {
	    return new Function("obj", "                                             \n\
	        'use strict'                                                         \n\
	        var len = this.length;                                               \n\
	        switch(len) {                                                        \n\
	            case 1: return obj.methodName(this[0]);                          \n\
	            case 2: return obj.methodName(this[0], this[1]);                 \n\
	            case 3: return obj.methodName(this[0], this[1], this[2]);        \n\
	            case 0: return obj.methodName();                                 \n\
	            default: return obj.methodName.apply(obj, this);                 \n\
	        }                                                                    \n\
	        ".replace(/methodName/g, methodName));
	}

	function makeGetter (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	}

	function getCompiled(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	}

	function getMethodCaller(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	}

	function getGetter(name) {
	    return getCompiled(name, makeGetter, getterCache);
	}

	function caller(obj) {
	    return obj[this.pop()].apply(obj, this);
	}
	Promise.prototype.call = function Promise$call(methodName) {
	    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	    if (canEvaluate) {
	        var maybeCaller = getMethodCaller(methodName);
	        if (maybeCaller !== null) {
	            return this._then(maybeCaller, void 0, void 0, args, void 0);
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, void 0, void 0, args, void 0);
	};

	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    return obj[this];
	}
	Promise.prototype.get = function Promise$get(propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, void 0, void 0, propertyName, void 0);
	};
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, apiRejection, INTERNAL, cast) {
	var errors = __webpack_require__(36);
	var TypeError = errors.TypeError;
	var deprecated = __webpack_require__(31).deprecated;
	var util = __webpack_require__(31);
	var errorObj = util.errorObj;
	var tryCatch1 = util.tryCatch1;
	var yieldHandlers = [];

	function promiseFromYieldHandler(value, yieldHandlers) {
	    var _errorObj = errorObj;
	    var _Promise = Promise;
	    var len = yieldHandlers.length;
	    for (var i = 0; i < len; ++i) {
	        var result = tryCatch1(yieldHandlers[i], void 0, value);
	        if (result === _errorObj) {
	            return _Promise.reject(_errorObj.e);
	        }
	        var maybePromise = cast(result, promiseFromYieldHandler);
	        if (maybePromise instanceof _Promise) return maybePromise;
	    }
	    return null;
	}

	function PromiseSpawn(generatorFunction, receiver, yieldHandler) {
	    var promise = this._promise = new Promise(INTERNAL);
	    promise._setTrace(void 0);
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = void 0;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	}

	PromiseSpawn.prototype.promise = function PromiseSpawn$promise() {
	    return this._promise;
	};

	PromiseSpawn.prototype._run = function PromiseSpawn$_run() {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = void 0;
	    this._next(void 0);
	};

	PromiseSpawn.prototype._continue = function PromiseSpawn$_continue(result) {
	    if (result === errorObj) {
	        this._generator = void 0;
	        var trace = errors.canAttach(result.e)
	            ? result.e : new Error(result.e + "");
	        this._promise._attachExtraTrace(trace);
	        this._promise._reject(result.e, trace);
	        return;
	    }

	    var value = result.value;
	    if (result.done === true) {
	        this._generator = void 0;
	        if (!this._promise._tryFollow(value)) {
	            this._promise._fulfill(value);
	        }
	    } else {
	        var maybePromise = cast(value, void 0);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise, this._yieldHandlers);
	            if (maybePromise === null) {
	                this._throw(new TypeError("A value was yielded that could not be treated as a promise"));
	                return;
	            }
	        }
	        maybePromise._then(
	            this._next,
	            this._throw,
	            void 0,
	            this,
	            null
	       );
	    }
	};

	PromiseSpawn.prototype._throw = function PromiseSpawn$_throw(reason) {
	    if (errors.canAttach(reason))
	        this._promise._attachExtraTrace(reason);
	    this._continue(
	        tryCatch1(this._generator["throw"], this._generator, reason)
	   );
	};

	PromiseSpawn.prototype._next = function PromiseSpawn$_next(value) {
	    this._continue(
	        tryCatch1(this._generator.next, this._generator, value)
	   );
	};

	Promise.coroutine =
	function Promise$Coroutine(generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(void 0, void 0, yieldHandler);
	        spawn._generator = generator;
	        spawn._next(void 0);
	        return spawn.promise();
	    };
	};

	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function");
	    yieldHandlers.push(fn);
	};

	Promise.spawn = function Promise$Spawn(generatorFunction) {
	    deprecated("Promise.spawn is deprecated. Use Promise.coroutine instead.");
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, PromiseArray, apiRejection, cast, INTERNAL) {
	var util = __webpack_require__(31);
	var tryCatch3 = util.tryCatch3;
	var errorObj = util.errorObj;
	var PENDING = {};
	var EMPTY_ARRAY = [];

	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._callback = fn;
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
	    this._init$(void 0, -2);
	}
	util.inherits(MappingPromiseArray, PromiseArray);

	MappingPromiseArray.prototype._init = function MappingPromiseArray$_init() {};

	MappingPromiseArray.prototype._promiseFulfilled =
	function MappingPromiseArray$_promiseFulfilled(value, index) {
	    var values = this._values;
	    if (values === null) return;

	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	    if (values[index] === PENDING) {
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;

	        var callback = this._callback;
	        var receiver = this._promise._boundTo;
	        var ret = tryCatch3(callback, receiver, value, index, length);
	        if (ret === errorObj) return this._reject(ret.e);

	        var maybePromise = cast(ret, void 0);
	        if (maybePromise instanceof Promise) {
	            if (maybePromise.isPending()) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = PENDING;
	                return maybePromise._proxyPromiseArray(this, index);
	            } else if (maybePromise.isFulfilled()) {
	                ret = maybePromise.value();
	            } else {
	                maybePromise._unsetRejectionIsUnhandled();
	                return this._reject(maybePromise.reason());
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }

	    }
	};

	MappingPromiseArray.prototype._drainQueue =
	function MappingPromiseArray$_drainQueue() {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};

	MappingPromiseArray.prototype._filter =
	function MappingPromiseArray$_filter(booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};

	MappingPromiseArray.prototype.preservedValues =
	function MappingPromiseArray$preserveValues() {
	    return this._preservedValues;
	};

	function map(promises, fn, options, _filter) {
	    var limit = typeof options === "object" && options !== null
	        ? options.concurrency
	        : 0;
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter);
	}

	Promise.prototype.map = function Promise$map(fn, options) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function");

	    return map(this, fn, options, null).promise();
	};

	Promise.map = function Promise$Map(promises, fn, options, _filter) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function");
	    return map(promises, fn, options, _filter).promise();
	};


	};


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise) {
	var util = __webpack_require__(31);
	var async = __webpack_require__(33);
	var tryCatch2 = util.tryCatch2;
	var tryCatch1 = util.tryCatch1;
	var errorObj = util.errorObj;

	function thrower(r) {
	    throw r;
	}

	function Promise$_spreadAdapter(val, receiver) {
	    if (!util.isArray(val)) return Promise$_successAdapter(val, receiver);
	    var ret = util.tryCatchApply(this, [null].concat(val), receiver);
	    if (ret === errorObj) {
	        async.invokeLater(thrower, void 0, ret.e);
	    }
	}

	function Promise$_successAdapter(val, receiver) {
	    var nodeback = this;
	    var ret = val === void 0
	        ? tryCatch1(nodeback, receiver, null)
	        : tryCatch2(nodeback, receiver, null, val);
	    if (ret === errorObj) {
	        async.invokeLater(thrower, void 0, ret.e);
	    }
	}
	function Promise$_errorAdapter(reason, receiver) {
	    var nodeback = this;
	    var ret = tryCatch1(nodeback, receiver, reason);
	    if (ret === errorObj) {
	        async.invokeLater(thrower, void 0, ret.e);
	    }
	}

	Promise.prototype.nodeify = function Promise$nodeify(nodeback, options) {
	    if (typeof nodeback == "function") {
	        var adapter = Promise$_successAdapter;
	        if (options !== void 0 && Object(options).spread) {
	            adapter = Promise$_spreadAdapter;
	        }
	        this._then(
	            adapter,
	            Promise$_errorAdapter,
	            void 0,
	            nodeback,
	            this._boundTo
	        );
	    }
	    return this;
	};
	};


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = __webpack_require__(31);
	var nodebackForPromise = __webpack_require__(41)
	    ._nodebackForPromise;
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = __webpack_require__(36).TypeError;
	var defaultSuffix = "Async";
	var defaultFilter = function(name, func) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        !util.isClass(func);
	};
	var defaultPromisified = {__isPromisified__: true};


	function escapeIdentRegex(str) {
	    return str.replace(/([$])/, "\\$");
	}

	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}

	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API " +
	                        "that has normal methods with '"+suffix+"'-suffix");
	                }
	            }
	        }
	    }
	}

	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}

	function switchCaseArgumentOrder(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 5);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        if (i === likelyArgumentCount) continue;
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 5; ++i) {
	        ret.push(i);
	    }
	    return ret;
	}

	function argumentSequence(argumentCount) {
	    return util.filledRange(argumentCount, "arguments[", "]");
	}

	function parameterDeclaration(parameterCount) {
	    return util.filledRange(parameterCount, "_arg", "");
	}

	function parameterCount(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	}

	function generatePropertyAccess(key) {
	    if (util.isIdentifier(key)) {
	        return "." + key;
	    }
	    else return "['" + key.replace(/(['\\])/g, "\\$1") + "']";
	}

	function makeNodePromisifiedEval(callback, receiver, originalName, fn, suffix) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var callbackName =
	        (typeof originalName === "string" && util.isIdentifier(originalName)
	            ? originalName + suffix
	            : "promisified");

	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (typeof callback === "string") {
	            ret = "                                                          \n\
	                this.method(args, fn);                                       \n\
	                break;                                                       \n\
	            ".replace(".method", generatePropertyAccess(callback));
	        } else if (receiver === THIS) {
	            ret =  "                                                         \n\
	                callback.call(this, args, fn);                               \n\
	                break;                                                       \n\
	            ";
	        } else if (receiver !== void 0) {
	            ret =  "                                                         \n\
	                callback.call(receiver, args, fn);                           \n\
	                break;                                                       \n\
	            ";
	        } else {
	            ret =  "                                                         \n\
	                callback(args, fn);                                          \n\
	                break;                                                       \n\
	            ";
	        }
	        return ret.replace("args", args).replace(", ", comma);
	    }

	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for(var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }
	        var codeForCall;
	        if (typeof callback === "string") {
	            codeForCall = "                                                  \n\
	                this.property.apply(this, args);                             \n\
	            "
	                .replace(".property", generatePropertyAccess(callback));
	        } else if (receiver === THIS) {
	            codeForCall = "                                                  \n\
	                callback.apply(this, args);                                  \n\
	            ";
	        } else {
	            codeForCall = "                                                  \n\
	                callback.apply(receiver, args);                              \n\
	            ";
	        }

	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = fn;                                                    \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", codeForCall);
	        return ret;
	    }

	    return new Function("Promise",
	                        "callback",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "INTERNAL","                                         \n\
	        var ret = function FunctionName(Parameters) {                        \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._setTrace(void 0);                                       \n\
	            var fn = nodebackForPromise(promise);                            \n\
	            try {                                                            \n\
	                switch(len) {                                                \n\
	                    [CodeForSwitchCase]                                      \n\
	                }                                                            \n\
	            } catch (e) {                                                    \n\
	                var wrapped = maybeWrapAsError(e);                           \n\
	                promise._attachExtraTrace(wrapped);                          \n\
	                promise._reject(wrapped);                                    \n\
	            }                                                                \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        ret.__isPromisified__ = true;                                        \n\
	        return ret;                                                          \n\
	        "
	        .replace("FunctionName", callbackName)
	        .replace("Parameters", parameterDeclaration(newParameterCount))
	        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase()))(
	            Promise,
	            callback,
	            receiver,
	            withAppended,
	            maybeWrapAsError,
	            nodebackForPromise,
	            INTERNAL
	        );
	}

	function makeNodePromisifiedClosure(callback, receiver) {
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        if (typeof callback === "string") {
	            callback = _receiver[callback];
	        }
	        var promise = new Promise(INTERNAL);
	        promise._setTrace(void 0);
	        var fn = nodebackForPromise(promise);
	        try {
	            callback.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            var wrapped = maybeWrapAsError(e);
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        }
	        return promise;
	    }
	    promisified.__isPromisified__ = true;
	    return promisified;
	}

	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;

	function promisifyAll(obj, suffix, filter, promisifier) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);

	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        obj[promisifiedKey] = promisifier === makeNodePromisified
	                ? makeNodePromisified(key, THIS, key, fn, suffix)
	                : promisifier(fn);
	    }
	    util.toFastProperties(obj);
	    return obj;
	}

	function promisify(callback, receiver) {
	    return makeNodePromisified(callback, receiver, void 0, callback);
	}

	Promise.promisify = function Promise$Promisify(fn, receiver) {
	    if (typeof fn !== "function") {
	        throw new TypeError("fn must be a function");
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    return promisify(fn, arguments.length < 2 ? THIS : receiver);
	};

	Promise.promisifyAll = function Promise$PromisifyAll(target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function");
	    }
	    options = Object(options);
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier");
	    }

	    var keys = util.inheritedDataKeys(target, {includeHidden: true});
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier);
	            promisifyAll(value, suffix, filter, promisifier);
	        }
	    }

	    return promisifyAll(target, suffix, filter, promisifier);
	};
	};



/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, PromiseArray, cast) {
	var util = __webpack_require__(31);
	var apiRejection = __webpack_require__(42)(Promise);
	var isObject = util.isObject;
	var es5 = __webpack_require__(32);

	function PropertiesPromiseArray(obj) {
	    var keys = es5.keys(obj);
	    var len = keys.length;
	    var values = new Array(len * 2);
	    for (var i = 0; i < len; ++i) {
	        var key = keys[i];
	        values[i] = obj[key];
	        values[i + len] = key;
	    }
	    this.constructor$(values);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);

	PropertiesPromiseArray.prototype._init =
	function PropertiesPromiseArray$_init() {
	    this._init$(void 0, -3) ;
	};

	PropertiesPromiseArray.prototype._promiseFulfilled =
	function PropertiesPromiseArray$_promiseFulfilled(value, index) {
	    if (this._isResolved()) return;
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val = {};
	        var keyOffset = this.length();
	        for (var i = 0, len = this.length(); i < len; ++i) {
	            val[this._values[i + keyOffset]] = this._values[i];
	        }
	        this._resolve(val);
	    }
	};

	PropertiesPromiseArray.prototype._promiseProgressed =
	function PropertiesPromiseArray$_promiseProgressed(value, index) {
	    if (this._isResolved()) return;

	    this._promise._progress({
	        key: this._values[index + this.length()],
	        value: value
	    });
	};

	PropertiesPromiseArray.prototype.shouldCopyValues =
	function PropertiesPromiseArray$_shouldCopyValues() {
	    return false;
	};

	PropertiesPromiseArray.prototype.getActualLength =
	function PropertiesPromiseArray$getActualLength(len) {
	    return len >> 1;
	};

	function Promise$_Props(promises) {
	    var ret;
	    var castValue = cast(promises, void 0);

	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(Promise.props, void 0, void 0, void 0, void 0);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }

	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 4);
	    }
	    return ret;
	}

	Promise.prototype.props = function Promise$props() {
	    return Promise$_Props(this);
	};

	Promise.props = function Promise$Props(promises) {
	    return Promise$_Props(promises);
	};
	};


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, PromiseArray, apiRejection, cast, INTERNAL) {
	var util = __webpack_require__(31);
	var tryCatch4 = util.tryCatch4;
	var tryCatch3 = util.tryCatch3;
	var errorObj = util.errorObj;
	var PENDING = {};
	function ReductionPromiseArray(promises, fn, accum, _each) {
	    this.constructor$(promises);
	    var currentIndex = -2;
	    this._preservedValues = _each === INTERNAL ? [] : null;
	    var maybePromise = cast(accum, void 0);
	    var rejected = false;
	    var isPromise = maybePromise instanceof Promise;
	    if (isPromise) {
	        if (maybePromise.isPending()) {
	            currentIndex = -1;
	            maybePromise._proxyPromiseArray(this, -1);
	        } else if (maybePromise.isFulfilled()) {
	            accum = maybePromise.value();
	            currentIndex = 0;
	        } else {
	            maybePromise._unsetRejectionIsUnhandled();
	            this._reject(maybePromise.reason());
	            rejected = true;
	        }
	    }
	    if (!isPromise && accum !== void 0) currentIndex = 0;
	    this._callback = fn;
	    this._currentIndex = currentIndex;
	    this._accum = accum;
	    if (!rejected) this._init$(void 0, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);

	ReductionPromiseArray.prototype._init =
	function ReductionPromiseArray$_init() {};

	ReductionPromiseArray.prototype._resolveEmptyArray =
	function ReductionPromiseArray$_resolveEmptyArray() {
	    if (this._currentIndex !== -1) {
	        this._resolve(this._preservedValues !== null
	                        ? [] : this._accum);
	    }
	};

	ReductionPromiseArray.prototype._promiseFulfilled =
	function ReductionPromiseArray$_promiseFulfilled(value, index) {
	    var accum;
	    var values = this._values;
	    if (values === null) return;
	    var length = this.length();
	    var currentIndex = this._currentIndex;
	    if (currentIndex > index) return;
	    var preservedValues = this._preservedValues;
	    var isEach = preservedValues !== null;
	    if (index === 0 && currentIndex === -2) {
	        accum = value;
	        currentIndex = 1;
	        if (length < 2) return this._resolve(void 0);
	        value = values[1];
	    } else if (index > currentIndex) {
	        return;
	    } else if (index === -1 || values[index] === PENDING) {
	        accum = value;
	        currentIndex++;
	        if (currentIndex >= length)
	            return this._resolve(isEach ? preservedValues : accum);
	        value = values[currentIndex];
	    } else {
	        accum = this._accum;
	    }

	    var callback = this._callback;
	    var receiver = this._promise._boundTo;
	    var ret;

	    for (var i = currentIndex; i < length; ++i) {
	        if (i > currentIndex) value = values[i];

	        if (value instanceof Promise) {
	            if (value.isFulfilled()) {
	                value = value._settledValue;
	            } else if (value.isPending()) {
	                this._accum = accum;
	                this._currentIndex = i;
	                return;
	            } else {
	                value._unsetRejectionIsUnhandled();
	                return this._reject(value.reason());
	            }
	        }

	        if (isEach) {
	            preservedValues.push(value);
	            ret = tryCatch3(callback, receiver, value, i, length);
	        }
	        else {
	            ret = tryCatch4(callback, receiver, accum, value, i, length);
	        }

	        if (ret === errorObj) return this._reject(ret.e);

	        var maybePromise = cast(ret, void 0);
	        if (maybePromise instanceof Promise) {
	            if (maybePromise.isPending()) {
	                values[i] = PENDING;
	                this._accum = accum;
	                this._currentIndex = i;
	                return maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise.isFulfilled()) {
	                ret = maybePromise.value();
	            } else {
	                maybePromise._unsetRejectionIsUnhandled();
	                return this._reject(maybePromise.reason());
	            }
	        }
	        accum = ret;
	    }
	    this._resolve(isEach ? preservedValues : accum);
	};

	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function");
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}

	Promise.prototype.reduce = function Promise$reduce(fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};

	Promise.reduce = function Promise$Reduce(promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	};


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports =
	    function(Promise, PromiseArray) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = __webpack_require__(31);

	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);

	SettledPromiseArray.prototype._promiseResolved =
	function SettledPromiseArray$_promiseResolved(index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};

	SettledPromiseArray.prototype._promiseFulfilled =
	function SettledPromiseArray$_promiseFulfilled(value, index) {
	    if (this._isResolved()) return;
	    var ret = new PromiseInspection();
	    ret._bitField = 268435456;
	    ret._settledValue = value;
	    this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected =
	function SettledPromiseArray$_promiseRejected(reason, index) {
	    if (this._isResolved()) return;
	    var ret = new PromiseInspection();
	    ret._bitField = 134217728;
	    ret._settledValue = reason;
	    this._promiseResolved(index, ret);
	};

	Promise.settle = function Promise$Settle(promises) {
	    return new SettledPromiseArray(promises).promise();
	};

	Promise.prototype.settle = function Promise$settle() {
	    return new SettledPromiseArray(this).promise();
	};
	};


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = __webpack_require__(31);
	var RangeError = __webpack_require__(36).RangeError;
	var AggregateError = __webpack_require__(36).AggregateError;
	var isArray = util.isArray;


	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);

	SomePromiseArray.prototype._init = function SomePromiseArray$_init() {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(void 0, -2);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        var message = "(Promise.some) input array contains less than " +
	                        this._howMany  + " promises";
	        this._reject(new RangeError(message));
	    }
	};

	SomePromiseArray.prototype.init = function SomePromiseArray$init() {
	    this._initialized = true;
	    this._init();
	};

	SomePromiseArray.prototype.setUnwrap = function SomePromiseArray$setUnwrap() {
	    this._unwrap = true;
	};

	SomePromiseArray.prototype.howMany = function SomePromiseArray$howMany() {
	    return this._howMany;
	};

	SomePromiseArray.prototype.setHowMany =
	function SomePromiseArray$setHowMany(count) {
	    if (this._isResolved()) return;
	    this._howMany = count;
	};

	SomePromiseArray.prototype._promiseFulfilled =
	function SomePromiseArray$_promiseFulfilled(value) {
	    if (this._isResolved()) return;
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	    }

	};
	SomePromiseArray.prototype._promiseRejected =
	function SomePromiseArray$_promiseRejected(reason) {
	    if (this._isResolved()) return;
	    this._addRejected(reason);
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            e.push(this._values[i]);
	        }
	        this._reject(e);
	    }
	};

	SomePromiseArray.prototype._fulfilled = function SomePromiseArray$_fulfilled() {
	    return this._totalResolved;
	};

	SomePromiseArray.prototype._rejected = function SomePromiseArray$_rejected() {
	    return this._values.length - this.length();
	};

	SomePromiseArray.prototype._addRejected =
	function SomePromiseArray$_addRejected(reason) {
	    this._values.push(reason);
	};

	SomePromiseArray.prototype._addFulfilled =
	function SomePromiseArray$_addFulfilled(value) {
	    this._values[this._totalResolved++] = value;
	};

	SomePromiseArray.prototype._canPossiblyFulfill =
	function SomePromiseArray$_canPossiblyFulfill() {
	    return this.length() - this._rejected();
	};

	function Promise$_Some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    if (promise.isRejected()) {
	        return promise;
	    }
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}

	Promise.some = function Promise$Some(promises, howMany) {
	    return Promise$_Some(promises, howMany);
	};

	Promise.prototype.some = function Promise$some(howMany) {
	    return Promise$_Some(this, howMany);
	};

	Promise._SomePromiseArray = SomePromiseArray;
	};


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, PromiseArray) {
	var util = __webpack_require__(31);
	var async = __webpack_require__(33);
	var errors = __webpack_require__(36);
	var tryCatch1 = util.tryCatch1;
	var errorObj = util.errorObj;

	Promise.prototype.progressed = function Promise$progressed(handler) {
	    return this._then(void 0, void 0, handler, void 0, void 0);
	};

	Promise.prototype._progress = function Promise$_progress(progressValue) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._progressUnchecked(progressValue);

	};

	Promise.prototype._progressHandlerAt =
	function Promise$_progressHandlerAt(index) {
	    return index === 0
	        ? this._progressHandler0
	        : this[(index << 2) + index - 5 + 2];
	};

	Promise.prototype._doProgressWith =
	function Promise$_doProgressWith(progression) {
	    var progressValue = progression.value;
	    var handler = progression.handler;
	    var promise = progression.promise;
	    var receiver = progression.receiver;

	    var ret = tryCatch1(handler, receiver, progressValue);
	    if (ret === errorObj) {
	        if (ret.e != null &&
	            ret.e.name !== "StopProgressPropagation") {
	            var trace = errors.canAttach(ret.e)
	                ? ret.e : new Error(ret.e + "");
	            promise._attachExtraTrace(trace);
	            promise._progress(ret.e);
	        }
	    } else if (ret instanceof Promise) {
	        ret._then(promise._progress, null, null, promise, void 0);
	    } else {
	        promise._progress(ret);
	    }
	};


	Promise.prototype._progressUnchecked =
	function Promise$_progressUnchecked(progressValue) {
	    if (!this.isPending()) return;
	    var len = this._length();
	    var progress = this._progress;
	    for (var i = 0; i < len; i++) {
	        var handler = this._progressHandlerAt(i);
	        var promise = this._promiseAt(i);
	        if (!(promise instanceof Promise)) {
	            var receiver = this._receiverAt(i);
	            if (typeof handler === "function") {
	                handler.call(receiver, progressValue, promise);
	            } else if (receiver instanceof Promise && receiver._isProxied()) {
	                receiver._progressUnchecked(progressValue);
	            } else if (receiver instanceof PromiseArray) {
	                receiver._promiseProgressed(progressValue, promise);
	            }
	            continue;
	        }

	        if (typeof handler === "function") {
	            async.invoke(this._doProgressWith, this, {
	                handler: handler,
	                promise: promise,
	                receiver: this._receiverAt(i),
	                value: progressValue
	            });
	        } else {
	            async.invoke(progress, promise, progressValue);
	        }
	    }
	};
	};


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var errors = __webpack_require__(36);
	var canAttach = errors.canAttach;
	var async = __webpack_require__(33);
	var CancellationError = errors.CancellationError;

	Promise.prototype._cancel = function Promise$_cancel(reason) {
	    if (!this.isCancellable()) return this;
	    var parent;
	    var promiseToReject = this;
	    while ((parent = promiseToReject._cancellationParent) !== void 0 &&
	        parent.isCancellable()) {
	        promiseToReject = parent;
	    }
	    promiseToReject._attachExtraTrace(reason);
	    promiseToReject._rejectUnchecked(reason);
	};

	Promise.prototype.cancel = function Promise$cancel(reason) {
	    if (!this.isCancellable()) return this;
	    reason = reason !== void 0
	        ? (canAttach(reason) ? reason : new Error(reason + ""))
	        : new CancellationError();
	    async.invokeLater(this._cancel, this, reason);
	    return this;
	};

	Promise.prototype.cancellable = function Promise$cancellable() {
	    if (this._cancellable()) return this;
	    this._setCancellable();
	    this._cancellationParent = void 0;
	    return this;
	};

	Promise.prototype.uncancellable = function Promise$uncancellable() {
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 2 | 4);
	    ret._follow(this);
	    ret._unsetCancellable();
	    return ret;
	};

	Promise.prototype.fork =
	function Promise$fork(didFulfill, didReject, didProgress) {
	    var ret = this._then(didFulfill, didReject, didProgress,
	                         void 0, void 0);

	    ret._setCancellable();
	    ret._cancellationParent = void 0;
	    return ret;
	};
	};


/***/ },
/* 60 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;

	Promise.prototype.filter = function Promise$filter(fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};

	Promise.filter = function Promise$Filter(promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};


/***/ },
/* 61 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function Promise$_Any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    if (promise.isRejected()) {
	        return promise;
	    }
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}

	Promise.any = function Promise$Any(promises) {
	    return Promise$_Any(promises);
	};

	Promise.prototype.any = function Promise$any() {
	    return Promise$_Any(this);
	};

	};


/***/ },
/* 62 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;

	Promise.prototype.each = function Promise$each(fn) {
	    return PromiseReduce(this, fn, null, INTERNAL);
	};

	Promise.each = function Promise$Each(promises, fn) {
	    return PromiseReduce(promises, fn, null, INTERNAL);
	};
	};


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	"use strict";
	module.exports = function (Promise, apiRejection, cast) {
	    var TypeError = __webpack_require__(36).TypeError;
	    var inherits = __webpack_require__(31).inherits;
	    var PromiseInspection = Promise.PromiseInspection;

	    function inspectionMapper(inspections) {
	        var len = inspections.length;
	        for (var i = 0; i < len; ++i) {
	            var inspection = inspections[i];
	            if (inspection.isRejected()) {
	                return Promise.reject(inspection.error());
	            }
	            inspections[i] = inspection.value();
	        }
	        return inspections;
	    }

	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }

	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = Promise.defer();
	        function iterator() {
	            if (i >= len) return ret.resolve();
	            var maybePromise = cast(resources[i++], void 0);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = cast(maybePromise._getDisposer()
	                                        .tryDispose(inspection), void 0);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret.promise;
	    }

	    function disposerSuccess(value) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = value;
	        inspection._bitField = 268435456;
	        return dispose(this, inspection).thenReturn(value);
	    }

	    function disposerFail(reason) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = reason;
	        inspection._bitField = 134217728;
	        return dispose(this, inspection).thenThrow(reason);
	    }

	    function Disposer(data, promise) {
	        this._data = data;
	        this._promise = promise;
	    }

	    Disposer.prototype.data = function Disposer$data() {
	        return this._data;
	    };

	    Disposer.prototype.promise = function Disposer$promise() {
	        return this._promise;
	    };

	    Disposer.prototype.resource = function Disposer$resource() {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return null;
	    };

	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var ret = resource !== null
	            ? this.doDispose(resource, inspection) : null;
	        this._promise._unsetDisposable();
	        this._data = this._promise = null;
	        return ret;
	    };

	    function FunctionDisposer(fn, promise) {
	        this.constructor$(fn, promise);
	    }
	    inherits(FunctionDisposer, Disposer);

	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };

	    Promise.using = function Promise$using() {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") return apiRejection("fn must be a function");
	        len--;
	        var resources = new Array(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = arguments[i];
	            if (resource instanceof Disposer) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            }
	            resources[i] = resource;
	        }

	        return Promise.settle(resources)
	            .then(inspectionMapper)
	            .spread(fn)
	            ._then(disposerSuccess, disposerFail, void 0, resources, void 0);
	    };

	    Promise.prototype._setDisposable =
	    function Promise$_setDisposable(disposer) {
	        this._bitField = this._bitField | 262144;
	        this._disposer = disposer;
	    };

	    Promise.prototype._isDisposable = function Promise$_isDisposable() {
	        return (this._bitField & 262144) > 0;
	    };

	    Promise.prototype._getDisposer = function Promise$_getDisposer() {
	        return this._disposer;
	    };

	    Promise.prototype._unsetDisposable = function Promise$_unsetDisposable() {
	        this._bitField = this._bitField & (~262144);
	        this._disposer = void 0;
	    };

	    Promise.prototype.disposer = function Promise$disposer(fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this);
	        }
	        throw new TypeError();
	    };

	};


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(65);
	var schemaUtil = __webpack_require__(67);
	var Document = __webpack_require__(80);
	var EventEmitter = __webpack_require__(8).EventEmitter;
	var Query = __webpack_require__(81);
	var Promise = __webpack_require__(29);
	var Errors = __webpack_require__(66);

	/*
	 * Constructor for a Model. Note that this is not what `thinky.createModel`
	 * returns. It is the prototype of what `thinky.createModel` returns.
	 * The whole chain being:
	 * document.__proto__ = new Document(...)
	 * document.__proto__.constructor = model (returned by thinky.createModel
	 * document.__proto__._model = instance of Model
	 * document.__proto__.constructor.__proto__ = document.__proto__._model
	 */
	function Model(name, schema, options, thinky) {
	  /**
	   * Name of the table used
	   * @type {string}
	   */
	  this._name = name;

	  // We want a deep copy
	  options = options || {};
	  this._options = {};
	  this._options.enforce_missing = (options.enforce_missing != null) ? options.enforce_missing : thinky._options.enforce_missing;
	  this._options.enforce_extra = (options.enforce_extra != null) ? options.enforce_extra : thinky._options.enforce_extra;
	  this._options.enforce_type = (options.enforce_type != null) ? options.enforce_type : thinky._options.enforce_type;
	  this._options.timeFormat = (options.timeFormat != null) ? options.timeFormat : thinky._options.timeFormat;
	  this._options.validate = (options.validate != null) ? options.validate : thinky._options.validate;

	  this._schema = schemaUtil.parse(schema, '', this._options, this);
	  //console.log(JSON.stringify(this._schema, null, 2));

	  this.virtualFields = [];
	  this.defaultFields = [];
	  this._schema._getDefaultFields([], this.defaultFields, this.virtualFields)

	  this.needToGenerateFields = (this.defaultFields.length+this.virtualFields.length) !== 0;

	  this._pk = (options.pk != null) ? options.pk : 'id';

	  this._thinky = thinky;

	  this._validator = options.validator;

	  this._indexes = {}; // indexName -> true
	  this._pendingPromises = [];

	  this._error = null; // If an error occured, we won't let people save things

	  this._listeners = {};
	  this._maxListeners = 10;
	  this._joins = {};
	  this._localKeys = {}; // key used as a foreign key by another model

	  // This is to track joins that were not directly called by this model but that we still need
	  // to purge the database
	  this._reverseJoins = {};

	  this._methods = {};
	  this._staticMethods = {};
	  this._async = {
	    init: false,
	    retrieve: false,
	    save: false,
	    validate: false
	  };

	  this._pre = {
	    save: [],
	    delete: [],
	    validate: []
	  };
	  this._post = {
	    init: [],
	    retrieve: [],
	    save: [],
	    delete: [],
	    validate: []
	  };
	}
	util.inherits(Model, EventEmitter);

	Model.new = function(name, schema, options, thinky) {

	  var proto = new Model(name, schema, options, thinky);
	  proto._initModel = options.init  !== undefined ? !!options.init : true;

	  var model = function model(doc, options) {
	    if (!util.isPlainObject(doc)) {
	      throw new Error("Cannot build a new instance of `"+proto._name+"` without an object")
	    }
	    // We create a deepcopy only if doc was already used to create a document
	    if (doc instanceof Document) {
	      doc = util.deepCopy(doc);
	    }

	    util.changeProto(doc, new Document(model, options));

	    // Create joins document. We do it here because `options` are easily available
	    util.loopKeys(proto._joins, function(joins, key) {
	      if (doc[key] != null) {
	        if ((joins[key].type === 'hasOne') && (doc[key] instanceof Document === false)) {
	          doc[key] = new joins[key].model(doc[key], options);
	        }
	        else if ((joins[key].type === 'belongsTo') && (doc[key] instanceof Document === false)) {
	          doc[key] = new joins[key].model(doc[key], options);
	        }
	        else if (joins[key].type === 'hasMany') {
	          doc.__proto__._hasMany[key] = []

	          for(var i=0; i<doc[key].length; i++) {
	            if (doc[key][i] instanceof Document === false) {
	              doc[key][i] = new joins[key].model(doc[key][i], options);
	            }
	          }
	        }
	        else if (joins[key].type === 'hasAndBelongsToMany') {
	          for(var i=0; i<doc[key].length; i++) {
	            if (doc[key][i] instanceof Document === false) {
	              doc[key][i] = new joins[key].model(doc[key][i], options);
	            }
	          }
	        }
	      }
	    });
	    if (proto.needToGenerateFields === true) {
	      doc._generateDefault();
	    }

	    var promises = [];
	    var promise;
	    if (proto._options.validate === 'oncreate') {
	      promise = doc.validate(options);
	      if (promise instanceof Promise) promises.push(promise);
	    }

	    if (proto._post.init.length > 0) {
	      promise = util.hook({
	        postHooks: doc._getModel()._post.init,
	        doc: doc,
	        async: doc._getModel()._async.init,
	        fn: function() {}
	      })
	      if (promise instanceof Promise) promises.push(promise);
	    }

	    if (promises.length > 0) {
	      return Promise.all(promises);
	    }
	    return doc;
	  }

	  model.__proto__ = proto;

	  if (options.init !== false) {
	    // Setup the model's table.
	    model.tableReady().then();
	  }
	  else {
	    // We do not initialize the table and suppose that it already exists and
	    // is ready.
	    model.emit('created');
	    model.emit('ready');
	  }

	  // So people can directly call the EventEmitter from the constructor
	  // TOIMPROVE: We should emit everything from the constructor instead of emitting things from
	  // the constructor and the instance of Model
	  util.loopKeys(EventEmitter.prototype, function(emitter, key) {
	    (function(_key) {
	      model[_key] = function() {
	        model._getModel()[_key].apply(model._getModel(), arguments);
	      }
	    })(key)
	  });


	  return model
	}

	/**
	 * Create the model's table.
	 * @return {Promise=} Returns a promise which will resolve when the table is ready.
	 */
	Model.prototype.tableReady = function() {
	  var self = this;
	  var model = this._getModel();
	  if (!this._initModel) return Promise.resolve();
	  if (this._tableReadyPromise) return this._tableReadyPromise;

	  // Create the table, or push the table name in the queue.
	  var r = model._thinky.r;
	  this._tableReadyPromise = model._thinky.dbReady()
	  .then(function() {
	    return r.tableCreate(model._name, {primaryKey: model._pk}).run();
	  })
	  .error(function(error) {
	    if (error.message.match(/Table `.*` already exists/)) {
	      return;
	    }
	    model._error = error;
	    // Should we throw here?
	  });

	  return this._tableReadyPromise.then(function() {
	    self.emit('created');
	    if (!self._pendingPromises.length) {
	      self.emit('ready');
	    }
	  });
	};

	/**
	 * Get a promise which resolves when the Model's table and
	 * all indices have been created.
	 */
	Model.prototype.ready = function() {
	  var requirements = [];

	  // Ensure the Model's table is ready
	  requirements.push(this.tableReady());

	  // Ensure all other pending promises have been resolved
	  requirements.push(this._promisesReady());

	  return Promise.all(requirements);
	};

	Model.prototype._promisesReady = function() {
	  var self = this;
	  if (this._promisesReadyPromise) return this._promisesReadyPromise;

	  var verifyAll = function() {
	    return Promise.all(self._pendingPromises)
	    .then(function() {
	      var i, allFullfilled = true;
	      for (i=0; i<self._pendingPromises.length; i++) {
	         if (!self._pendingPromises[i].isFulfilled()) {
	          allFullfilled = false;
	          break;
	         }
	      }
	      return allFullfilled ? Promise.resolve() : verifyAll();
	    });
	  };

	  this._promisesReadyPromise = verifyAll();
	  return this._promisesReadyPromise;
	};

	Model.prototype._waitFor = function(promise) {
	  var self = this;
	  this._pendingPromises.push(promise);

	  // Emit 'ready' when all pending promises have resolved
	  if (!this._pendingReady) {
	    this._pendingReady = this._promisesReady().then(function() {
	      delete self._pendingReady;
	      self.emit('ready', self);
	    });
	  }
	};


	Model.prototype._setError = function(error) {
	  this._getModel()._error = error;
	  this.emit('error', error);
	}


	/*
	 * Return the options of the model -- call from an instance of Model
	 */
	Model.prototype.getOptions = function() {
	  return this._options;
	}


	/*
	 * Return the instance of Model **when called on the function**
	 */
	Model.prototype._getModel = function() {
	  return this.__proto__;
	}

	/*
	 * Return the instance of Model
	 */
	Model.prototype.getTableName = function() {
	  return this._getModel()._name;
	}


	Model.prototype.ensureIndex = function(name, fn, opts) {
	  var self = this;

	  if ((opts === undefined) && (util.isPlainObject(fn))) {
	    opts = fn;
	    fn = undefined;
	  }

	  return self._createIndex(name, fn, opts)
	  .catch(function(error) {
	    self._getModel()._setError(error);
	    throw error;
	  });
	}

	Model.prototype._createIndex = function(name, fn, opts) {
	  var model = this._getModel();
	  var tableName = this.getTableName();
	  var r = model._thinky.r;

	  if (opts === undefined && util.isPlainObject(fn)) {
	    opts = fn;
	    fn = undefined;
	  }

	  var promise = this.tableReady().then(function() {
	    return new Promise(function(resolve, reject) {
	      return r.branch(
	        r.table(tableName).indexList().contains(name),
	        r.table(tableName).indexWait(name),
	        r.branch(
	          r.table(tableName).info()('primary_key').eq(name),
	          r.table(tableName).indexWait(name),
	          r.table(tableName).indexCreate(name, fn, opts).do(function() {
	            return r.table(tableName).indexWait(name);
	          })
	        )
	      )
	      .run()
	      .then(resolve)
	      .error(function(error) {
	        if (error.message.match(/^Index/)) {
	          // TODO: This regex seems a bit too generous since messages such
	          // as "Index `id` was not found on table..." will be accepted.
	          // Figure out if this is OK or not.
	          return resolve();
	        }
	        reject(error);
	      });
	    });
	  })
	  .then(function() {
	    model._indexes[name] = true;
	  });

	  this._waitFor(promise);
	  return promise;
	};

	/*
	 * joinedModel: the joined model
	 * fieldDoc: the field where the joined document will be kept
	 * leftKey: the key in the model used for the join
	 * rightKey: the key in the joined model used for the join
	 *
	 * The foreign key is stores in the joinedModel
	 *
	 * Post.hasOne(Author, "author", "id", "postId"
	 *                ^- post.id
	 *
	 * options can be:
	 * - init: Boolean (create an index or not)
	 * - timeFormat: 'raw'/'native'
	 * - enforce_extra: 'strict'/'remove'/'none'
	 * - enforce_missing: Boolean
	 * - enforce_type: 'strict'/'loose'/'none'
	 * - validate: 'oncreate'/'onsave'
	 */
	Model.prototype.hasOne = function(joinedModel, fieldDoc, leftKey, rightKey, options) {
	  var self  = this;

	  if ((joinedModel instanceof Model) === false) {
	    throw new Error("First argument of `hasOne` must be a Model")
	  }
	  if (fieldDoc in self._getModel()._joins) {
	    throw new Error("The field `"+fieldDoc+"` is already used by another relation.");
	  }
	  if (fieldDoc === "_apply") {
	    throw new Error("The field `_apply` is reserved by thinky. Please use another one.");
	  }
	  self._getModel()._joins[fieldDoc] = {
	    model: joinedModel,
	    leftKey: leftKey,
	    rightKey: rightKey,
	    type: 'hasOne'
	  }
	  joinedModel._getModel()._localKeys[rightKey] = true;

	  options = options || {};
	  if (options.init !== false) {
	    var newIndex = joinedModel._createIndex(rightKey)
	    .catch(function(error) {
	      joinedModel._getModel()._setError(error);
	      self._getModel()._setError(error);
	    });
	    self._waitFor(newIndex);
	  }
	}

	/*
	 * joinedModel: the joined model
	 * fieldDoc: the field where the joined document will be kept
	 * leftKey: the key in the model used for the join
	 * rightKey: the key in the joined model used for the join
	 *
	 * The foreign key is store in the model calling belongsTo
	 *
	 * Post.belongsTo(Author, "author", "authorId", "id"
	 *                        ^- author.id
	 */
	Model.prototype.belongsTo = function(joinedModel, fieldDoc, leftKey, rightKey, options) {
	  var self  = this;

	  if ((joinedModel instanceof Model) === false) {
	    throw new Error("First argument of `belongsTo` must be a Model")
	  }
	  if (fieldDoc in self._getModel()._joins) {
	    throw new Error("The field `"+fieldDoc+"` is already used by another relation.");
	  }
	  if (fieldDoc === "_apply") {
	    throw new Error("The field `_apply` is reserved by thinky. Please use another one.");
	  }

	  self._getModel()._joins[fieldDoc] = {
	    model: joinedModel,
	    leftKey: leftKey,
	    rightKey: rightKey,
	    type: 'belongsTo'
	  };
	  self._getModel()._localKeys[leftKey] = true;

	  joinedModel._getModel()._reverseJoins[fieldDoc] = {
	    model: self,
	    leftKey: leftKey,
	    rightKey: rightKey,
	    type: 'belongsTo',
	  }

	  options = options || {};
	  if (options.init !== false) {
	    /*
	    var newIndex = self._createIndex(leftKey)
	    .catch(function(error) {
	      joinedModel._getModel()._setError(error);
	      self._getModel()._setError(error);
	    });
	    joinedModel._waitFor(newIndex);
	    */
	    var newIndex = joinedModel._createIndex(rightKey)
	    .catch(function(error) {
	      joinedModel._getModel()._setError(error);
	      self._getModel()._setError(error);
	    });
	    self._waitFor(newIndex);

	  }
	}


	/*
	 * joinedModel: the joined model
	 * fieldDoc: the field where the joined document will be kept
	 * leftKey: the key in the model used for the join
	 * rightKey: the key in the joined model used for the join
	 *
	 * A post has one author, and an author can write multiple posts
	 * Author.hasMany(Post, "posts", "id", "authorId"
	 *                 ^- author.id
	 */
	Model.prototype.hasMany = function(joinedModel, fieldDoc, leftKey, rightKey, options) {
	  var self  = this;

	  if ((joinedModel instanceof Model) === false) {
	    throw new Error("First argument of `hasMany` must be a Model")
	  }
	  if (fieldDoc in self._getModel()._joins) {
	    throw new Error("The field `"+fieldDoc+"` is already used by another relation.");
	  }
	  if (fieldDoc === "_apply") {
	    throw new Error("The field `_apply` is reserved by thinky. Please use another one.");
	  }

	  this._getModel()._joins[fieldDoc] = {
	    model: joinedModel,
	    leftKey: leftKey,
	    rightKey: rightKey,
	    type: 'hasMany'
	  };
	  joinedModel._getModel()._localKeys[rightKey] = true;

	  options = options || {};
	  if (options.init !== false) {
	    var newIndex = joinedModel._createIndex(rightKey)
	    .catch(function(error) {
	      self._getModel()._setError(error);
	      joinedModel._getModel()._setError(error);
	    });
	    self._waitFor(newIndex);
	  }
	}


	/*
	 * joinedModel: the joined model
	 * fieldDoc: the field where the joined document will be kept
	 * leftKey: the key in the model used for the join
	 * rightKey: the key in the joined model used for the join
	 *
	 * Patient.hasAndBelongsToMany(Doctor, "doctors", "id", "id"
	 *                     patient.id-^  ^-doctor.id
	 *
	 * It automatically creates a table <modelName>_<joinedModel> or <joinedModel>_<modelName> (alphabetic order)
	 */
	Model.prototype.hasAndBelongsToMany = function(joinedModel, fieldDoc, leftKey, rightKey, options) {
	  var self = this;
	  var link, query;
	  var thinky = this._getModel()._thinky;
	  options = options || {};

	  if ((joinedModel instanceof Model) === false) {
	    throw new Error("First argument of `hasAndBelongsToMany` must be a Model")
	  }
	  if (fieldDoc in self._getModel()._joins) {
	    throw new Error("The field `"+fieldDoc+"` is already used by another relation.");
	  }
	  if (fieldDoc === "_apply") {
	    throw new Error("The field `_apply` is reserved by thinky. Please use another one.");
	  }

	  if (this._getModel()._name < joinedModel._getModel()._name) {
	    link = this._getModel()._name+"_"+joinedModel._getModel()._name;
	  }
	  else {
	    link = joinedModel._getModel()._name+"_"+this._getModel()._name;
	  }
	  if (typeof options.type === 'string') {
	    link = link+"_"+options.type;
	  }
	  else if (typeof options.type !== 'undefined') {
	    throw new Error('options.type should be a string or undefined.')
	  }

	  var linkModel;
	  if (thinky.models[link] === undefined) {
	    linkModel = thinky.createModel(link, {}); // Create a model, claim the namespace and create the table
	  }
	  else {
	    linkModel = thinky.models[link];
	  }


	  this._getModel()._joins[fieldDoc] = {
	    model: joinedModel,
	    leftKey: leftKey,
	    rightKey: rightKey,
	    type: 'hasAndBelongsToMany',
	    link: link,
	    linkModel: linkModel
	  }

	  joinedModel._getModel()._reverseJoins[self.getTableName()] = {
	    leftKey: leftKey,
	    rightKey: rightKey,
	    type: 'hasAndBelongsToMany',
	    link: link,
	    linkModel: linkModel
	  }

	  if (options.init !== false) {
	    var r = self._getModel()._thinky.r;

	    var query;
	    if ((this.getTableName() === joinedModel.getTableName())
	      && (leftKey === rightKey)) {
	      // The relation is built for the same model, using the same key
	      // Create a multi index
	      query = r.branch(
	        r.table(link).indexList().contains(leftKey+"_"+rightKey),
	        r.table(link).indexWait(leftKey+"_"+rightKey),
	        r.table(link).indexCreate(leftKey+"_"+rightKey, function(doc) {
	          return doc(leftKey+"_"+rightKey)
	        }, {multi: true}).do(function() {
	          return r.table(link).indexWait(leftKey+"_"+rightKey)
	        })
	      )
	    }
	    else {
	      query = r.branch(
	        r.table(link).indexList().contains(self.getTableName()+'_'+leftKey),
	        r.table(link).indexWait(self.getTableName()+'_'+leftKey),
	        r.table(link).indexCreate(self.getTableName()+'_'+leftKey).do(function() {
	          return r.table(link).indexWait(self.getTableName()+'_'+leftKey)
	        })
	      ).do(function() {
	        return r.branch(
	          r.table(link).indexList().contains(joinedModel.getTableName()+'_'+rightKey),
	          r.table(link).indexWait(joinedModel.getTableName()+'_'+rightKey),
	          r.table(link).indexCreate(joinedModel.getTableName()+'_'+rightKey).do(function() {
	            return r.table(link).indexWait(joinedModel.getTableName()+'_'+rightKey)
	          })
	        )
	      })

	    }

	    var linkPromise = linkModel.ready().then(function() {
	      return query.run()
	      .then(function() {
	        self._getModel()._indexes[leftKey] = true;
	        joinedModel._getModel()._indexes[rightKey] = true;
	      })
	      .error(function(error) {
	        if (error.message.match(/^Index `/)) {
	          return;
	        }
	        if (error.message.match(/^Table `.*` already exists/)) {
	          return;
	        }
	        self._getModel()._setError(error);
	        joinedModel._getModel()._setError(error);
	        throw error;
	      });
	    })
	    .then(function() {
	      self._createIndex(leftKey)
	      .catch(function(error) {
	        self._getModel()._setError(error);
	        joinedModel._getModel()._setError(error);
	      });

	      joinedModel._createIndex(rightKey)
	      .catch(function(error) {
	        self._getModel()._setError(error);
	        joinedModel._getModel()._setError(error);
	      });
	    });

	    joinedModel._waitFor(linkPromise);
	    self._waitFor(linkPromise);

	    return Promise.all([self.ready(), joinedModel.ready()]);
	  }
	};

	(function() {
	  // Import rethinkdbdash methods
	  var Term = __webpack_require__(1)({pool: false}).expr(1).__proto__;
	  util.loopKeys(Term, function(Term, key) {
	    if (!Term.hasOwnProperty(key)) return;
	    if (key === 'run' || key[0] === '_') return;

	    (function(key) {
	      switch (key) {
	        case 'orderBy':
	          Model.prototype[key] = function() {
	            var query = new Query(this);
	            if ((arguments.length === 1)
	              && (typeof arguments[0] === 'string')
	              && (this._getModel()._indexes[arguments[0]] === true)) {

	                query = query[key]({index: arguments[0]});
	                return query;
	            }
	            else {
	              query = query[key].apply(query, arguments);
	              return query;
	            }
	          }
	          break;
	        case 'filter':
	          Model.prototype[key] = function() {
	            var query = new Query(this);
	            if ((arguments.length === 1)
	              && (util.isPlainObject(arguments[0]))) {

	              // Optimize a filter with an object
	              // We replace the first key that match an index name
	              var filter = arguments[0];

	              var keys = Object.keys(filter).sort(); // Lexicographical order
	              for(var i=0 ; i<keys.length; i++) {
	                var index = keys[i];

	                if (this._getModel()._indexes[index] === true) { // Index found
	                  query = query.getAll(filter[index], {index: index});
	                  delete filter[index];
	                  break;
	                }
	              }
	            }

	            query = query[key].apply(query, arguments);
	            return query;
	          }
	          break;
	        case 'get':
	          // Make a copy of `get` into `_get`
	          Model.prototype['_get'] = function() {
	            var query = new Query(this);
	            query = query['_get'].apply(query, arguments);
	            return query;
	          }
	        default:
	          Model.prototype[key] = function() {
	            var query = new Query(this);
	            query = query[key].apply(query, arguments);
	            return query;
	          }
	      }

	    })(key);
	  });
	})();

	Model.prototype.getJoin = function() {
	  var query = new Query(this);
	  return query.getJoin.apply(query, arguments)
	}

	Model.prototype.removeRelations = function(relationsToRemove) {
	  var query = new Query(this);
	  return query.removeRelations(relationsToRemove);
	}


	Model.prototype.run = function(options) {
	  var query = new Query(this);
	  return query.run(options);
	}
	Model.prototype.execute = function(options) {
	  var query = new Query(this);
	  return query.execute(options);
	}

	Model.prototype.save = function(docs, options) {
	  var self = this;
	  var r = self._getModel()._thinky.r;
	  var isArray = Array.isArray(docs);

	  if (!isArray) {
	    docs = [docs];
	  }

	  var p = new Promise(function(mainResolve, mainReject) {
	    var toSave = docs.length;

	    var resolves = [];
	    var rejects = [];
	    var executeInsert = function (resolve, reject) {
	      toSave--;
	      resolves.push(resolve);
	      rejects.push(reject);

	      if (toSave === 0) {
	        var copies = [];
	        for(var i=0; i<docs.length; i++) {
	          copies.push(docs[i]._makeSavableCopy());
	        }
	        var _options;
	        if (util.isPlainObject(options)) {
	          _options = util.deepCopy(options);
	        }
	        else {
	          _options = {};
	        }
	        _options.returnChanges = 'always';
	        r.table(self.getTableName()).insert(copies, _options).run().then(function(results) {
	          if (results.errors === 0) {
	            // results.changes currently does not enforce the same order as docs
	            if (Array.isArray(results.changes)) {
	              for(var i=0; i<results.changes.length; i++) {
	                docs[i]._merge(results.changes[i].new_val);
	                if (docs[i]._getModel().needToGenerateFields === true) {
	                  docs[i]._generateDefault();
	                }
	                docs[i]._setOldValue(util.deepCopy(results.changes[i].old_val));
	                docs[i].setSaved();
	                docs[i].emit('saved', docs[i]);
	              }
	            }
	            for(i=0; i<resolves.length; i++) {
	              resolves[i]();
	            }
	          }
	          else {
	            //TODO Expand error with more information
	            for(var i=0; i<rejects.length; i++) {
	              rejects[i](new Error("An error occurred during the batch insert. Original results:\n"+JSON.stringify(results, null, 2)));
	            }
	          }
	        }).error(reject);
	      }
	    };

	    var promises = [];
	    var foundNonValidDoc = false;
	    for(var i=0; i<docs.length; i++) {
	      if (foundNonValidDoc === true) {
	        return;
	      }
	      if (docs[i] instanceof Document === false) {
	        docs[i] = new self(docs[i]);
	      }
	      var promise;
	      util.tryCatch(function() {
	        promise = docs[i].validate();
	        if (promise instanceof Promise) {
	          promises.push(promise)
	        }
	      }, function(error) {
	        foundNonValidDoc = true;
	        mainReject(new Errors.ValidationError("One of the documents is not valid. Original error:\n"+error.message))
	      });
	    }

	    if (foundNonValidDoc === false) {
	      Promise.all(promises).then(function() {
	        var promises = [];
	        for(var i=0; i<docs.length; i++) {
	          promises.push(docs[i]._batchSave(executeInsert));
	        }
	        Promise.all(promises).then(function() {
	          mainResolve(docs);
	        }).error(function(error) {
	          mainReject(error)
	        });
	      }).error(function(error) {
	        mainReject(new Errors.ValidationError("One of the documents is not valid. Original error:\n"+error.message))
	      });
	    }
	  })

	  if (!isArray) {
	    return p.get(0);
	  }

	  return p;
	}


	Model.prototype.define = function(key, fn) {
	  this._methods[key] = fn;
	}
	Model.prototype.defineStatic = function(key, fn) {
	  this._staticMethods[key] = fn;

	  this[key] = function() {
	    return fn.apply(this, arguments);
	  };
	}



	Model.prototype._parse = function(data, ungroup) {
	  var self = this;
	  var promises = [];
	  var promise;

	  var p = new Promise(function(resolve, reject) {
	    if (ungroup) {
	      for(var i=0; i<data.length; i++) {
	        for(var j=0; j<data[i].reduction.length; j++) {
	          util.tryCatch(function() {
	            var newDoc = new self(data[i].reduction[j]);
	            newDoc.setSaved(true);
	            newDoc._emitRetrieve();
	            data[i].reduction[j] = newDoc;
	          }, reject)
	        }
	      }
	      return resolve(data);
	    }
	    else if (Array.isArray(data)) {
	      util.tryCatch(function() {
	        for(var i=0; i<data.length; i++) {
	          data[i] = new self(data[i])
	          data[i].setSaved(true);

	          self.emit('retrieved', data[i]);

	          (function(i) {
	            // Order matters here, we want the hooks to be executed *before* calling validate
	            promise = util.hook({
	              postHooks: data[i]._getModel()._post.retrieve,
	              doc: data[i],
	              async: data[i]._getModel()._async.retrieve,
	              fn: function() {}
	            })
	            if (promise instanceof Promise) {
	              promise.then(function() {
	                var promise = data[i].validate();
	                if (promise instanceof Promise) {
	                  promise.then(function() {
	                    resolve(data)
	                  }).error(reject);
	                }
	                else {
	                  resolve(data);
	                }
	              }).error(reject);
	              promises.push(promise);
	            }
	            else {
	              promise = data[i].validate();
	              if (promise instanceof Promise) promises.push(promise);
	            }
	          })(i);
	        }
	      }, function(error) {
	        var newError = new Error("The results could not be converted to instances of `"+self.getTableName()+"`\nDetailed error: "+error.message);

	        return reject(newError);
	      });

	      if (promises.length > 0) {
	        Promise.all(promises).then(function() {
	          resolve(data);
	        }).error(reject);
	      }
	      else {
	        resolve(data);
	      }
	    }
	    else {
	      // If we get a GROUPED_DATA, we convert documents in each group
	      if (util.isPlainObject(data) && (data.$reql_type$ === "GROUPED_DATA")) {
	        var result = [];
	        util.tryCatch(function() {
	          var reduction, newDoc;
	          for(var i=0; i<data.data.length; i++) {
	            (function(i) {
	              reduction = [];
	              if (Array.isArray(data.data[i][1])) {
	                for(var j=0; j<data.data[i][1].length; j++) {
	                  (function(j) {
	                    newDoc = new self(data.data[i][1][j]);
	                    newDoc.setSaved(true);

	                    newDoc._emitRetrieve();

	                    promise = util.hook({
	                      postHooks: newDoc._getModel()._post.retrieve,
	                      doc: newDoc,
	                      async: newDoc._getModel()._async.retrieve,
	                      fn: function() {}
	                    })
	                    if (promise instanceof Promise) {
	                      promise.then(function() {
	                        var promise = newDoc.validate();
	                        if (promise instanceof Promise) {
	                          promise.then(function() {
	                            resolve(data)
	                          }).error(reject);
	                        }
	                        else {
	                          resolve(data);
	                        }
	                      }).error(reject);
	                      promises.push(promise);
	                    }
	                    else {
	                      promise = newDoc.validate();
	                      if (promise instanceof Promise) promises.push(promise);
	                    }

	                    reduction.push(newDoc)
	                  })(j);
	                }
	                result.push({
	                  group: data.data[i][0],
	                  reduction: reduction
	                })
	              }
	              else {
	                newDoc = new self(data.data[i][1]);
	                newDoc.setSaved(true);

	                newDoc._emitRetrieve();

	                promise = util.hook({
	                  postHooks: newDoc._getModel()._post.retrieve,
	                  doc: newDoc,
	                  async: newDoc._getModel()._async.retrieve,
	                  fn: function() {}
	                })
	                if (promise instanceof Promise) {
	                  promise.then(function() {
	                    var promise = newDoc.validate();
	                    if (promise instanceof Promise) {
	                      promise.then(function() {
	                        resolve(result)
	                      }).error(reject);
	                    }
	                    else {
	                      resolve(result);
	                    }
	                  }).error(reject);
	                  promises.push(promise);
	                }
	                else {
	                  promise = newDoc.validate();
	                  if (promise instanceof Promise) promises.push(promise);
	                }

	                result.push({
	                  group: data.data[i][0],
	                  reduction: newDoc
	                })
	              }
	            })(i);
	          }
	        }, reject);
	        if (promises.length > 0) {
	          Promise.all(promises).then(function() {
	            resolve(result)
	          }).error(reject);
	        }
	        else {
	          resolve(result);
	        }
	      }
	      else {
	        if (data === null) { // makeDocument is true, but we got `null`
	          reject(new Error("Cannot build a new instance of `"+self.getTableName()+"` with `null`."))
	        }
	        else {
	          util.tryCatch(function() {
	            var newDoc = new self(data);
	            newDoc.setSaved(true);

	            newDoc._emitRetrieve();

	            promise = util.hook({
	              postHooks: newDoc._getModel()._post.retrieve,
	              doc: newDoc,
	              async: newDoc._getModel()._async.retrieve,
	              fn: function() {}
	            })
	            if (promise instanceof Promise) {
	              promise.then(function() {
	                var promise = newDoc.validate();
	                if (promise instanceof Promise) {
	                  promise.then(function() {
	                    resolve(newDoc);
	                  }).error(reject);
	                }
	                else {
	                  resolve(newDoc);
	                }
	              }).error(reject);
	            }
	            else {
	              promise = newDoc.validate();
	            }

	            if (promise instanceof Promise) {
	              promise.then(function() {
	                resolve(newDoc)
	              }).error(function(err) {
	                reject(err)
	              });
	            }
	            else {
	              resolve(newDoc);
	            }
	          }, reject);
	        }
	      }
	    }
	  })
	  return p;
	}

	/*
	 * Implement an interface similar to events.EventEmitter
	 */
	Model.prototype.docAddListener = function(eventKey, listener) {
	  var listeners = this._getModel()._listeners;
	  if (listeners[eventKey] == null) {
	    listeners[eventKey] = [];
	  }
	  listeners[eventKey].push({
	    once: false,
	    listener: listener
	  });
	}
	Model.prototype.docOn = Model.prototype.docAddListener;

	Model.prototype.docOnce = function(eventKey, listener) {
	  var listeners = this._getModel()._listeners;
	  if (listeners[eventKey] == null) {
	    listeners[eventKey] = [];
	  }
	  listeners[eventKey].push({
	    once: true,
	    listener: listener
	  });
	}

	Model.prototype.docListeners = function(eventKey, raw) {
	  if (eventKey == null) {
	    return this._getModel()._listeners
	  }

	  raw = raw || true;
	  if (raw === true) {
	    return this._getModel()._listeners[eventKey];
	  }
	  else {
	    return this._getModel()._listeners[eventKey].map(function(fn) {
	      return fn.listener;
	    });
	  }
	}

	Model.prototype.docSetMaxListeners = function(n) {
	  this._getModel()._maxListeners = n;
	}

	Model.prototype.docRemoveListener = function(ev, listener) {
	  if (Array.isArray(this._getModel()._listeners[ev])) {
	    for(var i=0; i<this._getModel()._listeners[ev].length; i++) {
	      if (this._getModel()._listeners[ev][i] === listener) {
	        this._getModel()._listeners[ev].splice(i, 1);
	        break;
	      }
	    }
	  }
	}

	Model.prototype.docRemoveAllListeners = function(ev) {
	  if (ev === undefined) {
	    delete this._getModel()._listeners[ev]
	  }
	  else {
	    this._getModel()._listeners = {};
	  }
	}

	Model.prototype.pre = function(ev, fn) {
	  if (typeof fn !== "function") {
	    throw new Error("Second argument to `pre` must be a function");
	  }
	  if (fn.length > 1) {
	    throw new Error("Second argument to `pre` must be a function with at most one argument.");
	  }
	  if (Array.isArray(this._pre[ev]) === false) {
	    throw new Error("No pre-hook available for the event `"+ev+"`.")
	  }
	  this._getModel()._async[ev] = this._getModel()._async[ev] || (fn.length === 1)
	  this._getModel()._pre[ev].push(fn);
	}

	Model.prototype.post = function(ev, fn) {
	  if (typeof fn !== "function") {
	    throw new Error("Second argument to `pre` must be a function");
	  }
	  if (fn.length > 1) {
	    throw new Error("Second argument to `pre` must be a function with at most one argument.");
	  }
	  if (Array.isArray(this._post[ev]) === false) {
	    throw new Error("No post-hook available for the event `"+ev+"`.")
	  }
	  this._getModel()._async[ev] = this._getModel()._async[ev] || (fn.length === 1)
	  this._getModel()._post[ev].push(fn);
	}

	module.exports = Model;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var util = __webpack_require__(9);
	var Promise = __webpack_require__(29);
	var EventEmitter = __webpack_require__(8).EventEmitter;
	var Errors = __webpack_require__(66);

	/**
	 * Random useful methods used everywhere.
	 */


	/**
	 * Is `obj` a plain object.
	 * @return {boolean}
	 */
	function isPlainObject(obj) {
	  return Object.prototype.toString.call(obj) === '[object Object]';
	}
	util.isPlainObject = isPlainObject;


	/**
	 * Make a "deep copy".
	 * The prototype chain is not copied.
	 */
	function deepCopy(value) {
	  var result;
	  if (value instanceof Buffer) {
	    // isPlainObject(buffer) returns true.
	    return new Buffer(value);
	  }

	  if (isPlainObject(value) === true) {
	    result = {};
	    loopKeys(value, function(_value, key) {
	      if (_value.hasOwnProperty(key)) {
	        result[key] = deepCopy(_value[key]);
	      }
	    });
	    return result;
	  }

	  if (Array.isArray(value)) {
	    result = []
	    for(var i=0; i<value.length; i++) {
	      result.push(deepCopy(value[i]));
	    }
	    return result;
	  }

	  return value;
	}
	util.deepCopy = deepCopy;


	/**
	 * Wrap try/catch for v8
	 */
	function tryCatch(toTry, handleError) {
	  try{
	    toTry()
	  }
	  catch(err) {
	    handleError(err)
	  }
	}
	util.tryCatch = tryCatch;


	/**
	 * Return a promise if a hook is asynchronous
	 * Note: If no hook is asynchronous, `fn` can still be asynchronous in which
	 * case we return a promise or undefined
	 * @param {Object} options, the arguments are:
	 * - preHooks {Array} the methods to execute before the main one
	 * - postHooks {Array} the methods to execute after the main one
	 * - async {boolean} whether this this hook is asynchronous or not
	 * - doc {Document} the document that triggered the hooks
	 * - fn {Function} the main function
	 * - fnArgs {Array} arguments for `fn`
	 * @return {Promise=}
	 */
	function hook(options) {
	  var preHooks = options.preHooks;
	  if (Array.isArray(preHooks) === false) {
	    preHooks = [];
	  }
	  var postHooks = options.postHooks;
	  if (Array.isArray(postHooks) === false) {
	    postHooks = [];
	  }
	  var doc = options.doc; // We need the doc to set the context of the hooks
	  var async = options.async || false;
	  var fn = options.fn; // The function that we are hook
	  var fnArgs = options.fnArgs;

	  if (async === true) {
	    return new Promise(function(resolve, reject) {
	      _asyncHook({
	        resolve: resolve,
	        reject: reject,
	        preHooks: preHooks,
	        postHooks: postHooks,
	        doc: doc,
	        fn: fn,
	        fnArgs: fnArgs
	      });
	    });
	  }

	  return _syncHook({
	    preHooks: preHooks,
	    postHooks: postHooks,
	    doc: doc,
	    fn: fn,
	    fnArgs: fnArgs
	  });
	}
	function _syncHook(args) {
	  var preHooks = args.preHooks;
	  var postHooks = args.postHooks;
	  var fn = args.fn;
	  var doc = args.doc;
	  var fnArgs = args.fnArgs;

	  for(var i=0; i<preHooks.length; i++) {
	    preHooks[i].call(doc);
	  }
	  var result = fn.apply(doc, fnArgs);
	  for(var j=0; j<postHooks.length; j++) {
	    postHooks[j].call(doc);
	  }
	  return result;
	}
	function _asyncHook(args) {
	  // One of the hook, or the function is asynchronous, so we will
	  // always return a promise
	  // We only need to keep track of the result return/resolved for fn

	  var preHooks = args.preHooks;
	  var postHooks = args.postHooks;
	  var fn = args.fn;
	  var fnArgs = args.fnArgs;
	  var doc = args.doc;
	  var resolve = args.resolve;
	  var reject = args.reject;
	  var args = args.args;

	  var result;

	  var nextPost = function() {
	    if (typeof resolve === "function") {
	      resolve(result);
	    }
	    return result;
	  }

	  var executeMain = function() {
	    result = fn.apply(doc, fnArgs);
	    if (result instanceof Promise) {
	      return result.then(function(res) {
	        result = res;
	        executeHooks(0, postHooks, doc, reject, nextPost);
	      }).error(reject);
	    }
	    return executeHooks(0, postHooks, doc, reject, nextPost);
	  }

	  var nextPre = function() {
	    tryCatch(executeMain, function (err) {
	      return reject(err);
	    });
	  }
	  return executeHooks(0, preHooks, doc, reject, nextPre);
	}
	util.hook = hook;

	function executeHooks(hookIndex, hooks, doc, reject, next) {
	  if (hookIndex < hooks.length) {
	    if (hooks[hookIndex].length === 1) {
	      hooks[hookIndex].call(doc, function(err) {
	        if (err) return reject(err);
	        executeHooks(hookIndex+1, hooks, doc, reject, next)
	      });
	    }
	    else {
	      hooks[hookIndex](doc);
	      executeHooks(hookIndex+1, hooks, doc, reject, next)
	    }
	  }
	  else {
	    next();
	  }
	}

	function loopKeys(obj, fn) {
	  if (isPlainObject(obj)) {
	    var keys = Object.keys(obj);
	    var result;
	    for(var i=0; i<keys.length; i++) {
	      result = fn(obj, keys[i]);
	      if (result === false) return;
	    }
	  }
	}
	util.loopKeys = loopKeys;

	function changeProto(object, newProto) {
	  object.__proto__ = newProto;
	}
	util.changeProto = changeProto;

	function recurse(key, joins, modelTo, all, done) {
	  return (util.isPlainObject(modelTo) && modelTo.hasOwnProperty(key))
	    || ((all === true) && (done[joins[key].model.getTableName()] !== true))
	}
	util.recurse = recurse;

	function bindEmitter(self) {
	  util.loopKeys(EventEmitter.prototype, function(emitter, key) {
	    var fn = emitter[key];
	    if (typeof fn === 'function') {
	      self[key] = function() {
	        var args = new Array(arguments.length);
	        for(var i = 0; i < arguments.length; i++) {
	          args[i] = arguments[i];
	        }
	        fn.apply(self, args);
	      }
	    }
	  });
	}
	util.bindEmitter = bindEmitter;

	function mergeOptions(options, newOptions) {
	  if (util.isPlainObject(newOptions)) {
	    if (!options) {
	      options = {};
	    }
	    var localOptions = {};
	    localOptions.enforce_missing = (newOptions.enforce_missing != null) ? newOptions.enforce_missing : options.enforce_missing;
	    localOptions.enforce_type = (newOptions.enforce_type != null) ? newOptions.enforce_type : options.enforce_type;
	    localOptions.enforce_extra = (newOptions.enforce_extra != null) ? newOptions.enforce_extra : options.enforce_extra;
	    return localOptions;
	  }
	  return options;
	}
	util.mergeOptions = mergeOptions;

	function extractPrimaryKey(oldValue, newValue, primaryKey) {
	  var primaryKey;
	  if (oldValue !== null) {
	    return oldValue[primaryKey];
	  }
	  if (newValue !== null) {
	    return newValue[primaryKey];
	  }
	  return undefined;
	}
	util.extractPrimaryKey = extractPrimaryKey;


	function undefinedField(prefix) {
	  throw new Errors.ValidationError("Value for "+prefix+" must be defined.")
	}
	util.undefinedField = undefinedField;


	var vowels = {a: true, e: true, i: true, o: true, u: true};
	function strictType(prefix, expected) {
	  if ((expected.length > 0) && (vowels[expected[0]])) {
	    throw new Errors.ValidationError("Value for "+prefix+" must be an "+expected+".")
	  }
	  throw new Errors.ValidationError("Value for "+prefix+" must be a "+expected+".")
	}
	util.strictType = strictType;


	function extraField(prefix, key) {
	  if (prefix === '') {
	    throw new Errors.ValidationError("Extra field `"+key+"` not allowed.")
	  }
	  throw new Errors.ValidationError("Extra field `"+key+"` in "+prefix+" not allowed.")
	}
	util.extraField = extraField;


	function looseType(prefix, expected) {
	  if ((expected.length > 0) && (vowels[expected[0]])) {
	    throw new Errors.ValidationError("Value for "+prefix+" must be an "+expected+" or null.")
	  }
	  throw new Errors.ValidationError("Value for "+prefix+" must be a "+expected+" or null.")
	}
	util.looseType = looseType;


	function pseudoTypeError(type, missingField, prefix) {
	  throw new Errors.ValidationError("The raw "+type+" object for "+prefix+" is missing the required field "+missingField+".")
	}
	util.pseudoTypeError = pseudoTypeError;


	// Return true if doc is undefined or null, else false
	// Can throw
	function validateIfUndefined(value, prefix, type, options) {
	  if (value === undefined) {
	    if (options.enforce_missing === true) {
	      undefinedField(prefix);
	    }
	    return true;
	  }
	  return false;
	}
	util.validateIfUndefined = validateIfUndefined;

	function toArray(args) {
	    return Array.prototype.slice.call(args);
	}
	util.toArray = toArray;

	module.exports = util;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 66 */
/***/ function(module, exports) {

	/**
	 * DocumentNotFound error which is returned when `get` returns `null`.
	 * "Extends" Error
	 */
	function DocumentNotFound(message) {
	  Error.captureStackTrace(this, DocumentNotFound);
	  this.message = message || "The query did not find a document and returned null.";
	};
	DocumentNotFound.prototype = new Error();
	DocumentNotFound.prototype.name = "Document not found";
	module.exports.DocumentNotFound = DocumentNotFound;


	/**
	 * InvalidWrite error which is returned when an inplace update/replace return
	 * anon valid document.
	 * "Extends" Error
	 */
	function InvalidWrite(message, raw) {
	  Error.captureStackTrace(this, InvalidWrite);
	  this.message = message;
	  this.raw = raw;
	};
	InvalidWrite.prototype = new Error();
	InvalidWrite.prototype.name = "Invalid write";
	module.exports.InvalidWrite = InvalidWrite;


	/**
	 * ValidationError error which is returned when validation of a document fails.
	 * "Extends" Error
	 */
	function ValidationError(message) {
	    Error.captureStackTrace(this, ValidationError);
	    this.message = message;
	};
	ValidationError.prototype = new Error();
	ValidationError.prototype.name = "Document failed validation";
	module.exports.ValidationError = ValidationError;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var arrayPrefix = "__array"
	module.exports.arrayPrefix = arrayPrefix;

	var util = __webpack_require__(65);
	var type = __webpack_require__(68);
	var Errors = __webpack_require__(66);


	function generateVirtual(doc, defaultField, originalDoc, virtual) {
	  var path = defaultField.path;
	  var value = defaultField.value;
	  var field = doc;

	  var keepGoing = true;
	  var virtualValue = virtual;

	  for(var j=0; j<path.length-1; j++) {
	    if (util.isPlainObject(virtualValue)) {
	      virtualValue = virtualValue[path[j]];
	    }
	    else {
	      virtualValue = undefined;
	    }

	    if (path[j] === arrayPrefix) {
	      if (!Array.isArray(field)) {
	        // This is caught by validate, except if there is an `enforce_type: "none"`.
	        return;
	      }
	      else {
	        for(var k=0; k<field.length; k++) {
	          generateVirtual(field[k], {path: defaultField.path.slice(j+1), value: defaultField.value}, this, virtual[k]);
	        }
	      }
	      keepGoing = false;
	    }
	    else {
	      // field cannot be undefined (doc is not undefined on the first iteration, and we'll return if it becomes undefined
	      field = field[path[j]];
	      if (field === undefined) {
	        // We do not populate parent of default fields by default
	        return;
	      }
	    }
	  }
	  if (keepGoing) {
	    if (value === undefined) {
	      if (util.isPlainObject(virtualValue) && (virtualValue[[path[path.length-1]]] !== undefined)) {
	        field[path[path.length-1]] = virtualValue[[path[path.length-1]]];
	      }
	    }
	    else if ((typeof value === "function") && !Array.isArray(value._query)) {
	      field[path[path.length-1]] = value.call(doc);
	    }
	    else {
	      if (util.isPlainObject(value)) {
	        field[path[path.length-1]] = util.deepCopy(value);
	      }
	      else if (value !== undefined) {
	        field[path[path.length-1]] = value;
	      }
	    }
	  }
	  return doc;
	}

	module.exports.generateVirtual = generateVirtual;

	function generateDefault(doc, defaultField, originalDoc) {
	  var path = defaultField.path;
	  var value = defaultField.value;
	  var field = doc;

	  var keepGoing = true;
	  for(var j=0; j<path.length-1; j++) {
	    if (path[j] === arrayPrefix) {
	      if (!Array.isArray(field)) {
	        // This is caught by validate, except if there is an `enforce_type: "none"`.
	        return;
	      }
	      else {
	        for(var k=0; k<field.length; k++) {
	          generateDefault(field[k], {path: defaultField.path.slice(j+1), value: defaultField.value}, this);
	        }
	      }
	      keepGoing = false;
	    }
	    else {
	      field = field[path[j]];
	      if (field === undefined) {
	        // We do not populate parent of default fields by default
	        return;
	      }
	    }
	  }
	  if (keepGoing && util.isPlainObject(field) && field[path[path.length-1]] === undefined) {
	    if ((typeof value === "function") && !Array.isArray(value._query)) {
	      field[path[path.length-1]] = value.call(doc);
	    }
	    else {
	      if (util.isPlainObject(value) || Array.isArray(value)) {
	        field[path[path.length-1]] = util.deepCopy(value);
	      }
	      else {
	        field[path[path.length-1]] = value;
	      }
	    }
	  }
	  return doc;
	}

	module.exports.generateDefault = generateDefault;

	function parse(schema, prefix, options, model) {
	  var result;

	  if ((prefix === '') && (type.isObject(schema) === false) && (util.isPlainObject(schema) === false)) {
	    throw new Errors.ValidationError("The schema must be a plain object.")
	  }

	  // Validate a schema and add the field _enum if needed
	  if (util.isPlainObject(schema)) {
	    if (schema._type !== undefined) {
	      options = util.mergeOptions(options, schema.options);
	      var result;
	      switch(schema._type) {
	        case String:
	          result = type.string().options(options).validator(schema.validator).enum(schema.enum);
	          if (schema.default !== undefined) { result.default(schema.default); }
	          if (typeof schema.min === "number") { result.min(schema.min); }
	          if (typeof schema.max === "number") { result.max(schema.max); }
	          if (typeof schema.length === "number") { result.length(schema.length); }
	          if (schema.alphanum === true) { result.alphanum(); }
	          if (schema.lowercase === true) { result.lowercase(); }
	          if (schema.uppercase === true) { result.uppercase(); }
	          if (typeof schema.regex === "string") { result.regex(regex, schema.flags); }
	          return result;
	        case Number:
	          result = type.number().options(options).validator(schema.validator);
	          if (schema.default !== undefined) { result.default(schema.default); }
	          if (typeof schema.min === "number") { result.min(schema.min); }
	          if (typeof schema.max === "number") { result.max(schema.max); }
	          if (typeof schema.length === "number") { result.length(schema.length); }
	          if (schema.integer === true) { result.integer(); }
	          return result;
	        case Boolean:
	          result = type.boolean().options(options).validator(schema.validator);
	          if (schema.default !== undefined) { result.default(schema.default); }
	          return result;
	        case Date:
	          var result = type.date().options(options).validator(schema.validator);
	          if (schema.default !== undefined) { result.default(schema.default); }
	          if (schema.min instanceof Date) { result.min(schema.min); }
	          if (schema.max instanceof Date) { result.max(schema.max); }
	          return result;
	        case Buffer:
	          result = type.buffer().options(options).validator(schema.validator);
	          if (schema.default !== undefined) { result.default(schema.default); }
	          return result
	        case Object:
	          result = type.object().options(options).validator(schema.validator);
	          if (schema.default !== undefined) { result.default(schema.default); }
	          util.loopKeys(schema.schema, function(_schema, key) {
	            result.setKey(key, parse(_schema[key], prefix+"["+key+"]", options));
	          })
	          if (prefix === '') {
	            result._setModel(model)
	          }
	          return result;
	        case Array:
	          var result = type.array().options(options).validator(schema.validator);
	          if (schema.default !== undefined) { result.default(schema.default); }
	          if (schema.schema !== undefined) {
	            result.schema(parse(schema.schema, prefix+"[0]", options));
	          }
	          if (typeof schema.min === "number") { result.min(schema.min); }
	          if (typeof schema.max === "number") { result.max(schema.max); }
	          if (typeof schema.length === "number") { result.length(schema.length); }
	          return result;
	        case 'Point':
	          result = type.point().options(options).validator(schema.validator);
	          if (schema.default !== undefined) { result.default(schema.default); }
	          return result;
	        case 'virtual':
	          result = type.virtual();
	          if (schema.default !== undefined) { result.default(schema.default); }
	          return result
	        default: // Unknown type
	          throw new Errors.ValidationError("The field `_type` must be `String`/`Number`/`Boolean`/`Date`/`Buffer`/`Object`/`Array`/`'virtual'`/`'Point'` for "+prefix);
	      }
	    }
	    else if (type.isString(schema)
	        || type.isString(schema)
	        || type.isNumber(schema)
	        || type.isBoolean(schema)
	        || type.isDate(schema)
	        || type.isBuffer(schema)
	        || type.isPoint(schema)
	        || type.isObject(schema)
	        || type.isArray(schema)
	        || type.isAny(schema)
	        || type.isVirtual(schema)){ // Unknown type
	      // Nothing to do here
	      if (type.isObject(schema)) {
	        parse(schema._schema, prefix, options);
	      }
	      else if (type.isArray(schema)) {
	        if (schema._schema == undefined) {
	          schema._schema = parse(type.any(), prefix, options);
	        }
	        else {
	          schema._schema = parse(schema._schema, prefix, options);
	        }
	      }

	      // We want to copy the model object here
	      if (util.isPlainObject(schema._options) === false) {
	        schema.options(options);
	      }
	      else if ((schema._options.enforce_extra === undefined)
	          || (schema._options.enforce_missing === undefined)
	          || (schema._options.enforce_type === undefined)) {
	        var newOptions = {};
	        newOptions.enforce_missing = (schema._options.enforce_missing != null) ? schema._options.enforce_missing : options.enforce_missing;
	        newOptions.enforce_extra = (schema._options.enforce_extra != null) ? schema._options.enforce_extra : options.enforce_extra;
	        newOptions.enforce_type = (schema._options.enforce_type != null) ? schema._options.enforce_type : options.enforce_type;
	        schema.options(newOptions);
	      }
	      return schema;
	    }
	    else {
	      result = type.object().options(options);
	      util.loopKeys(schema, function(_schema, key) {
	        result.setKey(key, parse(_schema[key], prefix+"["+key+"]", options));
	      })
	      if (prefix === '') {
	        result._setModel(model)
	      }
	      return result;
	    }
	  }
	  else if (Array.isArray(schema)) {
	    result = type.array().options(options);
	    if (schema.length > 1) {
	      throw new Errors.ValidationError("An array in a schema can have at most one element. Found "+schema.length+" elements in "+prefix)
	    }

	    if (schema.length > 0) {
	      result.schema(parse(schema[0], prefix+"[0]", options));
	    }
	    return result;

	  }
	  else if (schema === String) {
	    return type.string().options(options);
	  }
	  else if (schema === Number) {
	    return type.number().options(options);
	  }
	  else if (schema === Boolean) {
	    return type.boolean().options(options);
	  }
	  else if (schema === Date) {
	    return type.date().options(options);
	  }
	  else if (schema === Buffer) {
	    return type.buffer().options(options);
	  }
	  else if (schema === Object) {
	    return type.object().options(options);
	  }
	  else if (schema === Array) {
	    return type.array().options(options);
	  }
	  else if (schema === 'Point') {
	    return type.point().options(options);
	  }
	  else if (schema === 'virtual') {
	    return type.virtual().options(options);
	  }
	  else {
	    throw new Errors.ValidationError("The value must be `String`/`Number`/`Boolean`/`Date`/`Buffer`/`Object`/`Array`/`'virtual'`/`'Point'` for "+prefix);
	  }
	}
	module.exports.parse = parse;

	// The schema doesn't contain joined docs
	function validate(doc, schema, prefix, options) {
	  schema.validate(doc, prefix, options);
	}
	module.exports.validate = validate;

	function getType(schema) {
	  if (util.isPlainObject(schema) && (schema._type !== undefined)) {
	    return schema._type;
	  }
	  return schema;
	}


	function validateEnum(doc, schema, prefix) {
	  if (Array.isArray(schema.enum) && (schema._enum[doc] !== true)) {
	    var validValues = Object.keys(schema._enum);
	    var message = "The field "+prefix+" must be one of these values: "

	    for(var i=0; i<validValues.length; i++) {
	      if (i === 10) { break; }
	      if ((i === validValues.length-1) || (i === 9)) {
	        message = message+validValues[i]
	      }
	      else {
	        message = message+validValues[i]+", "
	      }
	    }
	    if (validValues.length > 10) {
	      message = message+"..."
	    }
	    else {
	      message = message+"."
	    }

	    throw new Errors.ValidationError(message);
	  }
	}
	// Check that schema is a valid object first
	function validateCustomizedValidator(doc, schema, prefix) {
	  if (typeof schema.validator === 'function') {
	    if (schema.validator(doc) === false) {
	      throw new Errors.ValidationErrors.ValidationError("Validator for the field "+prefix+" returned `false`.");
	    }
	  }
	}

	function validateString(doc, schema, prefix, options) {
	  if (validateNotNullUndefined(doc, prefix, "string", options)) return;

	  if (typeof doc !== "string") { // doc is not null/undefined
	    if (options.enforce_type === "strict") {
	      strictType(prefix, "string");
	    }
	    else if (options.enforce_type === "loose") {
	      looseType(prefix, "string");
	    }
	  }

	  if (util.isPlainObject(schema)) {
	    validateCustomizedValidator(doc, schema, prefix);
	    validateEnum(doc, schema, prefix);
	  }
	}

	function validateNumber(doc, schema, prefix, options) {
	  if (validateNotNullUndefined(doc, prefix, "number", options)) return;

	  if (typeof doc !== "number") { // doc is not null/undefined
	    if (options.enforce_type === "strict") {
	      strictType(prefix, "number");
	    }
	    else if (options.enforce_type === "loose") {
	      looseType(prefix, "number");
	    }
	  }

	  if (util.isPlainObject(schema)) {
	    validateCustomizedValidator(doc, schema, prefix);
	    validateEnum(doc, schema, prefix);
	  }

	}

	function validateBoolean(doc, schema, prefix, options) {
	  if (validateNotNullUndefined(doc, prefix, "boolean", options)) return;

	  if (typeof doc !== "boolean") { // doc is not null/undefined
	    if (options.enforce_type === "strict") {
	      strictType(prefix, "boolean");
	    }
	    else if (options.enforce_type === "loose") {
	      looseType(prefix, "boolean");
	    }
	  }

	  if (util.isPlainObject(schema)) {
	    validateCustomizedValidator(doc, schema, prefix);
	    validateEnum(doc, schema, prefix);
	  }
	}

	function validateDate(doc, schema, prefix, options) {
	  if (validateNotNullUndefined(doc, prefix, "date", options)) return;

	  if (options.enforce_type !== "none") {
	    if (util.isPlainObject(doc) && (doc["$reql_type$"] === "TIME")) {
	      if (doc.epoch_time === undefined) {
	        pseudoTypeError("date", "epoch_time", prefix);
	      }
	      else if (doc.timezone === undefined) {
	        pseudoTypeError("date", "timezone", prefix);
	      }
	    }
	    else if ((typeof doc === 'function') && (Array.isArray(doc._query))) {
	      // TOIMPROVE -- we currently just check if it's a term from the driver
	      // We suppose for now that this is enough and we don't throw an error
	    }
	    else if (typeof doc === 'string') {
	      var date = new Date(doc);
	      if (date.getTime() !== date.getTime()) {
	        if (options.enforce_type === "strict") {
	          strictType(prefix, "date or a valid string");
	        }
	        else if (options.enforce_type !== "none") {
	          looseType(prefix, "date or a valid string");
	        }
	      }
	    }
	    else if ((doc instanceof Date) === false)  {
	      if (options.enforce_type === "strict") {
	        strictType(prefix, "date");
	      }
	      else if (options.enforce_type !== "none") {
	        looseType(prefix, "date");
	      }
	    }
	  }

	  if (util.isPlainObject(schema)) {
	    validateCustomizedValidator(doc, schema, prefix);
	  }
	}

	function validatePoint(doc, schema, prefix, options) {
	  if (validateNotNullUndefined(doc, prefix, "point", options)) return;

	  if (options.enforce_type !== "none") {
	    if (util.isPlainObject(doc) && (doc["$reql_type$"] === "GEOMETRY")) {
	      if (doc.type === undefined) {
	        pseudoTypeError("Point", "type", prefix);
	      }
	      else if (doc.type !== "Point") {
	        throw new Errors.ValidationError("The field `type` for "+prefix+" must be `'Point'`.")
	      }
	      else if (doc.coordinates === undefined) {
	        pseudoTypeError("date", "coordinates", prefix);
	      }
	      else if ((!Array.isArray(doc.coordinates)) || (doc.coordinates.length !== 2)) {
	        throw new Errors.ValidationError("The field `coordinates` for "+prefix+" must be an Array of two numbers.")
	      }
	    }
	    else if (util.isPlainObject(doc) && (doc.type === "Point") && (Array.isArray(doc.coordinates)) && (doc.coordinates.length === 2)) { // Geojson
	      // Geojson format
	    }
	    else if ((typeof doc === 'function') && (Array.isArray(doc._query))) {
	      // TOIMPROvE -- we currently just check if it's a term from the driver
	      // We suppose for now that this is enough and we don't throw an error
	    }
	    else if (util.isPlainObject(doc)) {
	      var keys = Object.keys(doc).sort();
	      if (((keys.length !== 2) || keys[0] !== 'latitude') || (keys[1] !== 'longitude') || (typeof doc.latitude !== "number") || (typeof doc.longitude !== "number")) {
	        throw new Errors.ValidationError("The value for "+prefix+" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].")
	      }
	      else if ((typeof doc.latitude !== 'number') || (typeof doc.latitude !== 'number')) {
	        throw new Errors.ValidationError("The value for "+prefix+" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].")
	      }
	    }
	    else if (Array.isArray(doc)) {
	      if ((doc.length !== 2) || (typeof doc[0] !== "number") || (typeof doc[1] !== "number")) {
	        throw new Errors.ValidationError("The value for "+prefix+" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].")
	      }
	    }
	  }
	  if (util.isPlainObject(schema)) {
	    validateCustomizedValidator(doc, schema, prefix);
	  }
	}

	function validateBuffer(doc, schema, prefix, options) {
	  if (validateNotNullUndefined(doc, prefix, "buffer", options)) return;

	  if (util.isPlainObject(doc) && (doc["$reql_type$"] === "BINARY")) {
	    if (doc.data === undefined) {
	      pseudoTypeError("binary", "data", prefix);
	    }
	  }
	  else if ((typeof doc === 'function') && (Array.isArray(doc._query))) {
	    // TOIMPROvE -- we currently just check if it's a term from the driver
	    // We suppose for now that this is enough and we don't throw an error
	  }
	  else if ((doc instanceof Buffer) === false)  {
	    if (options.enforce_type === "strict") {
	      strictType(prefix, "buffer");
	    }
	    else if (options.enforce_type !== "none") {
	      looseType(prefix, "buffer");
	    }
	  }

	  if (util.isPlainObject(schema)) {
	    validateCustomizedValidator(doc, schema, prefix);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var schema =      __webpack_require__(67);
	var util =        __webpack_require__(65);
	var TypeAny =     __webpack_require__(69);
	var TypeArray =   __webpack_require__(70);
	var TypeBoolean = __webpack_require__(71);
	var TypeBuffer =  __webpack_require__(72);
	var TypeDate =    __webpack_require__(73);
	var TypeNumber =  __webpack_require__(74);
	var TypeObject =  __webpack_require__(75);
	var TypePoint =   __webpack_require__(76);
	var TypeString =  __webpack_require__(77);
	var TypeVirtual = __webpack_require__(79);


	/**
	 * Create a new Type that let users create sub-types.
	 * @return {Type}
	 */
	function Type() { }


	/**
	 * Create a new TypeAny object
	 * @return {TypeAny}
	 */

	Type.prototype.any = function() {
	  return new TypeAny();
	}


	/**
	 * Create a new TypeString object.
	 * @return {TypeString}
	 */
	Type.prototype.string = function() {
	  return new TypeString();
	}


	/**
	 * Create a new TypeNumber object.
	 * @return {TypeNumber}
	 */
	Type.prototype.number = function() {
	  return new TypeNumber();
	}


	/**
	 * Create a new TypeBoolean object.
	 * @return {TypeBoolean}
	 */
	Type.prototype.boolean = function() {
	  return new TypeBoolean();
	}


	/**
	 * Create a new TypeDate object.
	 * @return {TypeDate}
	 */
	Type.prototype.date = function() {
	  return new TypeDate();
	}


	/**
	 * Create a new TypeBuffer object.
	 * @return {TypeBuffer}
	 */
	Type.prototype.buffer = function() {
	  return new TypeBuffer();
	}


	/**
	 * Create a new TypePoint object.
	 * @return {TypePoint}
	 */
	Type.prototype.point = function() {
	  return new TypePoint();
	}


	/**
	 * Create a new TypeObject object.
	 * @return {TypeObject}
	 */
	Type.prototype.object = function() {
	  return new TypeObject();
	}


	/**
	 * Create a new TypeArray object.
	 * @return {TypeArray}
	 */
	Type.prototype.array = function() {
	  return new TypeArray();
	}


	/**
	 * Create a new TypeVirtual object.
	 * @return {TypeVirtual}
	 */
	Type.prototype.virtual = function() {
	  return new TypeVirtual();
	}


	/**
	 * Create a new TypeString object to use as an id.
	 * @return {TypeString}
	 */
	Type.prototype.id = function() {
	  return new TypeString().optional();
	}


	/**
	 * Check if the first argument is a TypeString object or not
	 * @param {Object} obj The object to check against TypeString.
	 * @return {boolean}
	 */
	Type.prototype.isString = function(obj) {
	  return obj instanceof TypeString;
	}


	/**
	 * Check if the first argument is a TypeNumber object or not
	 * @param {Object} obj The object to check against TypeNumber.
	 * @return {boolean}
	 */
	Type.prototype.isNumber = function(obj) {
	  return obj instanceof TypeNumber;
	}


	/**
	 * Check if the first argument is a TypeBoolean object or not
	 * @param {Object} obj The object to check against TypeBoolean.
	 * @return {boolean}
	 */
	Type.prototype.isBoolean = function(obj) {
	  return obj instanceof TypeBoolean;
	}


	/**
	 * Check if the first argument is a TypeDate object or not
	 * @param {Object} obj The object to check against TypeDate.
	 * @return {boolean}
	 */
	Type.prototype.isDate = function(obj) {
	  return obj instanceof TypeDate;
	}


	/**
	 * Check if the first argument is a TypeBuffer object or not
	 * @param {Object} obj The object to check against TypeBuffer.
	 * @return {boolean}
	 */
	Type.prototype.isBuffer = function(obj) {
	  return obj instanceof TypeBuffer;
	}


	/**
	 * Check if the first argument is a TypePoint object or not
	 * @param {Object} obj The object to check against TypePoint.
	 * @return {boolean}
	 */
	Type.prototype.isPoint = function(obj) {
	  return obj instanceof TypePoint;
	}


	/**
	 * Check if the first argument is a TypeObject object or not
	 * @param {Object} obj The object to check against TypeObject.
	 * @return {boolean}
	 */
	Type.prototype.isObject = function(obj) {
	  return obj instanceof TypeObject;
	}


	/**
	 * Check if the first argument is a TypeArray object or not
	 * @param {Object} obj The object to check against TypeArray.
	 * @return {boolean}
	 */
	Type.prototype.isArray = function(obj) {
	  return obj instanceof TypeArray;
	}


	/**
	 * Check if the first argument is a TypeVirtual object or not
	 * @param {Object} obj The object to check against TypeVirtual.
	 * @return {boolean}
	 */
	Type.prototype.isVirtual = function(obj) {
	  return obj instanceof TypeVirtual;
	}


	/**
	 * Check if the first argument is a TypeAny object or not
	 * @param {Object} obj The object to check against TypeAny.
	 * @return {boolean}
	 */
	Type.prototype.isAny = function(obj) {
	  return obj instanceof TypeAny;
	}


	module.exports = new Type();


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(65);
	var schema =      __webpack_require__(67);

	function TypeAny() {
	  this._default = undefined;
	  this._validator = undefined;
	  this._options = {};
	}

	TypeAny.prototype.default = function(fnOrValue) {
	  this._default = fnOrValue;
	}
	TypeAny.prototype.validator = function(fn) {
	  this._validator = fn;
	}
	TypeAny.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
	}

	// Dummy methods, just to allow users to easily switch from a valid type to any
	TypeAny.prototype.options = function(options) {
	  return this;
	}
	TypeAny.prototype.optional = function() {
	  return this;
	}
	TypeAny.prototype.required = function() {
	  return this;
	}
	TypeAny.prototype.allowNull = function() {
	  return this;
	}
	TypeAny.prototype.min = function() {
	  return this;
	}
	TypeAny.prototype.max = function() {
	  return this;
	}
	TypeAny.prototype.length = function() {
	  return this;
	}
	TypeAny.prototype.schema = function() {
	  return this;
	}
	TypeAny.prototype.validate = function() {
	  return this;
	}

	module.exports = TypeAny;


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(65);
	var schema =      __webpack_require__(67);
	var arrayPrefix = schema.arrayPrefix;
	var Errors = __webpack_require__(66);

	function TypeArray() {
	  this._min = -1;
	  this._max = -1;
	  this._length = -1;
	  this._schema = undefined;
	  this._validator = undefined;
	  this._options = {};
	}


	TypeArray.prototype.options = function(options) {
	  if (util.isPlainObject(options)) {
	    if (options.enforce_missing != null) {
	      this._options.enforce_missing =  options.enforce_missing
	    }
	    if (options.enforce_type != null) {
	      this._options.enforce_type = options.enforce_type;
	    }
	    if (options.enforce_extra != null) {
	      this._options.enforce_extra = options.enforce_extra
	    }
	  }
	  return this;
	}


	TypeArray.prototype.optional = function() {
	  this._options.enforce_missing = false;
	  return this;
	}


	TypeArray.prototype.required = function() {
	  this._options.enforce_missing = true;
	  return this;
	}


	TypeArray.prototype.allowNull = function(value) {
	  if (this._options.enforce_type === 'strict') {
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    // else a no-op, strict -> strict
	  }
	  else if (this._options.enforce_type !== 'none') {
	    // The value is loose or undefined
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    else {
	      // The default value is loose, so if we call allowNull(false), it becomes strict
	      this._options.enforce_type = 'strict'
	    }
	  }
	  // else no op, type.any() is the same as type.any().allowNull(<bool>)
	  return this;
	}


	TypeArray.prototype.min = function(min) {
	  if (min < 0) {
	    throw new Errors.ValidationError("The value for `min` must be a positive integer");
	  }
	  this._min = min;
	  return this;
	}


	TypeArray.prototype.max = function(max) {
	  if (max < 0) {
	    throw new Errors.ValidationError("The value for `max` must be a positive integer");
	  }
	  this._max = max;
	  return this;
	}


	TypeArray.prototype.length = function(length) {
	  if (length < 0) {
	    throw new Errors.ValidationError("The value for `length` must be a positive integer");
	  }
	  this._length = length;
	  return this;
	}


	TypeArray.prototype.schema = function(schema) {
	  this._schema = schema;
	  return this;
	}


	TypeArray.prototype.default = function(fnOrValue) {
	  this._default = fnOrValue;
	  return this;
	}


	TypeArray.prototype.validator = function(fn) {
	  this._validator = fn;
	  return this;
	}


	TypeArray.prototype.validate = function(array, prefix, options) {
	  var self = this;
	  var localOptions = util.mergeOptions(this._options, options);

	  if (util.validateIfUndefined(array, prefix, "array", localOptions)) return;

	  if ((typeof self._validator === "function") && (self._validator(array) === false)) {
	    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
	  }

	  if ((typeof array === 'function') && (array._query !== undefined)) {
	    // We do not check ReQL terms
	  }
	  else if (Array.isArray(array) === false) {
	    if (localOptions.enforce_type === "strict") {
	      util.strictType(prefix, "array");
	    }
	    else if ((localOptions.enforce_type === "loose") && (array !== null)) {
	      util.looseType(prefix, "array");
	    }
	  }
	  else {
	    if ((this._min !== -1) && (this._min > array.length)){
	      throw new Errors.ValidationError("Value for "+prefix+" must have at least "+this._min+" elements.")
	    }
	    if ((this._max !== -1) && (this._max < array.length)){
	      throw new Errors.ValidationError("Value for "+prefix+" must have at most "+this._max+" elements.")
	    }
	    if ((this._length !== -1) && (this._length !== array.length)){
	      throw new Errors.ValidationError("Value for "+prefix+" must be an array with "+this._length+" elements.")
	    }

	    for(var i=0; i<array.length; i++) {
	      if (array[i] === undefined) {
	        throw new Errors.ValidationError("The element in the array "+prefix+" (position "+i+") cannot be `undefined`.");
	      }
	      if (this._schema !== undefined) {
	        this._schema.validate(array[i], prefix+"["+i+"]", options);
	      }
	    }
	  }
	}


	TypeArray.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
	  if (this._default !== undefined) {
	    defaultFields.push({
	      path: prefix,
	      value: this._default,
	    });
	  }
	  if (this._schema !== undefined) {
	    this._schema._getDefaultFields(prefix.concat(arrayPrefix), defaultFields, virtualFields);
	  }
	}


	module.exports = TypeArray;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(65);
	var Errors = __webpack_require__(66);

	function TypeBoolean() {
	  this._default = undefined;
	  this._validator = undefined;
	  this._options = {};
	}


	TypeBoolean.prototype.options = function(options) {
	  if (util.isPlainObject(options)) {
	    if (options.enforce_missing != null) {
	      this._options.enforce_missing =  options.enforce_missing
	    }
	    if (options.enforce_type != null) {
	      this._options.enforce_type = options.enforce_type;
	    }
	    if (options.enforce_extra != null) {
	      this._options.enforce_extra = options.enforce_extra
	    }
	  }
	  return this;
	}


	TypeBoolean.prototype.optional = function() {
	  this._options.enforce_missing = false;
	  return this;
	}


	TypeBoolean.prototype.required = function() {
	  this._options.enforce_missing = true;
	  return this;
	}


	TypeBoolean.prototype.allowNull = function(value) {
	  if (this._options.enforce_type === 'strict') {
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    // else a no-op, strict -> strict
	  }
	  else if (this._options.enforce_type !== 'none') {
	    // The value is loose or undefined
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    else {
	      // The default value is loose, so if we call allowNull(false), it becomes strict
	      this._options.enforce_type = 'strict'
	    }
	  }
	  // else no op, type.any() is the same as type.any().allowNull(<bool>)
	  return this;
	}



	TypeBoolean.prototype.default = function(fnOrValue) {
	  this._default = fnOrValue;
	  return this;
	}


	TypeBoolean.prototype.validator = function(fn) {
	  if (typeof fn === "function") {
	    this._validator = fn;
	  }
	  return this;
	}


	TypeBoolean.prototype.validate = function(bool, prefix, options) {
	  options = util.mergeOptions(this._options, options);

	  if (util.validateIfUndefined(bool, prefix, "boolean", options)) return;

	  if ((typeof this._validator === "function") && (this._validator(bool) === false)) {
	    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
	  }

	  if (typeof bool !== "boolean") {
	    if (options.enforce_type === "strict") {
	      util.strictType(prefix, "boolean");
	    }
	    else if ((options.enforce_type === "loose") && (bool !== null)) {
	      util.looseType(prefix, "boolean");
	    }
	  }
	}


	TypeBoolean.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
	  if (this._default !== undefined) {
	    defaultFields.push({
	      path: prefix,
	      value: this._default,
	    });
	  }
	}


	module.exports = TypeBoolean;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var util = __webpack_require__(65);
	var Errors = __webpack_require__(66);

	function TypeBuffer() {
	  this._default = undefined;
	  this._options = {};
	  this._validator = undefined;
	}


	TypeBuffer.prototype.options = function(options) {
	  if (util.isPlainObject(options)) {
	    if (options.enforce_missing != null) {
	      this._options.enforce_missing =  options.enforce_missing
	    }
	    if (options.enforce_type != null) {
	      this._options.enforce_type = options.enforce_type;
	    }
	    if (options.enforce_extra != null) {
	      this._options.enforce_extra = options.enforce_extra
	    }
	  }
	  return this;
	}


	TypeBuffer.prototype.optional = function() {
	  this._options.enforce_missing = false;
	  return this;
	}


	TypeBuffer.prototype.required = function() {
	  this._options.enforce_missing = true;
	  return this;
	}


	TypeBuffer.prototype.allowNull = function(value) {
	  if (this._options.enforce_type === 'strict') {
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    // else a no-op, strict -> strict
	  }
	  else if (this._options.enforce_type !== 'none') {
	    // The value is loose or undefined
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    else {
	      // The default value is loose, so if we call allowNull(false), it becomes strict
	      this._options.enforce_type = 'strict'
	    }
	  }
	  // else no op, type.any() is the same as type.any().allowNull(<bool>)
	  return this;
	}


	TypeBuffer.prototype.default = function(fnOrValue) {
	  this._default = fnOrValue;
	  return this;
	}


	TypeBuffer.prototype.validator = function(fn) {
	  if (typeof fn === "function") {
	    this._validator = fn;
	  }
	  return this;
	}


	TypeBuffer.prototype.validate = function(buffer, prefix, options) {
	  options = util.mergeOptions(this._options, options);

	  if (util.validateIfUndefined(buffer, prefix, "buffer", options)) return;

	  if ((typeof this._validator === "function") && (this._validator(buffer) === false)) {
	    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
	  }

	  if (util.isPlainObject(buffer) && (buffer["$reql_type$"] === "BINARY")) {
	    if (buffer.data === undefined) {
	      util.pseudoTypeError("binary", "data", prefix);
	    }
	  }
	  else if ((typeof buffer === 'function') && (buffer._query !== undefined)) {
	    // TOIMPROvE -- we currently just check if it's a term from the driver
	    // We suppose for now that this is enough and we don't throw an error
	  }
	  else if ((buffer instanceof Buffer) === false)  { // We don't have a buffer
	    if (options.enforce_type === "strict") {
	      util.strictType(prefix, "buffer");
	    }
	    else if ((options.enforce_type === "loose") && (buffer !== null)) {
	      util.looseType(prefix, "buffer");
	    }
	  }
	}


	TypeBuffer.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
	  if (this._default !== undefined) {
	    defaultFields.push({
	      path: prefix,
	      value: this._default,
	    });
	  }
	}


	module.exports = TypeBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(65);
	var Errors = __webpack_require__(66);

	function TypeDate() {
	  this._min = undefined;
	  this._max = undefined;
	  this._validator = undefined;
	  this._options = {};
	}


	TypeDate.prototype.options = function(options) {
	  if (util.isPlainObject(options)) {
	    if (options.enforce_missing != null) {
	      this._options.enforce_missing =  options.enforce_missing
	    }
	    if (options.enforce_type != null) {
	      this._options.enforce_type = options.enforce_type;
	    }
	    if (options.enforce_extra != null) {
	      this._options.enforce_extra = options.enforce_extra
	    }
	  }
	  return this;
	}


	TypeDate.prototype.optional = function() {
	  this._options.enforce_missing = false;
	  return this;
	}


	TypeDate.prototype.required = function() {
	  this._options.enforce_missing = true;
	  return this;
	}


	TypeDate.prototype.allowNull = function(value) {
	  if (this._options.enforce_type === 'strict') {
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    // else a no-op, strict -> strict
	  }
	  else if (this._options.enforce_type !== 'none') {
	    // The value is loose or undefined
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    else {
	      // The default value is loose, so if we call allowNull(false), it becomes strict
	      this._options.enforce_type = 'strict'
	    }
	  }
	  // else no op, type.any() is the same as type.any().allowNull(<bool>)
	  return this;
	}


	TypeDate.prototype.min = function(min) {
	  this._min = min;
	  return this;
	}


	TypeDate.prototype.max = function(max) {
	  this._max = max;
	  return this;
	}


	TypeDate.prototype.default = function(fnOrValue) {
	  this._default = fnOrValue;
	  return this;
	}


	TypeDate.prototype.validator = function(fn) {
	  if (typeof fn === "function") {
	    this._validator = fn;
	  }
	  return this;
	}


	TypeDate.prototype.validate = function(date, prefix, options) {
	  options = util.mergeOptions(this._options, options);

	  if (util.validateIfUndefined(date, prefix, "date", options)) return;

	  if ((typeof this._validator === "function") && (this._validator(date) === false)) {
	    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
	  }

	  var jsDate;
	  if (util.isPlainObject(date) && (date["$reql_type$"] === "TIME")) {
	    if (date.epoch_time === undefined) {
	      util.pseudoTypeError("date", "epoch_time", prefix);
	    }
	    else if (date.timezone === undefined) {
	      util.pseudoTypeError("date", "timezone", prefix);
	    }

	    jsDate = new Date(0);
	    jsDate.setUTCSeconds(date.epoch_time)
	  }
	  else if ((typeof date === 'function') && (date._query !== undefined)) {
	    // TOIMPROVE -- we currently just check if it's a term from the driver
	    // We suppose for now that this is enough and we don't throw an error
	  }
	  else if (typeof date === 'string' || typeof date === 'number') {
	    var numericDate = parseInt(date, 10);
	    if(!isNaN(numericDate)){
	      date = numericDate;
	    }
	    jsDate = new Date(date);
	    if (jsDate.getTime() !== jsDate.getTime()) {
	      if (options.enforce_type === "strict") {
	        util.strictType(prefix, "date or a valid string");
	      }
	      else if (options.enforce_type !== "none") {
	        util.looseType(prefix, "date or a valid string");
	      }
	    }
	  }
	  else if ((date instanceof Date) === false) { // We have a non valid date
	    if (options.enforce_type === "strict") {
	      util.strictType(prefix, "date");
	    }
	    else if ((options.enforce_type === "loose") && (date !== null)) {
	      util.looseType(prefix, "date");
	    }
	  }
	  else {
	    jsDate = date;
	  }

	  // We check for min/max only if we could create a javascript date from the value
	  if (jsDate !== undefined) {
	    if ((this._min instanceof Date) && (this._min > jsDate)){
	      throw new Errors.ValidationError("Value for "+prefix+" must be after "+this._min+".")
	    }
	    if ((this._max instanceof Date) && (this._max < jsDate)){
	      throw new Errors.ValidationError("Value for "+prefix+" must be before "+this._max+".")
	    }
	  }
	}


	TypeDate.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
	  if (this._default !== undefined) {
	    defaultFields.push({
	      path: prefix,
	      value: this._default,
	    });
	  }
	}


	module.exports = TypeDate;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(65);
	var Errors = __webpack_require__(66);

	function TypeNumber() {
	  this._min = -1;
	  this._max = -1;
	  this._integer = false;
	  this._default = undefined;
	  this._validator = undefined;
	  this._options = {};
	}


	TypeNumber.prototype.options = function(options) {
	  if (util.isPlainObject(options)) {
	    if (options.enforce_missing != null) {
	      this._options.enforce_missing =  options.enforce_missing
	    }
	    if (options.enforce_type != null) {
	      this._options.enforce_type = options.enforce_type;
	    }
	    if (options.enforce_extra != null) {
	      this._options.enforce_extra = options.enforce_extra
	    }
	  }
	  return this;
	}


	TypeNumber.prototype.optional = function() {
	  this._options.enforce_missing = false;
	  return this;
	}


	TypeNumber.prototype.required = function() {
	  this._options.enforce_missing = true;
	  return this;
	}


	TypeNumber.prototype.allowNull = function(value) {
	  if (this._options.enforce_type === 'strict') {
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    // else a no-op, strict -> strict
	  }
	  else if (this._options.enforce_type !== 'none') {
	    // The value is loose or undefined
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    else {
	      // The default value is loose, so if we call allowNull(false), it becomes strict
	      this._options.enforce_type = 'strict'
	    }
	  }
	  // else no op, type.any() is the same as type.any().allowNull(<bool>)
	  return this;
	}



	TypeNumber.prototype.min = function(min) {
	  if (min < 0) {
	    throw new Errors.ValidationError("The value for `min` must be a positive integer");
	  }
	  this._min = min;
	  return this;
	}


	TypeNumber.prototype.max = function(max) {
	  if (max < 0) {
	    throw new Errors.ValidationError("The value for `max` must be a positive integer");
	  }
	  this._max = max;
	  return this;
	}


	TypeNumber.prototype.integer = function() {
	  this._integer = true;
	  return this;
	}


	TypeNumber.prototype.default = function(fnOrValue) {
	  this._default = fnOrValue;
	  return this;
	}


	TypeNumber.prototype.validator = function(fn) {
	  if (typeof fn === "function") {
	    this._validator = fn;
	  }
	  return this;
	}


	TypeNumber.prototype.validate = function(number, prefix, options) {
	  options = util.mergeOptions(this._options, options);

	  if (util.validateIfUndefined(number, prefix, "number", options)) return;

	  if ((typeof this._validator === "function") && (this._validator(number) === false)) {
	    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
	  }

	  if(typeof number === 'string'){
	    var numericString = parseFloat(number);
	    if(!isNaN(numericString)){
	      number = numericString;
	    }
	  }

	  if ((typeof number === 'function') && (number._query !== undefined)) {
	    // We do not check ReQL terms
	  }
	  else if ((typeof number !== "number") || (isFinite(number) === false)) {
	    if (options.enforce_type === "strict") {
	      util.strictType(prefix, "finite number");
	    }
	    else if ((options.enforce_type === "loose") && (number !== null)) {
	      util.looseType(prefix, "finite number");
	    }
	  }
	  else {
	    if ((this._min !== -1) && (this._min > number)){
	      throw new Errors.ValidationError("Value for "+prefix+" must be greater than "+this._min+".")
	    }
	    if ((this._max !== -1) && (this._max < number)){
	      throw new Errors.ValidationError("Value for "+prefix+" must be less than "+this._max+".")
	    }
	    if ((this._integer === true) && (number%1 !== 0)){
	      throw new Errors.ValidationError("Value for "+prefix+" must be an integer.")
	    }
	  }
	}


	TypeNumber.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
	  if (this._default !== undefined) {
	    defaultFields.push({
	      path: prefix,
	      value: this._default,
	    });
	  }
	}


	module.exports = TypeNumber;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(65);
	var Errors = __webpack_require__(66);

	function TypeObject() {
	  this._default = undefined;
	  this._validator = undefined;
	  this._options = {};
	  this._schema = {};
	}


	TypeObject.prototype._setModel = function(model) {
	  this._model = model;
	  return this;
	}


	TypeObject.prototype.options = function(options) {
	  if (util.isPlainObject(options)) {
	    if (options.enforce_missing != null) {
	      this._options.enforce_missing =  options.enforce_missing
	    }
	    if (options.enforce_type != null) {
	      this._options.enforce_type = options.enforce_type;
	    }
	    if (options.enforce_extra != null) {
	      this._options.enforce_extra = options.enforce_extra
	    }
	  }
	  return this;
	}


	TypeObject.prototype.optional = function() {
	  this._options.enforce_missing = false;
	  return this;
	}


	TypeObject.prototype.required = function() {
	  this._options.enforce_missing = true;
	  return this;
	}


	TypeObject.prototype.allowNull = function(value) {
	  if (this._options.enforce_type === 'strict') {
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    // else a no-op, strict -> strict
	  }
	  else if (this._options.enforce_type !== 'none') {
	    // The value is loose or undefined
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    else {
	      // The default value is loose, so if we call allowNull(false), it becomes strict
	      this._options.enforce_type = 'strict'
	    }
	  }
	  // else no op, type.any() is the same as type.any().allowNull(<bool>)
	  return this;
	}


	TypeObject.prototype.allowExtra = function(allowed) {
	  if (allowed === true) {
	    this._options.enforce_extra = 'none';
	  }
	  else if (allowed === false) {
	    this._options.enforce_extra = 'strict';
	  }
	  return this;
	}


	TypeObject.prototype.removeExtra = function() {
	  this._options.enforce_extra = 'remove';
	  return this;
	}


	TypeObject.prototype.schema = function(schema) {
	  // Users shouldn't use the deprecated syntax with the chainable one
	  // We do not parse the schema as we don't have the current prefix, options etc.
	  this._schema = schema;
	  return this;
	}


	TypeObject.prototype.setKey = function(key, schema) {
	  this._schema[key] = schema;
	  return this;
	}


	TypeObject.prototype.default = function(fnOrValue) {
	  this._default = fnOrValue;
	  return this;
	}


	TypeObject.prototype.validator = function(fn) {
	  if (typeof fn === "function") {
	    this._validator = fn;
	  }
	  return this;
	}


	TypeObject.prototype.validate = function(object, prefix, options) {
	  var self = this;
	  var localOptions = util.mergeOptions(this._options, options);

	  if (util.validateIfUndefined(object, prefix, "object", localOptions)) return;

	  if ((typeof self._validator === "function") && (self._validator(object) === false)) {
	    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
	  }

	  if ((typeof object === 'function') && (object._query !== undefined)) {
	    // We do not check ReQL terms
	  }
	  else if (util.isPlainObject(object) === false) {
	    if (localOptions.enforce_type === "strict") {
	      util.strictType(prefix, "object");
	    }
	    else if ((localOptions.enforce_type === "loose") && (object !== null)) {
	      util.looseType(prefix, "object");
	    }
	  }
	  else {
	    util.loopKeys(self._schema, function(schema, key) {
	      schema[key].validate(object[key], prefix+"["+key+"]", options);
	    });

	    // We clean extra fields in validate, for a use case, see:
	    // https://github.com/neumino/thinky/pull/123#issuecomment-56254682
	    if (localOptions.enforce_extra === "remove") {
	      util.loopKeys(object, function(object, key) {
	        if ((self._model === undefined || self._model._joins.hasOwnProperty(key) === false)
	            && (self._schema[key] === undefined)) {
	          delete object[key];
	        }
	      });
	    }
	    else if (localOptions.enforce_extra === "strict") {
	      util.loopKeys(object, function(object, key) {
	        if ((self._model === undefined || self._model._joins.hasOwnProperty(key) === false)
	            && (self._schema[key] === undefined)) {
	          util.extraField(prefix, key);
	        }
	      });
	    }
	  }
	}


	TypeObject.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
	  if (this._default !== undefined) {
	    defaultFields.push({
	      path: prefix,
	      value: this._default,
	    });
	  }
	  if (this._schema !== undefined) {
	    util.loopKeys(this._schema, function(_schema, key) {
	      if (typeof _schema[key]._getDefaultFields !== 'function') {
	        console.log(_schema);
	        console.log(key);
	        console.log(_schema[key]);
	      }
	      _schema[key]._getDefaultFields(prefix.concat(key), defaultFields, virtualFields);
	    })
	  }
	}


	module.exports = TypeObject;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(65);
	var Errors = __webpack_require__(66);

	function TypePoint() {
	  this._default = undefined;
	  this._validator = undefined;
	  this._options = {};
	}


	TypePoint.prototype.options = function(options) {
	  if (util.isPlainObject(options)) {
	    if (options.enforce_missing != null) {
	      this._options.enforce_missing =  options.enforce_missing
	    }
	    if (options.enforce_type != null) {
	      this._options.enforce_type = options.enforce_type;
	    }
	    if (options.enforce_extra != null) {
	      this._options.enforce_extra = options.enforce_extra
	    }
	  }
	  return this;
	}


	TypePoint.prototype.optional = function() {
	  this._options.enforce_missing = false;
	  return this;
	}


	TypePoint.prototype.required = function() {
	  this._options.enforce_missing = true;
	  return this;
	}


	TypePoint.prototype.allowNull = function(value) {
	  if (this._options.enforce_type === 'strict') {
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    // else a no-op, strict -> strict
	  }
	  else if (this._options.enforce_type !== 'none') {
	    // The value is loose or undefined
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    else {
	      // The default value is loose, so if we call allowNull(false), it becomes strict
	      this._options.enforce_type = 'strict'
	    }
	  }
	  // else no op, type.any() is the same as type.any().allowNull(<bool>)
	  return this;
	}


	TypePoint.prototype.default = function(fnOrValue) {
	  this._default = fnOrValue;
	  return this;
	}


	TypePoint.prototype.validator = function(fn) {
	  if (typeof fn === "function") {
	   this._validator = fn;
	  }
	  return this;
	}


	TypePoint.prototype.validate = function(point, prefix, options) {
	  options = util.mergeOptions(this._options, options);

	  if (util.validateIfUndefined(point, prefix, "point", options)) return;

	  if ((typeof this._validator === "function") && (this._validator(point) === false)) {
	    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
	  }

	  if (util.isPlainObject(point) && (point["$reql_type$"] === "GEOMETRY")) {
	    if (point.type === undefined) {
	      util.pseudoTypeError("Point", "type", prefix);
	    }
	    else if (point.type !== "Point") {
	      throw new Errors.ValidationError("The field `type` for "+prefix+" must be `'Point'`.")
	    }
	    else if (point.coordinates === undefined) {
	      util.pseudoTypeError("date", "coordinates", prefix);
	    }
	    else if ((!Array.isArray(point.coordinates)) || (point.coordinates.length !== 2)) {
	      throw new Errors.ValidationError("The field `coordinates` for "+prefix+" must be an Array of two numbers.")
	    }
	  }
	  else if (util.isPlainObject(point) && (point.type === "Point") && (Array.isArray(point.coordinates)) && (point.coordinates.length === 2)) { // Geojson
	    // Geojson format
	  }
	  else if ((typeof point === 'function') && (point._query !== undefined)) {
	    // TOIMPROvE -- we currently just check if it's a term from the driver
	    // We suppose for now that this is enough and we don't throw an error
	  }
	  else if (util.isPlainObject(point)) {
	    var keys = Object.keys(point).sort();
	    if (((keys.length !== 2) || keys[0] !== 'latitude') || (keys[1] !== 'longitude') || (typeof point.latitude !== "number") || (typeof point.longitude !== "number")) {
	      throw new Errors.ValidationError("The value for "+prefix+" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].")
	    }
	    else if ((typeof point.latitude !== 'number') || (typeof point.latitude !== 'number')) {
	      throw new Errors.ValidationError("The value for "+prefix+" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].")
	    }
	  }
	  else if (Array.isArray(point)) {
	    if ((point.length !== 2) || (typeof point[0] !== "number") || (typeof point[1] !== "number")) {
	      throw new Errors.ValidationError("The value for "+prefix+" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].")
	    }
	  }
	  else { // We don't have a point
	    if (options.enforce_type === "strict") {
	      util.strictType(prefix, "Point");
	    }
	    else if ((options.enforce_type === "loose") && (point !== null)) {
	      util.looseType(prefix, "Point");
	    }
	  }
	}


	TypePoint.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
	  if (this._default !== undefined) {
	    defaultFields.push({
	      path: prefix,
	      value: this._default,
	    });
	  }
	}

	module.exports = TypePoint;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var util =       __webpack_require__(65);
	var validator =  __webpack_require__(78);
	var Errors = __webpack_require__(66);

	/**
	 * Create a new TypeString object
	 */
	function TypeString() {
	  /**
	   * Minimum length of the string, negative if no minimum length is required.
	   * @type {number}
	   */
	  this._min = -1;
	  /**
	   * Maximum length of the string, negative if no maximum length is required.
	   * @type {number}
	   */
	  this._max = -1;
	  /**
	   * Length of the string, negative if no length is required.
	   * @type {number}
	   */
	  this._length = -1;
	  /**
	   * Whether the string must be alphanumeric or not. We used the npm validator
	   * package, and as 2014/12/14, it check against the regex [a-zA-Z0-9]
	   * @type {boolean}
	   */
	  this._alphanum = false;
	  /**
	   * Whether this string must be uppercase or not.
	   * @type {boolean}
	   */
	  this._uppercase = false;
	  /**
	   * Whether this string must be lowercase or not.
	   * @type {boolean}
	   */
	  this._lowercase = false;
	  /*
	   * The regex against which the string must conform. Undefined if the string
	   * does not have to conform to a RegExp.
	   * @type {RegExp=}
	   */
	  this._regex = undefined;
	  /**
	   * The validator called with the string must return {true} if the string is valid,
	   * {false} if the string is not.
	   * @type {function(string)=}
	   */
	  this._enum = undefined;
	  /**
	   * The default value for this field or a function to generate the default value.
	   * @type {function|string}
	   */
	  this._default = undefined;
	  /**
	   * Options for this type "enforce_missing", "enforce_type", "enforce_extra"
	   * @type {Object=}
	   */
	  this._validator = undefined;
	  /**
	   * An object whose keys are the acceptable values for the string. Undefined if this
	   * is not a requirement.
	   * @type {Object=}
	   */
	  this._options = {};
	}


	/**
	 * Set the options for this field.
	 * @param {!object} options The options for this field. The valid fields are:
	 *  - `enforce_missing` {boolean}, default `false`
	 *  - `enforce_extra` {"strict"|"remove"|"none"}, default `"none"`
	 *  - `enforce_type` {"strict"|"loose"|"none"}, default `"loose"`
	 * @return {TypeString}
	 */
	TypeString.prototype.options = function(options) {
	  if (util.isPlainObject(options)) {
	    if (options.enforce_missing != null) {
	      this._options.enforce_missing =  options.enforce_missing
	    }
	    if (options.enforce_type != null) {
	      this._options.enforce_type = options.enforce_type;
	    }
	    if (options.enforce_extra != null) {
	      this._options.enforce_extra = options.enforce_extra
	    }
	  }
	  return this;
	}


	/**
	 * Set the property as optional (enforce_missing = false).
	 * Leaves other existing options unchanged.
	 * @return {TypeString}
	 */
	TypeString.prototype.optional = function() {
	  this._options.enforce_missing = false;
	  return this;
	}


	/**
	 * Set the property as required (enforce_missing = true).
	 * Leaves other existing options unchanged.
	 * @return {TypeString}
	 */
	TypeString.prototype.required = function() {
	  this._options.enforce_missing = true;
	  return this;
	}


	/**
	 * Set the property as not strict (null allowed, enforce_missing = true).
	 * Leaves other existing options unchanged.
	 * @return {TypeString}
	 */
	TypeString.prototype.allowNull = function(value) {
	  if (this._options.enforce_type === 'strict') {
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    // else a no-op, strict -> strict
	  }
	  else if (this._options.enforce_type !== 'none') {
	    // The value is loose or undefined
	    if (value === true) {
	      this._options.enforce_type = 'loose'
	    }
	    else {
	      // The default value is loose, so if we call allowNull(false), it becomes strict
	      this._options.enforce_type = 'strict'
	    }
	  }
	  // else no op, type.any() is the same as type.any().allowNull(<bool>)
	  return this;
	}


	/**
	 * Set the minimum length allowed for a string.
	 * @param {number} min Minimum length for the string
	 * @return {TypeString}
	 */
	TypeString.prototype.min = function(min) {
	  if (min < 0) {
	    throw new Errors.ValidationError("The value for `min` must be a positive integer");
	  }
	  this._min = min;
	  return this;
	}


	/**
	 * Set the maximum length allowed for a string.
	 * @param {number} min Minimum length for the string
	 * @return {TypeString}
	 */
	TypeString.prototype.max = function(max) {
	  if (max < 0) {
	    throw new Errors.ValidationError("The value for `max` must be a positive integer");
	  }
	  this._max = max;
	  return this;
	}


	/**
	 * Set the length allowed for a string.
	 * @param {number} min Minimum length for the string
	 * @return {TypeString}
	 */
	TypeString.prototype.length = function(length) {
	  if (length < 0) {
	    throw new Errors.ValidationError("The value for `length` must be a positive integer");
	  }
	  this._length = length;
	  return this;
	}


	/**
	 * Set the regex that the string must match.
	 * @param {string} regex The string representation of the regex
	 * @param {string} flags The flags used when calling new RegExp(...)
	 * @return {TypeString}
	 */
	TypeString.prototype.regex = function(regex, flags) {
	  if (typeof flags === "string") {
	    this._regex = new RegExp(regex, flags);
	  }
	  else {
	    this._regex = new RegExp(regex);
	  }
	  return this;
	}


	/**
	 * Set the string to be alphanumeric.
	 * @return {TypeString}
	 */
	TypeString.prototype.alphanum = function() {
	  this._alphanum = true;
	  return this;
	}


	/**
	 * Set the string to be an email.
	 * @return {TypeString}
	 */
	TypeString.prototype.email = function() {
	  this._email = true;
	  return this;
	}


	/**
	 * Set the string to be lowercase.
	 * @return {TypeString}
	 */
	TypeString.prototype.lowercase = function() {
	  this._lowercase = true;
	  return this;
	}


	/**
	 * Set the string to be uppercase.
	 * @return {TypeString}
	 */
	TypeString.prototype.uppercase = function() {
	  this._uppercase = true;
	  return this;
	}


	/**
	 * Set the default value for this string, or the function that will generate
	 * the default value
	 * @param {string|function} fnOrValue
	 * @return {TypeString}
	 */
	TypeString.prototype.default = function(fnOrValue) {
	  this._default = fnOrValue;
	  return this;
	}


	/**
	 * Set a custom validator that will be called with the string. The validator
	 * should return a boolean whether the field is valid or not.
	 * @param {function} fn
	 * @return {TypeString}
	 */
	TypeString.prototype.validator = function(fn) {
	  if (typeof fn === "function") {
	    this._validator = fn;
	  }
	  return this;
	}


	/**
	 * Set the valid values for this field. The arguments must be strings
	 * or an array of strings.
	 * @param {...string|Array.<string>} fn
	 * @return {TypeString}
	 */
	TypeString.prototype.enum = function() {
	  if ((arguments.length === 1) && (Array.isArray(arguments[0]))) {
	    this._enum = {};
	    for(var i=0; i<arguments[0].length; i++) {
	      this._enum[arguments[0][i]] = true;
	    }
	  }
	  else if ((arguments.length !== 1) || (arguments[0] !== undefined)) {
	    this._enum = {};
	    for(var i=0; i<arguments.length; i++) {
	      this._enum[arguments[i]] = true;
	    }
	  }
	  return this;
	}


	/**
	 * Validate the string given optional options, and throw an error in case
	 * the field is not valid.
	 * @param {string} str The string to validate.
	 * @param {string} prefix The prefix leading to `str`.
	 * @param {object=} options Options to overwrite the one defined for the field.
	 * @throws {Error}
	 */
	TypeString.prototype.validate = function(str, prefix, options) {
	  var _options = util.mergeOptions(this._options, options);

	  if (util.validateIfUndefined(str, prefix, "string", _options)) return;

	  if ((typeof this._validator === "function") && (this._validator(str) === false)) {
	    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
	  }


	  if ((typeof str === 'function') && (str._query !== undefined)) {
	    // We do not check ReQL terms
	  }
	  else if (typeof str !== "string") {
	    if (_options.enforce_type === "strict") {
	      util.strictType(prefix, "string");
	    }
	    else if ((_options.enforce_type === "loose") && (str !== null)) {
	      util.looseType(prefix, "string");
	    }
	  }
	  else {
	    if ((this._min !== -1) && (this._min > str.length)){
	      throw new Errors.ValidationError("Value for "+prefix+" must be longer than "+this._min+".")
	    }
	    if ((this._max !== -1) && (this._max < str.length)){
	      throw new Errors.ValidationError("Value for "+prefix+" must be shorter than "+this._max+".")
	    }
	    if ((this._length !== -1) && (this._length !== str.length)){
	      throw new Errors.ValidationError("Value for "+prefix+" must be a string with "+this._length+" characters.")
	    }
	    if ((this._regex instanceof RegExp) && (this._regex.test(str) === false)) {
	      throw new Errors.ValidationError("Value for "+prefix+" must match the regex.")
	    }
	    if ((this._alphanum === true) && (validator.isAlphanumeric(str) === false)) {
	      throw new Errors.ValidationError("Value for "+prefix+" must be an alphanumeric string.")
	    }
	    if ((this._email === true) && (validator.isEmail(str) === false)) {
	      throw new Errors.ValidationError("Value for "+prefix+" must be a valid email.")
	    }
	    if ((this._lowercase === true) && (validator.isLowercase(str) === false)) {
	      throw new Errors.ValidationError("Value for "+prefix+" must be a lowercase string.")
	    }
	    if ((this._uppercase === true) && (validator.isUppercase(str) === false)) {
	      throw new Errors.ValidationError("Value for "+prefix+" must be a uppercase string.")
	    }
	    if ((this._enum !== undefined) && (this._enum[str] !== true)) {
	      var validValues = Object.keys(this._enum);
	      var message = "The field "+prefix+" must be one of these values: "

	      for(var i=0; i<validValues.length; i++) {
	        if (i === 10) { break; }
	        if ((i === validValues.length-1) || (i === 9)) {
	          message = message+validValues[i]
	        }
	        else {
	          message = message+validValues[i]+", "
	        }
	      }
	      if (validValues.length > 10) {
	        message = message+"..."
	      }
	      else {
	        message = message+"."
	      }

	      throw new Errors.ValidationError(message);
	    }
	  }
	}


	/**
	 * Look for a default value or default function, and append an object to `defaultFields`.
	 * @param {string} prefix The prefix leading to `str`.
	 * @param {Array.<Object>} defaultFields The default fields to generate
	 * @param {Array.<Object>} virtualFields The virtual fields to generate
	 * @return {TypeString}
	 */
	TypeString.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
	  if (this._default !== undefined) {
	    defaultFields.push({
	      path: prefix,
	      value: this._default,
	    });
	  }
	  return this;
	}


	module.exports = TypeString;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2014 Chris O'Hara <cohara87@gmail.com>
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * "Software"), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */

	(function (name, definition) {
	    if (true) {
	        module.exports = definition();
	    } else if (typeof define === 'function' && typeof define.amd === 'object') {
	        define(definition);
	    } else {
	        this[name] = definition();
	    }
	})('validator', function (validator) {

	    'use strict';

	    validator = { version: '3.22.2' };

	    var email = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;

	    var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/;

	    var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/
	      , isbn13Maybe = /^(?:[0-9]{13})$/;

	    var ipv4Maybe = /^(\d?\d?\d)\.(\d?\d?\d)\.(\d?\d?\d)\.(\d?\d?\d)$/
	      , ipv6 = /^::|^::1|^([a-fA-F0-9]{1,4}::?){1,7}([a-fA-F0-9]{1,4})$/;

	    var uuid = {
	        '3': /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i
	      , '4': /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i
	      , '5': /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i
	      , all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
	    };

	    var alpha = /^[a-zA-Z]+$/
	      , alphanumeric = /^[a-zA-Z0-9]+$/
	      , numeric = /^-?[0-9]+$/
	      , int = /^(?:-?(?:0|[1-9][0-9]*))$/
	      , float = /^(?:-?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/
	      , hexadecimal = /^[0-9a-fA-F]+$/
	      , hexcolor = /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/;

	    var ascii = /^[\x00-\x7F]+$/
	      , multibyte = /[^\x00-\x7F]/
	      , fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/
	      , halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;

	    var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;

	    var base64 = /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/;

	    validator.extend = function (name, fn) {
	        validator[name] = function () {
	            var args = Array.prototype.slice.call(arguments);
	            args[0] = validator.toString(args[0]);
	            return fn.apply(validator, args);
	        };
	    };

	    //Right before exporting the validator object, pass each of the builtins
	    //through extend() so that their first argument is coerced to a string
	    validator.init = function () {
	        for (var name in validator) {
	            if (typeof validator[name] !== 'function' || name === 'toString' ||
	                    name === 'toDate' || name === 'extend' || name === 'init') {
	                continue;
	            }
	            validator.extend(name, validator[name]);
	        }
	    };

	    validator.toString = function (input) {
	        if (typeof input === 'object' && input !== null && input.toString) {
	            input = input.toString();
	        } else if (input === null || typeof input === 'undefined' || (isNaN(input) && !input.length)) {
	            input = '';
	        } else if (typeof input !== 'string') {
	            input += '';
	        }
	        return input;
	    };

	    validator.toDate = function (date) {
	        if (Object.prototype.toString.call(date) === '[object Date]') {
	            return date;
	        }
	        date = Date.parse(date);
	        return !isNaN(date) ? new Date(date) : null;
	    };

	    validator.toFloat = function (str) {
	        return parseFloat(str);
	    };

	    validator.toInt = function (str, radix) {
	        return parseInt(str, radix || 10);
	    };

	    validator.toBoolean = function (str, strict) {
	        if (strict) {
	            return str === '1' || str === 'true';
	        }
	        return str !== '0' && str !== 'false' && str !== '';
	    };

	    validator.equals = function (str, comparison) {
	        return str === validator.toString(comparison);
	    };

	    validator.contains = function (str, elem) {
	        return str.indexOf(validator.toString(elem)) >= 0;
	    };

	    validator.matches = function (str, pattern, modifiers) {
	        if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
	            pattern = new RegExp(pattern, modifiers);
	        }
	        return pattern.test(str);
	    };

	    validator.isEmail = function (str) {
	        return email.test(str);
	    };

	    var default_url_options = {
	        protocols: [ 'http', 'https', 'ftp' ]
	      , require_tld: true
	      , require_protocol: false
	      , allow_underscores: false
	    };

	    validator.isURL = function (url, options) {
	        if (!url || url.length >= 2083) {
	            return false;
	        }
	        if (url.indexOf('mailto:') === 0) {
	            return false;
	        }
	        options = merge(options, default_url_options);
	        var protocol, user, pass, auth, host, hostname, port,
	            port_str, path, query, hash, split;
	        split = url.split('://');
	        if (split.length > 1) {
	            protocol = split.shift();
	            if (options.protocols.indexOf(protocol) === -1) {
	                return false;
	            }
	        } else if (options.require_protocol) {
	            return false;
	        }
	        url = split.join('://');
	        split = url.split('#');
	        url = split.shift();
	        hash = split.join('#');
	        if (hash && /\s/.test(hash)) {
	            return false;
	        }
	        split = url.split('?');
	        url = split.shift();
	        query = split.join('?');
	        if (query && /\s/.test(query)) {
	            return false;
	        }
	        split = url.split('/');
	        url = split.shift();
	        path = split.join('/');
	        if (path && /\s/.test(path)) {
	            return false;
	        }
	        split = url.split('@');
	        if (split.length > 1) {
	            auth = split.shift();
	            if (auth.indexOf(':') >= 0) {
	                auth = auth.split(':');
	                user = auth.shift();
	                if (!/^\S+$/.test(user)) {
	                    return false;
	                }
	                pass = auth.join(':');
	                if (!/^\S*$/.test(user)) {
	                    return false;
	                }
	            }
	        }
	        hostname = split.join('@');
	        split = hostname.split(':');
	        host = split.shift();
	        if (split.length) {
	            port_str = split.join(':');
	            port = parseInt(port_str, 10);
	            if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
	                return false;
	            }
	        }
	        if (!validator.isIP(host) && !validator.isFQDN(host, options) &&
	                host !== 'localhost') {
	            return false;
	        }
	        if (options.host_whitelist &&
	                options.host_whitelist.indexOf(host) === -1) {
	            return false;
	        }
	        if (options.host_blacklist &&
	                options.host_blacklist.indexOf(host) !== -1) {
	            return false;
	        }
	        return true;
	    };

	    validator.isIP = function (str, version) {
	        version = validator.toString(version);
	        if (!version) {
	            return validator.isIP(str, 4) || validator.isIP(str, 6);
	        } else if (version === '4') {
	            if (!ipv4Maybe.test(str)) {
	                return false;
	            }
	            var parts = str.split('.').sort(function (a, b) {
	                return a - b;
	            });
	            return parts[3] <= 255;
	        }
	        return version === '6' && ipv6.test(str);
	    };

	    var default_fqdn_options = {
	        require_tld: true
	      , allow_underscores: false
	    };

	    validator.isFQDN = function (str, options) {
	        options = merge(options, default_fqdn_options);
	        var parts = str.split('.');
	        if (options.require_tld) {
	            var tld = parts.pop();
	            if (!parts.length || !/^[a-z]{2,}$/i.test(tld)) {
	                return false;
	            }
	        }
	        for (var part, i = 0; i < parts.length; i++) {
	            part = parts[i];
	            if (options.allow_underscores) {
	                if (part.indexOf('__') >= 0) {
	                    return false;
	                }
	                part = part.replace(/_/g, '');
	            }
	            if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
	                return false;
	            }
	            if (part[0] === '-' || part[part.length - 1] === '-' ||
	                    part.indexOf('---') >= 0) {
	                return false;
	            }
	        }
	        return true;
	    };

	    validator.isAlpha = function (str) {
	        return alpha.test(str);
	    };

	    validator.isAlphanumeric = function (str) {
	        return alphanumeric.test(str);
	    };

	    validator.isNumeric = function (str) {
	        return numeric.test(str);
	    };

	    validator.isHexadecimal = function (str) {
	        return hexadecimal.test(str);
	    };

	    validator.isHexColor = function (str) {
	        return hexcolor.test(str);
	    };

	    validator.isLowercase = function (str) {
	        return str === str.toLowerCase();
	    };

	    validator.isUppercase = function (str) {
	        return str === str.toUpperCase();
	    };

	    validator.isInt = function (str) {
	        return int.test(str);
	    };

	    validator.isFloat = function (str) {
	        return str !== '' && float.test(str);
	    };

	    validator.isDivisibleBy = function (str, num) {
	        return validator.toFloat(str) % validator.toInt(num) === 0;
	    };

	    validator.isNull = function (str) {
	        return str.length === 0;
	    };

	    validator.isLength = function (str, min, max) {
	        var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
	        var len = str.length - surrogatePairs.length;
	        return len >= min && (typeof max === 'undefined' || len <= max);
	    };

	    validator.isByteLength = function (str, min, max) {
	        return str.length >= min && (typeof max === 'undefined' || str.length <= max);
	    };

	    validator.isUUID = function (str, version) {
	        var pattern = uuid[version ? version : 'all'];
	        return pattern && pattern.test(str);
	    };

	    validator.isDate = function (str) {
	        return !isNaN(Date.parse(str));
	    };

	    validator.isAfter = function (str, date) {
	        var comparison = validator.toDate(date || new Date())
	          , original = validator.toDate(str);
	        return !!(original && comparison && original > comparison);
	    };

	    validator.isBefore = function (str, date) {
	        var comparison = validator.toDate(date || new Date())
	          , original = validator.toDate(str);
	        return original && comparison && original < comparison;
	    };

	    validator.isIn = function (str, options) {
	        if (!options || typeof options.indexOf !== 'function') {
	            return false;
	        }
	        if (Object.prototype.toString.call(options) === '[object Array]') {
	            var array = [];
	            for (var i = 0, len = options.length; i < len; i++) {
	                array[i] = validator.toString(options[i]);
	            }
	            options = array;
	        }
	        return options.indexOf(str) >= 0;
	    };

	    validator.isCreditCard = function (str) {
	        var sanitized = str.replace(/[^0-9]+/g, '');
	        if (!creditCard.test(sanitized)) {
	            return false;
	        }
	        var sum = 0, digit, tmpNum, shouldDouble;
	        for (var i = sanitized.length - 1; i >= 0; i--) {
	            digit = sanitized.substring(i, (i + 1));
	            tmpNum = parseInt(digit, 10);
	            if (shouldDouble) {
	                tmpNum *= 2;
	                if (tmpNum >= 10) {
	                    sum += ((tmpNum % 10) + 1);
	                } else {
	                    sum += tmpNum;
	                }
	            } else {
	                sum += tmpNum;
	            }
	            shouldDouble = !shouldDouble;
	        }
	        return !!((sum % 10) === 0 ? sanitized : false);
	    };

	    validator.isISBN = function (str, version) {
	        version = validator.toString(version);
	        if (!version) {
	            return validator.isISBN(str, 10) || validator.isISBN(str, 13);
	        }
	        var sanitized = str.replace(/[\s-]+/g, '')
	          , checksum = 0, i;
	        if (version === '10') {
	            if (!isbn10Maybe.test(sanitized)) {
	                return false;
	            }
	            for (i = 0; i < 9; i++) {
	                checksum += (i + 1) * sanitized.charAt(i);
	            }
	            if (sanitized.charAt(9) === 'X') {
	                checksum += 10 * 10;
	            } else {
	                checksum += 10 * sanitized.charAt(9);
	            }
	            if ((checksum % 11) === 0) {
	                return !!sanitized;
	            }
	        } else  if (version === '13') {
	            if (!isbn13Maybe.test(sanitized)) {
	                return false;
	            }
	            var factor = [ 1, 3 ];
	            for (i = 0; i < 12; i++) {
	                checksum += factor[i % 2] * sanitized.charAt(i);
	            }
	            if (sanitized.charAt(12) - ((10 - (checksum % 10)) % 10) === 0) {
	                return !!sanitized;
	            }
	        }
	        return false;
	    };

	    validator.isJSON = function (str) {
	        try {
	            JSON.parse(str);
	        } catch (e) {
	            return false;
	        }
	        return true;
	    };

	    validator.isMultibyte = function (str) {
	        return multibyte.test(str);
	    };

	    validator.isAscii = function (str) {
	        return ascii.test(str);
	    };

	    validator.isFullWidth = function (str) {
	        return fullWidth.test(str);
	    };

	    validator.isHalfWidth = function (str) {
	        return halfWidth.test(str);
	    };

	    validator.isVariableWidth = function (str) {
	        return fullWidth.test(str) && halfWidth.test(str);
	    };

	    validator.isSurrogatePair = function (str) {
	        return surrogatePair.test(str);
	    };

	    validator.isBase64 = function (str) {
	        return base64.test(str);
	    };

	    validator.isMongoId = function (str) {
	        return validator.isHexadecimal(str) && str.length === 24;
	    };

	    validator.ltrim = function (str, chars) {
	        var pattern = chars ? new RegExp('^[' + chars + ']+', 'g') : /^\s+/g;
	        return str.replace(pattern, '');
	    };

	    validator.rtrim = function (str, chars) {
	        var pattern = chars ? new RegExp('[' + chars + ']+$', 'g') : /\s+$/g;
	        return str.replace(pattern, '');
	    };

	    validator.trim = function (str, chars) {
	        var pattern = chars ? new RegExp('^[' + chars + ']+|[' + chars + ']+$', 'g') : /^\s+|\s+$/g;
	        return str.replace(pattern, '');
	    };

	    validator.escape = function (str) {
	        return (str.replace(/&/g, '&amp;')
	            .replace(/"/g, '&quot;')
	            .replace(/'/g, '&#x27;')
	            .replace(/</g, '&lt;')
	            .replace(/>/g, '&gt;'));
	    };

	    validator.stripLow = function (str, keep_new_lines) {
	        var chars = keep_new_lines ? '\x00-\x09\x0B\x0C\x0E-\x1F\x7F' : '\x00-\x1F\x7F';
	        return validator.blacklist(str, chars);
	    };

	    validator.whitelist = function (str, chars) {
	        return str.replace(new RegExp('[^' + chars + ']+', 'g'), '');
	    };

	    validator.blacklist = function (str, chars) {
	        return str.replace(new RegExp('[' + chars + ']+', 'g'), '');
	    };

	    var default_normalize_email_options = {
	        lowercase: true
	    };

	    validator.normalizeEmail = function (email, options) {
	        options = merge(options, default_normalize_email_options);
	        if (!validator.isEmail(email)) {
	            return false;
	        }
	        var parts = email.split('@', 2);
	        parts[1] = parts[1].toLowerCase();
	        if (options.lowercase) {
	            parts[0] = parts[0].toLowerCase();
	        }
	        if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
	            if (!options.lowercase) {
	                parts[0] = parts[0].toLowerCase();
	            }
	            parts[0] = parts[0].replace(/\./g, '').split('+')[0];
	            parts[1] = 'gmail.com';
	        }
	        return parts.join('@');
	    };

	    function merge(obj, defaults) {
	        obj = obj || {};
	        for (var key in defaults) {
	            if (typeof obj[key] === 'undefined') {
	                obj[key] = defaults[key];
	            }
	        }
	        return obj;
	    }

	    validator.init();

	    return validator;

	});


/***/ },
/* 79 */
/***/ function(module, exports) {

	function TypeVirtual() {
	  this._default = undefined;
	  this._validator = undefined;
	  this._options = {};
	}


	TypeVirtual.prototype.default = function(fnOrValue) {
	  this._default = fnOrValue;
	  return this;
	}


	// Dummy functions
	TypeVirtual.prototype.validate = function() {}


	TypeVirtual.prototype.options = function() {}


	TypeVirtual.prototype.optional = function() {}


	TypeVirtual.prototype.required = function() {}


	TypeVirtual.prototype.allowNull = function() {}


	TypeVirtual.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
	  // We keep track of virtual fields even if there is no default value
	  virtualFields.push({
	    path: prefix,
	    value: this._default,
	  });
	}

	module.exports = TypeVirtual;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var schemaUtil =    __webpack_require__(67);
	var type =          __webpack_require__(68);
	var util =          __webpack_require__(65);
	var Promise =       __webpack_require__(29);
	var EventEmitter =  __webpack_require__(8).EventEmitter;
	var Errors =        __webpack_require__(66);


	/**
	 * Create a document of a model (returned by `thinky.createModel`).
	 * @param {function} model The model of this document
	 * @param {object=} options Options that can overwrite the ones of the model
	 */
	function Document(model, options) {
	  var self = this;  // Keep a reference to itself.

	  this.constructor = model;  // The constructor for this model
	  this._model = model._getModel(); // The instance of Model

	  // We don't want to store options if they are different
	  // than the one provided by the model
	  if (util.isPlainObject(options)) {
	    this._schemaOptions = {};
	    this._schemaOptions.enforce_missing =
	        (options.enforce_missing != null) ? options.enforce_missing : model.getOptions().enforce_missing;
	    this._schemaOptions.enforce_extra =
	        (options.enforce_extra != null) ? options.enforce_extra : model.getOptions().enforce_extra;
	    this._schemaOptions.enforce_type =
	        (options.enforce_type != null) ? options.enforce_type : model.getOptions().enforce_type;
	  }

	  //TODO: We do not need to make a deep copy. We can do the same as for this._schemaOptions.
	  options = options || {};
	  this._options = {};
	  this._options.timeFormat = (options.timeFormat != null) ? options.timeFormat : model.getOptions().timeFormat;
	  this._options.validate = (options.validate != null) ? options.validate : model.getOptions().validate;

	  this._saved = options.saved || false;  // Whether the document is saved or not

	  util.bindEmitter(self);  // Copy methods from eventEmitter

	  // links to hasOne/hasMany documents
	  // We use it to know if some links have been removed/added before saving.
	  // Example: { key: doc } or { key: [docs] }
	  this._belongsTo = {};
	  this._hasOne = {};
	  this._hasMany = {};
	  // Example: { <linkTableName>: { <valueOfRightKey>: true, ... }, ... }
	  this._links = {}

	  // Keep reference of any doc having a link pointing to this
	  // So we can clean when users do doc.belongsToDoc.delete()
	  this._parents = {
	    _hasOne: {},      // <tableName>: [{doc, key}]
	    _hasMany: {},     // <tableName>: [{doc, key}]
	    _belongsTo: {},   // <tableName>: [{doc, key, foreignKey}]
	    _belongsLinks: {} // <tableName>: [{doc, key}]
	  }

	  // Bind listeners of the model to this documents.
	  util.loopKeys(model._listeners, function(listeners, eventKey) {
	    for(var j=0; j<listeners[eventKey].length; j++) {
	      if (listeners[eventKey][j].once === false) {
	        self.addListener(eventKey, listeners[eventKey][j].listener);
	      }
	      else if (listeners[eventKey][j].once === true) {
	        self.once(eventKey, listeners[eventKey][j].listener);
	      }
	    }
	  });


	  // Atom feed
	  this._active = false;
	  this._feed = null;

	  // Add customized methods of the model on this document.
	  util.loopKeys(model._methods, function(methods, key) {
	    if (self[key] === undefined) {
	      self[key] = methods[key];
	    }
	    else {
	      //TODO: Should we warn the users? Throw an error?
	      console.log(self[key]);
	      console.log("A property "+key+" is already defined in the prototype chain. Skipping.");
	    }
	  });
	}


	/**
	 * Return the options of the document, not the instance of Document.
	 * @return {Object=}
	 */
	Document.prototype._getOptions = function() {
	  return this.__proto__._options;
	}


	/**
	 * Return the options for the schema of the document, not the instance of Document.
	 * @return {Object=}
	 */
	Document.prototype._getSchemaOptions = function() {
	  return this.__proto__._schemaOptions;
	}


	/**
	 * Return the constructor of the document, not the instance of Document.
	 * @return {function}
	 */
	Document.prototype.getModel = function() {
	  return this.__proto__.constructor;
	}


	/**
	 * Return the model, the instance of Model
	 * @return {function}
	 */
	Document.prototype._getModel = function() {
	  return this.__proto__._model;
	}


	/**
	 * Save the virtual fields of the document to be re-injected later.
	 */
	Document.prototype._saveVirtual = function() {
	  var copy = {};
	  var model = this._getModel(); // instance of Model

	  // TODO We could do better and copy less things, but things get a bit tricky
	  // when virtual fields are nested in arrays.
	  // This implementation still allows no overhead if no virtual fields exist,
	  // which should be the most common case
	  for(var i=0; i<this._getModel().virtualFields.length; i++) {
	    var key = this._getModel().virtualFields[i].path[0];
	    copy[key] = this[key];
	  }
	  this.__proto__.virtualValue = util.deepCopy(copy);
	}


	/**
	 * Get the virtual fields saved by `_saveVirtual`.
	 * @return {Object=}
	 */
	Document.prototype._getVirtual = function() {
	  return this.__proto__.virtualValue;
	}

	/**
	 * Generate the virtual values for the document, or re-inject the ones
	 * previously saved.
	 * This should be called **after** `_generateDefault`.
	 */
	Document.prototype.generateVirtualValues = function() {
	  for(var i=0; i<this._getModel().virtualFields.length; i++) {
	    schemaUtil.generateVirtual(this, this._getModel().virtualFields[i], this, this._getVirtual());
	  }
	}


	/**
	 * Generate the default values for the document, first the non virtual fields, and then
	 * the virtual fields.
	 */
	Document.prototype._generateDefault = function() {
	  for(var i=0; i<this._getModel().defaultFields.length; i++) {
	    schemaUtil.generateDefault(this, this._getModel().defaultFields[i], this);
	  }
	  if (this._getModel().virtualFields.length > 0) {
	    this.generateVirtualValues();
	  }
	}


	/*
	 * Validate this document against the schema of its model and triggers all the hooks.
	 * @param {Object=} options Options to overwrite the ones of the document.
	 * @param {Object=} modelToValidate Internal parameter, model to validate
	 * @param {boolean=} validateAll Internal parameter, Option to keep recursing as long as no non-circular model have been found.
	 * @param {Object=} validatedModel Internal parameter, All the models for which we already validated at least one document.
	 * @param {string=} prefix Internal parameter, The current path to this path (used in case of joined documents).
	 * @return {Promise=} return a promise if the validation is asynchrone, else undefined.
	 */
	Document.prototype.validate = function(options, modelToValidate, validateAll, validatedModel, prefix) {
	  modelToValidate = modelToValidate || {};
	  validateAll = validateAll || false;
	  validatedModel = validatedModel || {};
	  prefix = prefix || '';

	  var self = this;
	  var validatedModelCopy = util.deepCopy(validatedModel);

	  //TODO: Can we not always call this?
	  var async = self._validateIsAsync(modelToValidate, validateAll, validatedModelCopy);

	  return util.hook({
	    preHooks: self._getModel()._pre.validate,
	    postHooks: self._getModel()._post.validate,
	    doc: self,
	    async: async,
	    fn: self._validateHook,
	    fnArgs: [options, modelToValidate, validateAll, validatedModel, prefix]
	  })
	}


	/*
	 * Validate this document against the schema of its model and all its joined documents and triggers all the hooks
	 * @param {Object=} options Options to overwrite the ones of the document.
	 * @param {Object=} modelToValidate Internal parameter, model to validate
	 * @return {Promise=} return a promise if the validation is asynchrone, else undefined.
	 */
	Document.prototype.validateAll = function(options, modelToValidate) {
	  var validateAll = modelToValidate === undefined;
	  modelToValidate = modelToValidate || {};

	  return this.validate(options, modelToValidate, validateAll, {}, '', true);
	}


	/*
	 * Internal methods that will validate the document (but that will not execute the hooks).
	 * @param {Object=} options Options to overwrite the ones of the document.
	 * @param {Object=} modelToValidate Internal parameter, model to validate
	 * @param {boolean=} validateAll Internal parameter, Option to keep recursing as long as no non-circular model have been found.
	 * @param {Object=} validatedModel Internal parameter, All the models for which we already validated at least one document.
	 * @param {string=} prefix Internal parameter, The current path to this path (used in case of joined documents).
	 * @return {Promise=} return a promise if the validation is asynchrone, else undefined.
	 */
	Document.prototype._validateHook = function(options, modelToValidate, validateAll, validatedModel, prefix) {
	  var self = this;
	  var promises = [];
	  var error;

	  var schemaOptions = self._getSchemaOptions();
	  if (util.isPlainObject(schemaOptions)) {
	    schemaOptions = util.mergeOptions(schemaOptions, options);
	  }
	  else {
	    schemaOptions = options;
	  }


	  if (typeof self._getModel()._validator === 'function') {
	    if (self._getModel()._validator.call(self, self) === false) {
	      throw new Errors.ValidationError("Document's validator returned `false`.");
	    }
	  }

	  // Validate this document
	  self._getModel()._schema.validate(self, prefix, schemaOptions)

	  if (util.isPlainObject(modelToValidate) === false) {
	    modelToValidate = {};
	  }

	  var constructor = self.__proto__.constructor;
	  validatedModel[constructor.getTableName()] = true;

	  // Validate joined documents
	  util.loopKeys(self._getModel()._joins, function(joins, key) {
	    if (util.recurse(key, joins, modelToValidate, validateAll, validatedModel)) {
	      switch (joins[key].type) {
	        case 'hasOne':
	        case 'belongsTo':
	          if (util.isPlainObject(self[key])) {
	            if (self[key] instanceof Document === false) {
	              self[key] = new self._getModel()._joins[key].model(self[key]);
	            }
	            // We do not propagate the options of this document, but only those given to validate
	            var promise = self[key].validate(options, modelToValidate[key], validateAll, validatedModel, prefix+'['+key+']');
	            if (promise instanceof Promise) {
	              promises.push(promise);
	              promise = null;
	            }
	          }
	          else if (self[key] != null) {
	            throw new Errors.ValidationError("Joined field "+prefix+"["+key+"] should be `undefined`, `null` or an `Object`")
	          }
	          break;

	        case 'hasMany':
	        case 'hasAndBelongsToMany':
	          if (Array.isArray(self[key])) {
	            for(var i=0; i<self[key].length; i++) {
	              if (util.isPlainObject(self[key][i])) {
	                if (self[key][i] instanceof Document === false) {
	                  self[key][i] = new self._getModel()._joins[key].model(self[key][i]);
	                }
	                promise = self[key][i].validate(options, modelToValidate[key], validateAll, validatedModel, prefix+'['+key+']['+i+']');
	                if (promise instanceof Promise) {
	                  promises.push(promise);
	                  promise = null;
	                }
	              }
	              else {
	                throw new Errors.ValidationError("Joined field "+prefix+"["+key+"]["+i+"] should be `undefined`, `null` or an `Array`")
	              }
	            }
	          }
	          else if (self[key] != null) {
	            throw new Errors.ValidationError("Joined field "+prefix+"["+key+"] should be `undefined`, `null` or an `Array`")
	          }
	          break;
	      }
	    }
	  });
	  if (promises.length > 0) {
	    return Promise.all(promises);
	  }
	}


	/*
	 * Return whether the validation run with the same options will be asynchronous or not.
	 * @param {Object=} modelToValidate Internal parameter, model to validate
	 * @param {boolean=} validateAll Internal parameter, Option to keep recursing as long as no non-circular model have been found.
	 * @param {Object=} validatedModel Internal parameter, All the models for which we already validated at least one document.
	 * @return {boolean}
	 */
	Document.prototype._validateIsAsync = function(modelToValidate, validateAll, validatedModel) {
	  var self = this;

	  if (self._getModel()._async.validate) {
	    return true;
	  }
	  var async = false;
	  util.loopKeys(self._getModel()._joins, function(joins, key) {
	    if (util.recurse(key, joins, modelToValidate, validateAll, validatedModel)) {
	      if (((joins[key].type === 'hasOne') || (joins[key].type === 'belongsTo'))) {
	        if (util.isPlainObject(self[key])) {
	          if (self[key] instanceof Document === false) {
	            self[key] = new self._getModel()._joins[key].model(self[key]);
	          }
	          // We do not propagate the options of this document, but only those given to validate
	          if (self[key]._getModel()._async.validate || self[key]._validateIsAsync(modelToValidate, validateAll, validatedModel)) {
	            async = true;
	            return false;
	          }
	        }
	      }
	      else  if (((joins[key].type === 'hasMany') || (joins[key].type === 'hasAndBelongsToMany'))) {
	        if (Array.isArray(self[key])) {
	          for(var i=0; i<self[key].length; i++) {
	            if (util.isPlainObject(self[key][i])) {
	              if (self[key][i] instanceof Document === false) {
	                self[key][i] = new self._getModel()._joins[key].model(self[key][i]);
	              }
	              if (self[key][i]._getModel()._async.validate || self[key][i]._validateIsAsync(modelToValidate, validateAll, validatedModel)) {
	                async = true;
	                return false;
	              }
	            }
	          }
	        }
	      }
	    }
	    return false;
	  });
	  return async;
	}


	/**
	 * Save the document and execute the hooks. Return a promise if the callback
	 * is not provided.
	 * @param {function=} callback to execute
	 * @return {Promise=}
	 */
	Document.prototype.save = function(callback) {
	  return this._save({}, false, {}, callback);
	}


	/**
	 * Save the document and its joined documents. It will also execute the hooks.
	 * Return a promise if the callback is not provided.
	 * It will save joined documents as long as a document of th esame model has not
	 * been saved.
	 * @param {function=} callback to execute
	 * @return {Promise=}
	 */
	Document.prototype.saveAll = function(docToSave, callback) {
	  var saveAll;
	  if (typeof docToSave === 'function') {
	    callback = docToSave;
	    saveAll = true;
	    docToSave = {};
	  }
	  else {
	    saveAll = docToSave === undefined;
	    docToSave = docToSave || {};
	  }

	  return this._save(docToSave, saveAll,{}, callback);
	}


	/**
	 * Return a savable copy of the document by removing the extra fields,
	 * generating the dfault and virtual fields.
	 * @return {object}
	 */
	Document.prototype._makeSavableCopy = function() {
	  var model = this._getModel(); // instance of Model
	  var schema = this._getModel()._schema;

	  var r = this._getModel()._thinky.r;

	  if (this._getModel().needToGenerateFields === true){
	    this._generateDefault();
	  }

	  return this.__makeSavableCopy(this, schema, this._getOptions(), model, r)
	}


	/**
	 * Internal helper for _makeSavableCopy.
	 * generating the dfault and virtual fields.
	 * @return {any} the copy of the field/object.
	 */
	Document.prototype.__makeSavableCopy = function(doc, schema, options, model, r) {
	  var localOptions; // can be undefined
	  if (schema !== undefined) {
	    localOptions = schema._options;
	  }

	  // model is an instance of a Model (for the top level fields), or undefined
	  var result, key, keys, nextSchema, copyFlag;
	  if (type.isDate(schema) && (typeof doc === 'string' || typeof doc === 'number')) {
	    if (typeof doc === 'number') {
	      var numericDate = parseInt(doc, 10);
	      if(!isNaN(numericDate)) {
	        doc = numericDate;
	      }
	    }
	    return new Date(doc); // Use r.ISO8601 and not `new Date()` to keep timezone
	  }
	  else if (type.isPoint(schema)) {
	    if (util.isPlainObject(doc) && (doc['$reql_type$'] !== "GEOMETRY")) {
	      var keys = Object.keys(doc).sort();
	      if ((keys.length === 2) && (keys[0] === 'latitude') && (keys[1] === 'longitude') && (typeof doc.latitude === "number") && (typeof doc.longitude === "number")) {
	        return r.point(doc.longitude, doc.latitude)
	      }
	      else if ((doc.type === "Point") && (Array.isArray(doc.coordinates)) && (doc.coordinates.length === 2)) { // Geojson
	        return r.geojson(doc)
	      }
	    }
	    else if (Array.isArray(doc)) {
	      if ((doc.length === 2) && (typeof doc[0] === "number") && (typeof doc[1] === "number")) {
	        return r.point(doc[0], doc[1])
	      }
	    }
	    else { // no transformation are required here, return doc
	      return doc;
	    }
	  }
	  else if (type.isNumber(schema) && (typeof doc === 'string')) {
	    var numericString = parseFloat(doc);
	    if(!isNaN(numericString)){
	      return numericString;
	    }else{
	      return doc;
	    }
	  }

	  if (util.isPlainObject(doc) && (doc instanceof Buffer === false)) {
	    result = {};
	    util.loopKeys(doc, function(doc, key) {
	      copyFlag = true;
	      if ((util.isPlainObject(model) === false) || (model._joins[key] === undefined)) { // We do not copy joined documents
	        if ((schema !== undefined) && (schema._schema !== undefined) && (type.isVirtual(schema._schema[key]) === true)) {
	          // We do not copy virtual
	        }
	        else if (((schema === undefined) || (schema._schema === undefined) || (schema._schema[key] === undefined)) &&
	            (localOptions !== undefined) && (localOptions.enforce_extra === "remove")) {
	          // We do not copy fields if enfroce_extra is "remove"
	        }
	        else {
	          if ((schema !== undefined) && (schema._schema !== undefined)) {
	            nextSchema = schema._schema[key];
	          }
	          else {
	            nextSchema = undefined;
	          }
	          result[key] = Document.prototype.__makeSavableCopy(doc[key], nextSchema, localOptions, undefined, r);
	        }
	      }
	    });

	    // Copy the fields that are used as foreign keys
	    if (util.isPlainObject(model) === true) {
	      util.loopKeys(model._localKeys, function(localKeys, localKey) {
	        if (doc[localKey] !== undefined) {
	          if (schema !== undefined) {
	            nextSchema = schema._schema[key];
	          }
	          else {
	            nextSchema = undefined;
	          }
	          //TODO: Do we want to copy the foreign key value? If yes, there's no need for this loop
	          //Do we want to copy the key from the joined document? If yes we need to replace doc[localKey]
	          result[localKey] = Document.prototype.__makeSavableCopy(doc[localKey], nextSchema, localOptions, undefined, r);
	        }
	      });
	    }
	    return result;
	  }
	  else if (Array.isArray(doc)) {
	    result = [];
	    copyFlag = true;

	    // Next schema
	    if (type.isArray(schema)) {
	      nextSchema = schema._schema;
	    }
	    else if ((util.isPlainObject(schema)) && (schema._type !== undefined) && (schema._schema !== undefined)) {
	      nextSchema = schema._schema
	      if (schema._type === "virtual") {
	        copyFlag = false;
	      }
	    }
	    else {
	      nextSchema = undefined;
	    }
	    if (copyFlag === true) {
	      for(var i=0; i<doc.length; i++) {
	        result.push(Document.prototype.__makeSavableCopy(doc[i], nextSchema, localOptions, undefined, r));
	      }
	    }
	    return result;
	  }
	  // else, doc is a primitive (or a buffer)
	  return doc;
	}


	/**
	 * Save the document, its joined documents and execute the hooks. Return a
	 * promise if the callback is undefined.
	 * @param {Object=} docToSave Documents to save represented by an object field->true
	 * @param {boolean} saveAll Whether _save should recurse by default or not
	 * @param {Object=} savedModel Models saved in this call
	 * @param {Object=} callback to execute
	 * @return {Promise=}
	 */
	Document.prototype._save = function(docToSave, saveAll, savedModel, callback) {
	  //TOIMPROVE? How should we handle circular references outsides of joined fields? Now we throw with a maximum call stack size exceed
	  var self = this;
	  self.emit('saving', self);

	  return util.hook({
	    preHooks: self._getModel()._pre.save,
	    postHooks: self._getModel()._post.save,
	    doc: self,
	    async: true,
	    fn: self._saveHook,
	    fnArgs: [docToSave, saveAll, savedModel, callback]
	  });
	}


	/**
	 * Save the document and execute the hooks. This is an internal method used with
	 * Model.save. This let us use a similar code path for `document.save` and `Model.save`.
	 * @param {Function} executeInsert the method that will execute the batch insert
	 * @return {Promise}
	 */
	Document.prototype._batchSave = function(executeInsert) {
	  // Keep in sync with _save
	  var self = this;
	  self.emit('saving', self);

	  return util.hook({
	    preHooks: self._getModel()._pre.save,
	    postHooks: self._getModel()._post.save,
	    doc: self,
	    async: true,
	    fn: self._batchSaveSelf,
	    fnArgs: [executeInsert]
	  });
	}


	/**
	 * Call executeInsert when the model is ready
	 * @param {Function} executeInsert the method that will execute the batch insert
	 * @return {Promise}
	 */
	Document.prototype._batchSaveSelf = function(executeInsert) {
	  var self = this;

	  return new Promise(function(resolve, reject) {
	    self.getModel().ready().then(function() {
	      executeInsert(resolve, reject)
	    });
	  })
	}


	/**
	 * Save the document and maybe its joined documents. Hooks have been dealt with
	 * in _save.
	 * @param {!Object} copy The savable copy of the original documents.
	 * @param {Object=} docToSave Documents to save represented by an object field->true
	 * @param {Object=} belongsToKeysSaved The keys that may contains a document to save
	 * @param {boolean} saveAll Whether _save should recurse by default or not
	 * @param {Object=} savedModel Models saved in this call
	 * @param {Function} resolve The function to call when everything has been saved
	 * @param {Function} reject The function to call if an error happened
	 */
	Document.prototype._saveHook = function(docToSave, saveAll, savedModel, callback) {
	  var self = this;
	  var model = self._getModel(); // instance of Model
	  var constructor = self.getModel();
	  var r = model._thinky.r;

	  if (util.isPlainObject(docToSave) === false) {
	    docToSave = {};
	  }

	  savedModel[constructor.getTableName()] = true;


	  var p = new Promise(function(resolve, reject) {
	    // Steps:
	    // - Save belongsTo
	    // - Save this
	    // - Save hasOne, hasMany and hasAndBelongsToMany docs
	    // - Save links

	    // We'll use it to know which `belongsTo` docs were saved
	    var belongsToKeysSaved = {};

	    var copy = self._makeSavableCopy();
	    self._saveVirtual();

	    // Save the joined documents via belongsTo first
	    var promises = [];
	    util.loopKeys(model._joins, function(joins, key) {
	      if ((docToSave.hasOwnProperty(key) || (saveAll === true)) &&
	          (joins[key].type === 'belongsTo') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))) {

	        belongsToKeysSaved[key] = true;
	        if (self[key] != null) {
	          savedModel[joins[key].model.getTableName()] = true;
	          if (saveAll === true) {
	            promises.push(self[key]._save({}, true, savedModel))
	          }
	          else {
	            promises.push(self[key]._save(docToSave[joins[key].model.getTableName()], false, savedModel))
	          }
	        }
	      }
	    });

	    //TODO Remove once
	    self.getModel().ready().then(function() {
	      Promise.all(promises).then(function() {
	        self._onSavedBelongsTo(copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject);
	      }).error(reject);
	    });
	  });
	  return p.nodeify(callback);
	}


	/**
	 * Save the joined documents linked with a BelongsTo relation. This should be
	 * called before _saveSelf as we will have to copy the foreign keys in `self`.
	 * @param {!Object} copy The savable copy of the original documents.
	 * @param {Object=} docToSave Documents to save represented by an object field->true
	 * @param {Object=} belongsToKeysSaved The keys that may contains a document to save
	 * @param {boolean} saveAll Whether _save should recurse by default or not
	 * @param {Object=} savedModel Models saved in this call
	 * @param {Function} resolve The function to call when everything has been saved
	 * @param {Function} reject The function to call if an error happened
	 */
	Document.prototype._onSavedBelongsTo = function(
	    copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject) {
	  var self = this;
	  var model = self._getModel();
	  var constructor = self.__proto__.constructor;
	  var r = this._getModel()._thinky.r;

	  util.loopKeys(belongsToKeysSaved, function(joins, key) {
	    var joins = model._joins;
	    if (self[key] != null) {

	      self.__proto__._belongsTo[key] = true;

	      // Copy foreign key
	      if (self[key][joins[key].rightKey] == null) {
	        if (self.hasOwnProperty(joins[key].leftKey)) {
	          delete self[joins[key][joins[key].leftKey]];
	        }
	        if (copy.hasOwnProperty(joins[key].leftKey)) {
	          delete copy[joins[key][joins[key].leftKey]];
	        }
	      }
	      else {
	        self[joins[key].leftKey] = self[key][joins[key].rightKey];
	        copy[joins[key].leftKey] = self[key][joins[key].rightKey]; // We need to put it in copy before saving it
	      }

	      // Save the document that belongs to self[key]
	      if (self[key].__proto__._parents._belongsTo[constructor.getTableName()] == null) {
	        self[key].__proto__._parents._belongsTo[constructor.getTableName()] = [];
	      }
	      self[key].__proto__._parents._belongsTo[constructor.getTableName()].push({
	        doc: self,
	        foreignKey: joins[key].leftKey,
	        key: key // foreignDoc
	      });
	    }
	  });
	  self._saveSelf(copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject)
	}


	/**
	 * Save the document on which `save` was called.
	 * @param {!Object} copy The savable copy of the original documents.
	 * @param {Object=} docToSave Documents to save represented by an object field->true
	 * @param {Object=} belongsToKeysSaved The keys that may contains a document to save
	 * @param {boolean} saveAll Whether _save should recurse by default or not
	 * @param {Object=} savedModel Models saved in this call
	 * @param {Function} resolve The function to call when everything has been saved
	 * @param {Function} reject The function to call if an error happened
	 */
	Document.prototype._saveSelf = function(
	    copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject) {
	  var self = this;
	  var model = self._getModel();
	  var constructor = self.__proto__.constructor;
	  var r = this._getModel()._thinky.r;

	  // BelongsTo documents were saved before. We just need to copy the foreign
	  // keys.
	  util.loopKeys(model._joins, function(joins, key) {
	    if ((joins[key].type === 'belongsTo') && (belongsToKeysSaved[key] === true)) {
	      if (self[key] != null) {
	        self[joins[key].leftKey] = self[key][joins[key].rightKey]
	      }
	      else if (self.__proto__._belongsTo[key]) {
	        delete self[joins[key].leftKey];
	        delete copy[joins[key].leftKey];
	      }
	    }
	  });

	  var querySaveSelf; // The query to save the document on which `save`/`saveAll` was called.
	  // We haven't validated the document yet, so building the query with `copy`
	  // may throw an error (for example if a Date has not a valid time).
	  var buildQuery = function () {
	    if (self.__proto__._saved === false) {
	      return querySaveSelf = r.table(constructor.getTableName())
	        .insert(copy, {returnChanges: 'always'})
	    }
	    else {
	      if (copy[model._pk] === undefined) {
	        throw new Error("The document was previously saved, but its primary key is undefined.");
	      }
	      return querySaveSelf = r.table(constructor.getTableName())
	        .get(copy[model._pk]).replace(copy, {returnChanges: 'always'})
	    }
	  }

	  self.getModel().ready().then(function() {
	    util.tryCatch(function() {
	      // Validate the document before saving it
	      var promise = self.validate();
	      if (promise instanceof Promise) {
	        promise.then(function() {
	          querySaveSelf = buildQuery();
	          querySaveSelf.run().then(function(result) {
	            self._onSaved(result, docToSave, saveAll, savedModel, resolve, reject)
	          }).error(reject)
	        }).error(reject);
	      }
	      else {
	        querySaveSelf = buildQuery();
	        querySaveSelf.run().then(function(result) {
	          self._onSaved(result, docToSave, saveAll, savedModel, resolve, reject)
	        }).error(reject)
	      }
	    }, reject);
	  });
	}


	/**
	 * Callback for the insert query.
	 * @param {Object} result The result from the insert query
	 * @param {Object=} docToSave Documents to save represented by an object field->true
	 * @param {boolean} saveAll Whether _save should recurse by default or not
	 * @param {Object=} savedModel Models saved in this call
	 * @param {Function} resolve The function to call when everything has been saved
	 * @param {Function} reject The function to call if an error happened
	 */
	Document.prototype._onSaved = function(result, docToSave, saveAll, savedModel, resolve, reject) {
	  // Keep in sync with Model.save
	  var self = this;

	  if (result.first_error != null) {
	    return reject(new Error(result.first_error));
	  }

	  util.tryCatch(function() { // Validate the doc, replace it, and tag it as saved
	    if (Array.isArray(result.changes) && result.changes.length > 0) {
	      self._merge(result.changes[0].new_val);
	      self._setOldValue(util.deepCopy(result.changes[0].old_val));
	    }

	    if (self._getModel().needToGenerateFields === true) {
	      self._generateDefault();
	    }
	    self.setSaved();
	    self.emit('saved', self);

	    var promise = self.validate();
	    if (promise instanceof Promise) {
	      promise.then(function() {
	        self._saveMany(docToSave, saveAll, savedModel, resolve, reject)
	      }).error(reject);
	    }
	    else {
	      self._saveMany(docToSave, saveAll, savedModel, resolve, reject)
	    }
	  }, reject);
	}


	/**
	 * Save the joined documents linked with a hasOne or hasMany or
	 * hasAndBelongsToMany relation. This should be called after `_saveSelf` as we
	 * will have to copy the foreign keys in the joined documents.
	 * @param {Object} result The result from the insert query
	 * @param {Object=} docToSave Documents to save represented by an object field->true
	 * @param {boolean} saveAll Whether _save should recurse by default or not
	 * @param {Object=} savedModel Models saved in this call
	 * @param {Function} resolve The function to call when everything has been saved
	 * @param {Function} reject The function to call if an error happened
	 */
	Document.prototype._saveMany = function(docToSave, saveAll, savedModel, resolve, reject) {
	  var self = this;
	  var model = self._getModel();

	  var promisesMany = [];
	  util.loopKeys(model._joins, function(joins, key) {
	    if (((key in docToSave) || (saveAll === true)) &&
	        (joins[key].type === 'hasOne') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))) {
	      savedModel[joins[key].model.getTableName()] = true;

	      if (self[key] != null) {
	        self[key][joins[key].rightKey] = self[joins[key].leftKey];
	        (function(_key) {
	          promisesMany.push(new Promise(function(resolve, reject) {
	            self[_key]._save(docToSave[_key], saveAll, savedModel).then(function() {
	              self.__proto__._hasOne[_key] = {
	                doc: self[_key],
	                foreignKey: self._getModel()._joins[_key].rightKey
	              };
	              if (self[_key].__proto__._parents._hasOne[self._getModel()._name] == null) {
	                self[_key].__proto__._parents._hasOne[self._getModel()._name] = [];
	              }
	              self[_key].__proto__._parents._hasOne[self._getModel()._name].push({
	                doc: self,
	                key: key
	              });
	              resolve();
	            }).error(reject);
	          }))
	        })(key)
	      }
	      else if ((self[key] == null) && (self.__proto__._hasOne[key] != null)) {
	        var doc = self.__proto__._hasOne[key].doc;
	        delete doc[self.__proto__._hasOne[key].foreignKey];
	        promisesMany.push(doc._save(docToSave[key], saveAll, savedModel))
	        self.__proto__._hasOne[key] = null;
	      }
	    }
	  });
	  util.loopKeys(model._joins, function(joins, key) {
	    if (((key in docToSave) || (saveAll === true)) &&
	        (joins[key].type === 'hasMany') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))
	        && (Array.isArray(self[key]))) {

	      savedModel[joins[key].model.getTableName()] = true;

	      //Go through _hasMany and find element that were removed
	      var pkMap = {};
	      if (Array.isArray(self[key])) {
	        for(var i=0; i<self[key].length; i++) {
	          if (self[key][i][joins[key].model._pk] != null) {
	            pkMap[self[key][i][joins[key].model._pk]] = true;
	          }
	        }
	      }

	      if (self.__proto__._hasMany[key] != null) {
	        for(var i=0; i<self.__proto__._hasMany[key].length; i++) {
	          if (pkMap[self.__proto__._hasMany[key][i].doc[[joins[key].model._pk]]] == null) {
	            delete self.__proto__._hasMany[key][i].doc[self.__proto__._hasMany[key][i].foreignKey];
	            promisesMany.push(self.__proto__._hasMany[key][i].doc._save(docToSave[key], saveAll, savedModel));
	          }
	        }
	      }
	      self.__proto__._hasMany[key] = [];

	      for(var i=0; i<self[key].length; i++) {
	        self[key][i][joins[key].rightKey] = self[joins[key].leftKey];
	        (function(key, i) {
	          promisesMany.push(new Promise(function(resolve, reject) {
	            if (!(self[key][i] instanceof Document)) {
	              self[key][i] = new joins[key].model(self[key][i]);
	            }

	            var callback = function() {
	              self[key][i]._save(docToSave[key], saveAll, savedModel).then(function(doc) {
	                if (!Array.isArray(self.__proto__._hasMany[key])) {
	                  self.__proto__._hasMany[key] = [];
	                }
	                self.__proto__._hasMany[key].push({
	                  doc: doc,
	                  foreignKey: self._getModel()._joins[key].rightKey
	                });

	                if (self[key][i].__proto__._parents._hasMany[self._getModel()._name] == null) {
	                  self[key][i].__proto__._parents._hasMany[self._getModel()._name] = [];
	                }
	                self[key][i].__proto__._parents._hasMany[self._getModel()._name].push({
	                  doc: self,
	                  key: key
	                });

	                resolve();
	              }).error(reject);
	            }

	            if (self[key][i] instanceof Promise) {
	              self[key][i].then(callback).error(reject);
	            }
	            else {
	              callback();
	            }

	          }))
	        })(key, i);
	      }
	    }
	  });
	  util.loopKeys(model._joins, function(joins, key) {
	    // Compare to null
	    if (((key in docToSave) || (saveAll === true)) &&
	        (joins[key].type === 'hasAndBelongsToMany') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))) {

	      savedModel[joins[key].model.getTableName()] = true;

	      if (Array.isArray(self[key])) {
	        for(var i=0; i<self[key].length; i++) {
	          if (util.isPlainObject(self[key][i])) { // Save only if we have a full object, and not just a key
	            (function(key, i) {
	              promisesMany.push(new Promise(function(resolve, reject) {
	                if (!(self[key][i] instanceof Document)) {
	                  self[key][i] = new joins[key].model(self[key][i]);
	                }
	                var callback = function() {
	                  self[key][i]._save(docToSave[key], saveAll, savedModel).then(function() {
	                    // self.__proto__._links will be saved in saveLinks
	                    if (self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] == null) {
	                      self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] = [];
	                    }
	                    self[key][i].__proto__._parents._belongsLinks[self._getModel()._name].push({
	                      doc: self,
	                      key: key
	                    });
	                    resolve();
	                  }).error(reject);
	                }

	                if (self[key][i] instanceof Promise) {
	                  self[key][i].then(callback).error(reject);
	                }
	                else {
	                  callback();
	                }
	              }))
	            })(key, i)
	          }
	        }
	      }
	    }
	  });

	  if (promisesMany.length > 0) {
	    Promise.all(promisesMany).then(function() {
	      self._saveLinks(docToSave, saveAll, resolve, reject)
	    }).error(reject);
	  }
	  else {
	    self._saveLinks(docToSave, saveAll, resolve, reject)
	  }
	}


	/**
	 * Save the links for hasAndBelongsToMany joined documents.
	 * called before _saveSelf as we will have to copy the foreign keys in `self`.
	 * @param {Object=} docToSave Documents to save represented by an object field->true
	 * @param {boolean} saveAll Whether _save should recurse by default or not
	 * @param {Function} resolve The function to call when everything has been saved
	 * @param {Function} reject The function to call if an error happened
	 */
	Document.prototype._saveLinks = function(docToSave, saveAll, resolve, reject) {
	  var self = this;
	  var model = self._getModel();
	  var constructor = self.getModel();
	  var r = model._thinky.r;

	  var promisesLink = [];

	  util.loopKeys(model._joins, function(joins, key) {
	    // Write tests about that!
	    if (((key in docToSave) || (saveAll === true)) &&
	        (joins[key].type === 'hasAndBelongsToMany')) {

	      if (Array.isArray(self[key])) {
	        var newKeys = {}
	        for(var i=0; i<self[key].length; i++) {
	          if (util.isPlainObject(self[key][i])) {
	            if (self[key][i].isSaved() === true) {
	              newKeys[self[key][i][joins[key].rightKey]] = true;
	            }
	          }
	          else { // self[key][i] is just the key
	            newKeys[self[key][i]] = true;
	          }
	        }

	        if (self.__proto__._links[joins[key].link] === undefined) {
	          self.__proto__._links[joins[key].link] = {}
	        }
	        var oldKeys = self.__proto__._links[joins[key].link];

	        util.loopKeys(newKeys, function(newKeys, link) {
	          if (oldKeys[link] !== true) {
	            var newLink = {};

	            if ((constructor.getTableName() === joins[key].model.getTableName())
	              && (joins[key].leftKey === joins[key].rightKey)) {

	              // We link on the same model and same key
	              // We don't want to save redundant field
	              if (link < self[joins[key].leftKey]) {
	                newLink.id = link+"_"+self[joins[key].leftKey];
	              }
	              else {
	                newLink.id = self[joins[key].leftKey]+"_"+link;
	              }
	              newLink[joins[key].leftKey+"_"+joins[key].leftKey] = [link, self[joins[key].leftKey]];
	            }
	            else {
	              newLink[constructor.getTableName()+"_"+joins[key].leftKey] = self[joins[key].leftKey];
	              newLink[joins[key].model.getTableName()+"_"+joins[key].rightKey] = link;

	              // Create the primary key
	              if (constructor.getTableName() < joins[key].model.getTableName()) {
	                newLink.id = self[joins[key].leftKey]+"_"+link;
	              }
	              else if (constructor.getTableName() > joins[key].model.getTableName()) {
	                newLink.id = link+"_"+self[joins[key].leftKey];
	              }
	              else {
	                if (link < self[joins[key].leftKey]) {
	                  newLink.id = link+"_"+self[joins[key].leftKey];
	                }
	                else {
	                  newLink.id = self[joins[key].leftKey]+"_"+link;
	                }
	              }
	            }

	            (function(key, link) {
	              promisesLink.push(new Promise(function(resolve, reject) {
	                r.table(self._getModel()._joins[key].link).insert(newLink, {conflict: "replace", returnChanges: 'always'}).run().then(function(result) {
	                  if (Array.isArray(result.changes) && result.changes.length > 0) {
	                    self.__proto__._links[joins[key].link][result.changes[0].new_val[joins[key].model.getTableName()+"_"+joins[key].rightKey]] = true;
	                  }
	                  else {
	                    self.__proto__._links[joins[key].link][newLink[joins[key].model.getTableName()+"_"+joins[key].rightKey]] = true;
	                  }
	                  resolve();
	                }).error(reject);
	              }))
	            })(key, link);
	          }
	        });

	        var keysToDelete = []
	        util.loopKeys(oldKeys, function(oldKeys, link) {
	          if (newKeys[link] === undefined) {
	            if (constructor.getTableName() < joins[key].model.getTableName()) {
	              keysToDelete.push(self[joins[key].leftKey]+"_"+link);
	            }
	            else {
	              keysToDelete.push(link+"_"+self[joins[key].leftKey]);
	            }
	          }
	        });
	        if (keysToDelete.length > 0) {
	          var table = r.table(joins[key].link);
	          promisesLink.push(table.getAll.apply(table, keysToDelete).delete().run().then(function() {
	            for(var i=0; i<keysToDelete.length; i++) {
	              self.__proto__._links[joins[key].link][keysToDelete[i]] = false;
	            }
	          }));
	        }
	      }
	    }
	  });

	  if (promisesLink.length > 0) {
	    Promise.all(promisesLink).then(function() {
	      resolve(self);
	    }).error(reject);
	  }
	  else {
	    resolve(self);
	  }
	}


	/**
	 * Return the value saved in __proto__.oldValue
	 */
	Document.prototype.getOldValue = function() {
	  return this.__proto__.oldValue;
	}


	/**
	 * Save a reference of `value` that will be later accessible with `getOldValue`.
	 * @param {Object} value The value to save
	 */
	Document.prototype._setOldValue = function(value) {
	  return this.__proto__.oldValue = value;
	}


	/**
	 * Return whether this document was saved or not.
	 * @return {boolean}
	 */
	Document.prototype.isSaved = function() {
	  return this.__proto__._saved;
	}


	/**
	 * Set the document (and maybe its joined documents) as saved.
	 * @param {boolean=} all Recursively set all the joined documents as saved
	 */
	Document.prototype.setSaved = function(all) {
	  var self = this;
	  self.__proto__._saved = true;
	  if (all !== true) return;
	    util.loopKeys(self._getModel()._joins, function(joins, key) {
	      switch (joins[key].type) {
	        case 'hasOne':
	          if (self[key] instanceof Document) {
	            self[key].setSaved(true);
	          }
	          break;

	        case 'belongsTo':
	          if (self[key] instanceof Document) {
	            self[key].setSaved(true);
	          }
	          break;

	        case 'hasMany':
	          if (Array.isArray(self[key])) {
	            for(var i=0; i<self[key].length; i++) {
	              if (self[key][i] instanceof Document) {
	                self[key][i].setSaved(true);
	              }
	            }
	          }
	          break;

	        case 'hasAndBelongsToMany':
	          if (Array.isArray(self[key])) {
	            for(var i=0; i<self[key].length; i++) {
	              if (self[key][i] instanceof Document) {
	                self[key][i].setSaved(true);
	              }
	            }
	          }
	          break;
	      }
	    });

	    // Make joins, we should keep references only of the saved documents
	    util.loopKeys(self._getModel()._joins, function(joins, key) {
	      if (self[key] == null) return;
	      switch (joins[key].type) {
	        case 'hasOne':
	          if (self[key].isSaved()) {
	            self.__proto__._hasOne[key] = {
	              doc: self[key],
	              foreignKey: self._getModel()._joins[key].rightKey
	            }
	          }

	          if (self[key].__proto__._parents._hasOne[self._getModel()._name] == null) {
	            self[key].__proto__._parents._hasOne[self._getModel()._name] = [];
	          }
	          self[key].__proto__._parents._hasOne[self._getModel()._name].push({
	            doc: self,
	            key: key
	          });
	          break;

	        case 'belongsTo':
	          if (self[key].__proto__._parents._belongsTo[self._getModel()._name] == null) {
	            self[key].__proto__._parents._belongsTo[self._getModel()._name] = [];
	          }
	          self[key].__proto__._parents._belongsTo[self._getModel()._name].push({
	            doc: self,
	            foreignKey: self._getModel()._joins[key].leftKey,
	            key: key
	          });
	          self.__proto__._belongsTo[key] = true;
	          break;

	        case 'hasMany':
	          self.__proto__._hasMany[key] = []

	          for(var i=0; i<self[key].length; i++) {
	            if (self[key][i].isSaved()) {
	              self.__proto__._hasMany[key].push({
	                doc: self[key][i],
	                foreignKey: self._getModel()._joins[key].rightKey
	              })
	            }

	            if (self[key][i].__proto__._parents._hasMany[self._getModel()._name] == null) {
	              self[key][i].__proto__._parents._hasMany[self._getModel()._name] = [];
	            }
	            self[key][i].__proto__._parents._hasMany[self._getModel()._name].push({
	              doc: self,
	              key: key
	            });

	          }
	          break;

	        case 'hasAndBelongsToMany':
	          if (self.__proto__._links[self._getModel()._joins[key].link] === undefined) {
	            self.__proto__._links[self._getModel()._joins[key].link] = {}
	          }

	          for(var i=0; i<self[key].length; i++) {
	            if (self[key][i].isSaved()) {
	              self.__proto__._links[self._getModel()._joins[key].link][self[key][i][self._getModel()._joins[key].rightKey]] = true;
	            }

	            if (self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] == null) {
	              self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] = [];
	            }
	            self[key][i].__proto__._parents._belongsLinks[self._getModel()._name].push({
	              doc: self,
	              key: key
	            });

	          }
	          break;
	      }
	    });

	}


	/**
	 * Set the document as unsaved
	 */
	Document.prototype._setUnSaved = function() {
	  this.__proto__._saved = false;
	}


	/**
	 * Delete the document from the database. Update the joined documents by
	 * removing the foreign key for hasOne/hasMany joined documents, and remove the
	 * links for hasAndBelongsToMany joined documents if the link is built on the
	 * primary key.
	 * @param {Function=} callback
	 * @return {Promise=} Return a promise if no callback is provided
	 */
	Document.prototype.delete = function(callback) {
	  return this._delete({}, false, [], true, true, callback)
	}


	/**
	 * Delete the document from the database and the joined documents. If
	 * `docToDelete` is undefined, it will delete all the joined documents, else it
	 * will limits itself to the one stored in the keys defined in `docToDelete`.
	 * It will also update the joined documents by removing the foreign key for
	 * `hasOne`/`hasMany` joined documents, and remove the links for
	 * `hasAndBelongsToMany` joined documents if the link is built on the primary
	 * key.
	 * @param {Object=} docToDelete An object where a field maps to `true` if the
	 * document stored in this field should be deleted.
	 * @param {Function=} callback
	 * @return {Promise=} Return a promise if no callback is provided
	 */
	Document.prototype.deleteAll = function(docToDelete, callback) {
	  var deleteAll;
	  if (typeof docToDelete === 'function') {
	    callback = docToDelete;
	    deleteAll = true;
	    docToDelete = {};
	  }
	  else {
	    deleteAll = docToDelete === undefined;
	    docToDelete = docToDelete || {};
	  }
	  return this._delete(docToDelete, deleteAll, [], true, true, callback)
	}


	/**
	 * Delete the document from the database and the joined documents. If
	 * `docToDelete` is `undefined` and `deleteAll` is `true`, it will delete all
	 * the joined documents, else it will limits itself to the one stored in the
	 * keys defined in `docToDelete`. It will also update the joined documents by
	 * removing the foreign key for `hasOne`/`hasMany` joined documents, and
	 * remove the links for `hasAndBelongsToMany` joined documents if the link is
	 * built on the primary key.
	 * Hooks will also be executed.
	 * @param {Object=} docToDelete Explicit maps of the documents to delete
	 * @param {boolean} deleteAll Recursively delete all the documents if
	 *     `docToDelete` is undefined
	 * @param {Array} deletedDocs Array of docs already deleted, used to make sure
	 *     that we do not try to delete multiple times the same documents
	 * @param {boolean} deleteSelf Whether it should delete self
	 * @param {boolean} updateParents Whether it should update the keys for the
	 *     parents
	 * @param {Function=} callback
	 * @return {Promise=} Return a promise if no callback is provided
	 */
	Document.prototype._delete = function(docToDelete, deleteAll, deletedDocs, deleteSelf, updateParents, callback) {
	  //TODO Set a (string) id per document and use it to perform faster lookup
	  var self = this;

	  if (util.isPlainObject(docToDelete) === false) {
	    docToDelete = {};
	  }

	  deleteSelf = (deleteSelf === undefined) ? true: deleteSelf;

	  return util.hook({
	    preHooks: self._getModel()._pre.delete,
	    postHooks: self._getModel()._post.delete,
	    doc: self,
	    async: true,
	    fn: self._deleteHook,
	    fnArgs: [docToDelete, deleteAll, deletedDocs, deleteSelf, updateParents, callback]
	  });
	}


	/**
	 * Internal methods used in `_delete`. Does the same as `_delete` but without
	 * the hooks.
	 * @param {Object=} docToDelete Explicit maps of the documents to delete
	 * @param {boolean} deleteAll Recursively delete all the documents if
	 *     `docToDelete` is undefined
	 * @param {Array} deletedDocs Array of docs already deleted, used to make sure
	 *     that we do not try to delete multiple times the same documents
	 * @param {boolean} deleteSelf Whether it should delete self
	 * @param {boolean} updateParents Whether it should update the keys for the
	 *     parents
	 * @return {Promise=} Return a promise if no callback is provided
	 */
	Document.prototype._deleteHook = function(docToDelete, deleteAll, deletedDocs, deleteSelf, updateParents, callback) {
	  var self = this;
	  var model = self._getModel(); // instance of Model
	  var constructor = self.getModel();
	  var r = model._thinky.r;

	  var promises = [];

	  deletedDocs.push(self);
	  util.loopKeys(self._getModel()._joins, function(joins, key) {
	    if ((joins[key].type === 'hasOne') && (self[key] instanceof Document)) {
	      if ((self[key].isSaved() === true) &&
	        ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key]) === -1)))) {

	        (function(key) {
	          promises.push(new Promise(function(resolve, reject) {
	            self[key]._delete(docToDelete[key], deleteAll, deletedDocs, true, false).then(function() {
	              delete self[key];
	              resolve();
	            }).error(reject);
	          }))
	        })(key);
	      }
	      else if ((deleteSelf === true) && (deletedDocs.indexOf(self[key]) === -1)) {
	        delete self[key][joins[key].rightKey];
	        if (self[key].isSaved() === true) {
	          promises.push(self[key].save({}, false, {}, true, false));
	        }
	      }
	    }
	    if ((joins[key].type === 'belongsTo') && (self[key] instanceof Document)) {
	      if ((self[key].isSaved() === true) &&
	        ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key]) === -1)))) {

	        (function(key) {
	          promises.push(new Promise(function(resolve, reject) {
	            self[key]._delete(docToDelete[key], deleteAll, deletedDocs, true, false).then(function() {
	              delete self[key];
	              resolve();
	            }).error(reject);
	          }));
	        })(key);
	      }
	    }

	    if ((joins[key].type === 'hasMany') && (Array.isArray(self[key]))) {
	      var manyPromises = [];
	      for(var i=0; i<self[key].length; i++) {
	        if (((self[key][i] instanceof Document) && (self[key][i].isSaved() === true))
	          && ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key][i]) === -1)))) {

	          manyPromises.push(self[key][i]._delete(docToDelete[key], deleteAll, deletedDocs, true, false))
	        }
	        else if ((self[key][i] instanceof Document) && (deletedDocs.indexOf(self[key][i]) === -1)) {
	          delete self[key][i][joins[key].rightKey];
	          if (self[key][i].isSaved() === true) {
	            promises.push(self[key][i].save({}, false, {}, true, false))
	          }
	        }
	      }
	      (function(key) {
	        promises.push(new Promise(function(resolve, reject) {
	          Promise.all(manyPromises).then(function() {
	            delete self[key];
	            resolve()
	          })
	        }));
	      })(key)
	    }
	    if ((joins[key].type === 'hasAndBelongsToMany') && (Array.isArray(self[key]))) {
	      // Delete links + docs
	      var pks = []; // primary keys of the documents
	      var linksPks = []; // primary keys of the links

	      // Store the element we are going to delete.
	      // If the user force the deletion of the same element multiple times, we can't naively loop
	      // over the elements in the array...
	      var docsToDelete = [];


	      for(var i=0; i<self[key].length; i++) {
	        if (((self[key][i] instanceof Document) && (self[key][i].isSaved() === true))
	          && ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key][i]) === -1)))) {

	          //pks.push(self[key][i][joins[key].model._getModel()._pk]);
	          docsToDelete.push(self[key][i]);
	          // We are going to do a range delete, but we still have to recurse
	          promises.push(self[key][i]._delete(docToDelete[key], deleteAll, deletedDocs, true, false))

	          if (self.getModel()._getModel()._pk === joins[key].leftKey) {
	            // The table is created since we are deleting an element from it
	            if (self._getModel()._name < joins[key].model._getModel()._name) {
	              linksPks.push(self[joins[key].leftKey]+"_"+self[key][i][joins[key].rightKey]);
	            }
	            else {
	              linksPks.push(self[key][i][joins[key].rightKey]+"_"+self[joins[key].leftKey]);
	            }
	          }
	        }
	        else if ((self[key][i] instanceof Document) && (deletedDocs.indexOf(self[key][i]) === -1)) {
	          // It's safe to destroy links only if it's a primary key
	          if (self.getModel()._getModel()._pk === joins[key].leftKey) {
	            if (self._getModel()._name < joins[key].model._getModel()._name) {
	              linksPks.push(self[joins[key].leftKey]+"_"+self[key][i][joins[key].rightKey]);
	            }
	            else {
	              linksPks.push(self[key][i][joins[key].rightKey]+"_"+self[joins[key].leftKey]);
	            }
	          }
	        }
	      }
	      if (linksPks.length > 0) {
	        var query = r.table(joins[key].link);
	        query = query.getAll.apply(query, linksPks).delete();
	        promises.push(query.run());
	      }
	    }
	  });
	  if (updateParents !== false) {
	    // Clean links that we are aware of
	    util.loopKeys(self.__proto__._parents._hasOne, function(hasOne, key) {
	      var parents = hasOne[key];
	      for(var i=0; i<parents.length; i++) {
	        delete parents[i].doc[parents[i].key];
	      }
	    });
	    util.loopKeys(self.__proto__._parents._belongsTo, function(belongsTo, key) {
	      var parents = belongsTo[key];
	      for(var i=0; i<parents.length; i++) {
	        delete parents[i].doc[parents[i].key];
	        delete parents[i].doc[parents[i].foreignKey];
	        if (deletedDocs.indexOf(parents[i]) === -1) {
	          promises.push(parents[i].doc.save());
	        }
	      }
	    });
	    util.loopKeys(self.__proto__._parents._hasMany, function(hasMany, key) {
	      var parents = hasMany[key];
	      for(var i=0; i<parents.length; i++) {
	        for(var j=0; j<parents[i].doc[parents[i].key].length; j++) {
	          if (parents[i].doc[parents[i].key][j] === self) {
	            parents[i].doc[parents[i].key].splice(j, 1);
	            break;
	          }
	        }
	      }
	    });
	    util.loopKeys(self.__proto__._parents._belongsLinks, function(belongsLinks, key) {
	      var parents = belongsLinks[key];
	      for(var i=0; i<parents.length; i++) {
	        for(var j=0; j<parents[i].doc[parents[i].key].length; j++) {
	          if (parents[i].doc[parents[i].key][j] === self) {
	            parents[i].doc[parents[i].key].splice(j, 1);
	            break;
	          }
	        }
	      }
	    });
	  }

	  if (deleteSelf !== false) {
	    if (self.isSaved() === true) {
	      promises.push(new Promise(function(resolve, reject) {
	        r.table(model._name).get(self[model._pk]).delete().run().then(function(result) {
	          self._setUnSaved();
	          self.emit('deleted', self);
	          resolve(self);
	        }).error(reject);
	      }))
	    }
	    // else we don't throw an error, should we?
	  }

	  var p = new Promise(function(resolve, reject) {
	    Promise.all(promises).then(function(result) {
	      resolve(self);
	    }).error(function(error) {
	      reject(error)
	    });
	  })
	  return p.nodeify(callback);
	}

	/*
	 * Delete this document and purge the database by doing range update to clean
	 * the foreign keys.
	 * @param {Function=} callback
	 * @return {Promise=} Return a promise if no callback is provided
	 */
	Document.prototype.purge = function(callback) {
	  var self = this;

	  var model = self._getModel(); // instance of Model
	  var r = model._thinky.r;

	  // Clean parent for hasOne
	  // doc.otherDoc.delete()
	  util.loopKeys(self.__proto__._parents._hasOne, function(hasOne, key) {
	    for(var i=0; i<hasOne[key].length; i++) {
	      var parentDoc = hasOne[key][i].doc; // A doc that belongs to otherDoc (aka this)
	      delete parentDoc[hasOne[key][i].key] // Delete reference to otherDoc (aka this)
	    }
	  });

	  // Clean parent for belongsTo
	  // doc.otherDoc.delete()
	  util.loopKeys(self.__proto__._parents._belongsTo, function(belongsTo, key) {
	    for(var i=0; i<belongsTo[key].length; i++) {
	      var parentDoc = belongsTo[key][i].doc;
	      delete parentDoc[belongsTo[key][i].key];
	      delete parentDoc[belongsTo[key][i].foreignKey];
	    }
	  });

	  // Clean parent for hasMany
	  util.loopKeys(self.__proto__._parents._hasMany, function(hasMany, key) {
	    for(var i=0; i<hasMany[key].length; i++) {
	      var parentDoc = hasMany[key][i].doc;
	      var field = hasMany[key][i].key;
	      for(var j=0; j<parentDoc[field].length; j++) {
	        if (parentDoc[field][j] === this) {
	          parentDoc[field].splice(j, 1);
	          break;
	        }
	      }
	    }
	  });


	  // Clean parent for hasAndBelongsToMany
	  util.loopKeys(self.__proto__._parents._belongsLinks, function(belongsLinks, key) {
	    for(var i=0; i<belongsLinks[key].length; i++) {
	      var parentDoc = belongsLinks[key][i].doc;
	      var field = belongsLinks[key][i].key;
	      for(var j=0; j<parentDoc[field].length; j++) {
	        if (parentDoc[field][j] === this) {
	          parentDoc[field].splice(j, 1);
	          break;
	        }
	      }
	    }
	  });

	  // Purge the database
	  var promises = [];
	  util.loopKeys(self._getModel()._joins, function(joins, field) {
	    var join = joins[field];
	    var joinedModel = join.model;

	    if ((join.type === 'hasOne') || (join.type === 'hasMany')) {
	      promises.push(r.table(joinedModel.getTableName()).getAll(self[join.leftKey], {index: join.rightKey}).replace(function(doc) {
	        return doc.without(join.rightKey)
	      }).run())
	    }
	    // nothing to do for "belongsTo"
	    else if (join.type === 'hasAndBelongsToMany') {
	      if (self.getModel()._getModel()._pk === join.leftKey) {
	        // [1]
	        promises.push(r.table(join.link).getAll(self[join.leftKey], {index: self.getModel().getTableName()+"_"+join.leftKey}).delete().run())
	      }
	    }
	  });

	  util.loopKeys(self._getModel()._reverseJoins, function(reverseJoins, field) {
	    var join = reverseJoins[field];
	    var joinedModel = join.model; // model where belongsTo/hasAndBelongsToMany was called

	    if (join.type === 'belongsTo') {
	      // What was called is joinedModel.belongsTo(self, fieldDoc, leftKey, rightKey)
	      promises.push(r.table(joinedModel.getTableName()).getAll(self[join.rightKey], {index: join.leftKey}).replace(function(doc) {
	        return doc.without(join.leftKey)
	      }).run())
	    }
	    // nothing to do for "belongsTo"
	    else if (join.type === 'hasAndBelongsToMany') {
	      // Purge only if the key is a primary key
	      // What was called is joinedModel.hasAndBelongsToMany(self, fieldDoc, leftKey, rightKey)
	      if (self.getModel()._getModel()._pk === join.leftKey) {
	        promises.push(r.table(join.link).getAll(self[join.rightKey], {index: self.getModel().getTableName()+"_"+join.rightKey}).delete().run())
	      }
	    }
	  });

	  // Delete itself
	  promises.push(self.delete())

	  return new Promise(function(resolve, reject) {
	    Promise.all(promises).then(function() {
	      resolve(self);
	    }).error(reject);
	  }).nodeify(callback);
	}

	Document.prototype.removeRelation = function() {
	  var self = this;
	  var pk = self._getModel()._pk;

	  var query = self.getModel().get(this[pk])
	  return query.removeRelation.apply(query, arguments);
	}

	/**
	 * Perform a `merge` of `obj` in this document. Extra keys will be removed.
	 */
	Document.prototype._merge = function(obj) {
	  var self = this;
	  util.loopKeys(self, function(self, key) {
	    if ((obj[key] === undefined) && (self._getModel()._joins[key] === undefined)) {
	      delete self[key];
	    }
	  });
	  util.loopKeys(obj, function(obj, key) {
	    self[key] = obj[key];
	  });
	  return self;
	}


	/**
	 * Perform a `merge` of `obj` in this document. Extra keys will not be removed.
	 */
	Document.prototype.merge = function(obj) {
	  var self = this;
	  util.loopKeys(obj, function(obj, key) {
	    // Recursively merge only if both fields are objects, else we'll overwrite the field
	    if (util.isPlainObject(obj[key]) && util.isPlainObject(self[key])) {
	      Document.prototype.merge.call(self[key], obj[key])
	    }
	    else {
	      self[key] = obj[key];
	    }
	  });
	  return self;
	}

	/**
	 * Set the atom feed and update the document for each change
	 */
	Document.prototype._setFeed = function(feed) {
	  var self = this;

	  self.__proto__._feed = feed;
	  self.__proto__._active = true;
	  feed.each(function(err, change) {
	    if (err) {
	      self.__proto__._active = false;
	      self.emit('error', err);
	    }
	    else {
	      if (change.new_val === null) {
	        // Delete all the fields
	        self._merge({});
	        self._setOldValue(change.old_val);
	        self._setUnSaved();
	        self.emit('change', self);
	      }
	      else {
	        self._merge(change.new_val);
	        self._setOldValue(change.old_val);
	        self.setSaved();
	        self.emit('change', self);
	      }
	    }

	  });
	};

	Document.prototype.getFeed = function() {
	  return this.__proto__._feed;
	}

	Document.prototype.closeFeed = function() {
	  return this.__proto__._feed.close();
	}

	/**
	 * Have the model emit 'retrieved' with the current document and
	 * recurse to have all joined models do the same.
	 */
	Document.prototype._emitRetrieve = function() {
	  var self = this;
	  self.getModel().emit('retrieved', self);
	  util.loopKeys(self._getModel()._joins, function(joins, key) {
	    var join = joins[key];
	    if ((joins[key].type === 'hasOne') || (joins[key].type === 'belongsTo')) {
	      if ((self[key] != null) && (typeof self[key]._emitRetrieve === 'function')) {
	        self[key]._emitRetrieve();
	      }
	    }
	    else if ((joins[key].type === 'hasMany') || (joins[key].type === 'hasAndBelongsToMany')) {
	      if (Array.isArray(self[key])) {
	        for(var i=0; i<self[key].length; i++) {
	          if (typeof self[key][i]._emitRetrieve === 'function') {
	            self[key][i]._emitRetrieve();
	          }
	        }
	      }
	    }
	  })
	}

	module.exports = Document;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var Promise = __webpack_require__(29);
	var util = __webpack_require__(65);
	var Errors = __webpack_require__(66);
	var schemaUtil = __webpack_require__(67);
	var Feed = __webpack_require__(82);


	/**
	 * Constructor for a Query. A Query basically wraps a ReQL queries to keep track
	 * of the model returned and if a post-query validation is required.
	 * @param {Function=} model Model of the documents returned
	 * @param {ReQLQuery=} current ReQL query (rethinkdbdash)
	 * @param {boolean=} postValidation whether post query validation should be performed
	 */
	function Query(model, query, options, error) {
	  var self = this;

	  this._model = model; // constructor of the model we should use for the results.
	  if (model !== undefined) {
	    this._r = model._getModel()._thinky.r;
	    util.loopKeys(model._getModel()._staticMethods, function(staticMethods, key) {
	      (function(_key) {
	        self[_key] = function() {
	          return staticMethods[_key].apply(self, arguments);
	        };
	      })(key);
	    });
	  }

	  if (query !== undefined) {
	    this._query = query;
	   }
	  else if (model !== undefined) {
	    // By default, we initialize the query to `r.table(<tableName>)`.
	    this._query = this._r.table(model.getTableName());
	  }

	  if (util.isPlainObject(options)) {
	    if (options.postValidation) {
	      this._postValidation = options.postValidation === true;
	    }
	    if (options.ungroup) {
	      this._ungroup = options.ungroup === true;
	    }
	    else {
	      this._ungroup = false;
	    }
	  }
	  else { // let the user rework the result after ungroup
	    this._ungroup = false;
	  }
	  if (error) {
	    // Note `Query.prototype.error` is defined because of `r.error`, so we shouldn't
	    // defined this.error.
	    this._error = error;
	  }
	  this._pointWrite = false;
	}

	Query.prototype.setPostValidation = function() {
	  this._postValidation = true;
	}

	Query.prototype.setPointWrite = function() {
	  this._pointWrite = true;
	}

	/**
	 * Execute a Query and expect the results to be object(s) that can be converted
	 * to instances of the model.
	 * @param {Object=} options The options passed to the driver's method `run`
	 * @param {Function=} callback
	 * @return {Promise} return a promise that will be resolved when the query and
	 * the instances of the models will be created (include the potential
	 * asynchronous hooks).
	 */
	Query.prototype.run = function(options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	  return this._execute(options, true).nodeify(callback);
	}


	/**
	 * Execute a Query
	 * @param {Object=} options The options passed to the driver's method `run`
	 * @param {Function=} callback
	 * @return {Promise} return a promise that will be resolved with the results
	 * of the query.
	 */
	Query.prototype.execute = function(options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	  return this._execute(options, false).nodeify(callback);
	}


	/**
	 * Internal method to execute a query. Called by `run` and `execute`.
	 * @param {Object} options The options passed to the driver's method `run`
	 * @param {boolean} parse Whether the results should be converted as instance(s) of the model
	 * @param {Function=} callback
	 * @return {Promise} return a promise that will be resolved with the results
	 * of the query.
	 * @private
	 */
	Query.prototype._execute = function(options, parse) {
	  var self = this;
	  options = options || {};
	  var fullOptions = {groupFormat: 'raw'}
	  util.loopKeys(options, function(options, key) {
	    fullOptions[key] = options[key]
	  });
	  if (parse === true) {
	    fullOptions.cursor = false;
	  }

	  if (self._model._error !== null) {
	    return Promise.reject(self._model._error);
	  }
	  return self._model.ready().then(function() {
	    return self._executeCallback(fullOptions, parse, options.groupFormat);
	  });
	}

	Query.prototype._executeCallback = function(fullOptions, parse, groupFormat) {
	  var self = this;
	  if (self._error !== undefined) {
	    return Promise.reject(new Error("The partial value is not valid, so the write was not executed. The original error was:\n"+self._error.message));
	  }

	  return self._query.run(fullOptions).then(function(result) {
	    if (result === null && parse) {
	      throw new Errors.DocumentNotFound();
	    }

	    // Expect a write result from RethinkDB
	    if (self._postValidation === true) {
	      return self._validateQueryResult(result);
	    }

	    if (result != null && typeof result.getType === 'function') {
	      var resultType = result.getType();
	      if (resultType === 'Feed' ||
	        resultType === 'OrderByLimitFeed' ||
	        resultType === 'UnionedFeed'
	      ) {
	        var feed = new Feed(result, self._model);
	        return feed;
	      }

	      if (resultType === 'AtomFeed') {
	        return result.next().then(function(initial) {
	          var value = initial.new_val || {};
	          return self._model._parse(value).then(function(doc) {
	            doc._setFeed(result);
	            return doc;
	          });
	        });
	      }
	    }

	    if (parse === true) {
	      return self._model._parse(result, self._ungroup);
	    }

	    if (groupFormat !== 'raw') {
	      return Query.prototype._convertGroupedData(result);
	    }

	    return result;
	  }).catch(function(err) {
	    var notFoundRegex = new RegExp('^' + new Errors.DocumentNotFound().message);
	    if (err.message.match(notFoundRegex)) {
	      //Reject with an instance of Errors.DocumentNotFound
	      err = new Errors.DocumentNotFound(err.message);
	    }
	    return Promise.reject(err);
	  })
	};

	Query.prototype._validateUngroupResult = function(result) {
	}

	Query.prototype._validateQueryResult = function(result) {
	  var self = this;
	  if (result.errors > 0) {
	    console.log(result);
	    return Promise.reject(new Errors.InvalidWrite("An error occured during the write", result));
	  }
	  if (!Array.isArray(result.changes)) {
	    if (self._isPointWrite()) {
	      return Promise.resolve();
	    }
	    return Promise.resolve([]);
	  }

	  var promises = [];
	  for(var i=0; i<result.changes.length; i++) {
	    (function(i) {
	      if (result.changes[i].new_val !== null) {
	        promises.push(self._model._parse(result.changes[i].new_val));
	      }
	    })(i)
	  }
	  return Promise.all(promises).then(function(result) {
	    if (self._isPointWrite()) {
	      if (result.length > 1) {
	        throw new Error('A point write returned multiple values')
	      }
	      return result[0];
	    }
	    return result;
	  }).catch(function(error) {
	    if (error instanceof Errors.DocumentNotFound) {
	      // Should we send back null?
	    }
	    else {
	      var revertPromises = [];
	      var primaryKeys = [];
	      var keysToValues = {};
	      var r = self._model._thinky.r;
	      for(var p=0; p<result.changes.length; p++) {
	        // Extract the primary key of the document saved in the database
	        var primaryKey = util.extractPrimaryKey(
	            result.changes[p].old_val,
	            result.changes[p].new_val,
	            self._model._pk)
	        if (primaryKey === undefined) {
	          continue;
	        }

	        if (typeof primaryKey === "string") {
	          keysToValues[primaryKey] = result.changes[p].old_val;
	          primaryKeys.push(primaryKey);
	        }
	        else {
	          // Replace documents with non-string type primary keys
	          // one by one.
	          revertPromises.push(r.table(self._model.getTableName())
	            .get(primaryKey)
	            .replace(result.changes[p].old_val)
	            .run());
	        }
	      }

	      // Replace all documents with string-type primary keys
	      // in a single replace() operation.
	      if (primaryKeys.length) {
	        revertPromises.push(
	          r.table(self._model.getTableName()).getAll(r.args(primaryKeys)).replace(function(doc) {
	            return r.expr(keysToValues)(doc(self._model._pk));
	          }).run()
	        );
	      }

	      return Promise.all(revertPromises).then(function(result) {
	        throw new Error("The write failed, and the changes were reverted.");
	      }).error(function(error) {
	        throw new Error("The write failed, and the attempt to revert the changes failed with the error:\n"+error.message);
	      });
	    }
	  })
	};


	/**
	 * Convert GROUPED_DATA results to [group: <group>, reduction: <reduction>]
	 * This does the same as the driver. The reduction is not converted to
	 * instances of the model.
	 */
	Query.prototype._convertGroupedData = function(data) {
	  if (util.isPlainObject(data) && (data.$reql_type$ === "GROUPED_DATA")) {
	    var result = [];
	    var reduction;
	    for(var i=0; i<data.data.length; i++) {
	      result.push({
	        group: data.data[i][0],
	        reduction: data.data[i][1]
	      });
	    }
	    return result;
	  }
	  else {
	    return data;
	  }
	}


	/**
	 * Perform a join given the relations on this._model
	 * @param {Object=} modelToGet explicit joined documents to retrieve
	 * @param {boolean} getAll Internal argument, if `modelToGet` is undefined, `getAll` will
	 * be set to `true` and `getJoin` will be greedy and keep recursing as long as it does not
	 * hit a circular reference
	 * @param {Object=} gotModel Internal argument, the model we are already fetching.
	 * @return {Query}
	 */
	Query.prototype.getJoin = function(modelToGet, getAll, gotModel) {
	  var self = this;
	  var r = self._model._getModel()._thinky.r;

	  var model = this._model;
	  var joins = this._model._getModel()._joins;

	  var getAll = modelToGet === undefined;
	  if (util.isPlainObject(modelToGet) === false) {
	    modelToGet = {};
	  }
	  var innerQuery;

	  gotModel = gotModel || {};
	  gotModel[model.getTableName()] = true;

	  util.loopKeys(joins, function(joins, key) {
	    if (util.recurse(key, joins, modelToGet, getAll, gotModel)) {
	      switch (joins[key].type) {
	        case 'hasOne':
	        case 'belongsTo':
	          self._query = self._query.merge(function(doc) {
	            return r.branch(
	              doc.hasFields(joins[key].leftKey),
	              r.table(joins[key].model.getTableName()).getAll(doc(joins[key].leftKey), {index: joins[key].rightKey}).coerceTo("ARRAY").do(function(result) {
	                innerQuery = new Query(joins[key].model, result.nth(0));

	                if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {
	                  innerQuery = modelToGet[key]._apply(innerQuery);
	                }
	                innerQuery = innerQuery.getJoin(modelToGet[key], getAll, gotModel)._query;
	                return r.branch(
	                  result.count().eq(1),
	                  r.object(key, innerQuery),
	                  r.branch(
	                    result.count().eq(0),
	                    {},
	                    r.error(r.expr("More than one element found for ").add(doc.coerceTo("STRING")).add(r.expr("for the field ").add(key)))
	                  )
	                )
	              }),
	              {}
	            )
	          });
	          break;

	        case 'hasMany':
	          self._query = self._query.merge(function(doc) {
	            innerQuery = new Query(joins[key].model,
	                       r.table(joins[key].model.getTableName())
	                      .getAll(doc(joins[key].leftKey), {index: joins[key].rightKey}))

	            if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {
	              innerQuery = modelToGet[key]._apply(innerQuery);
	            }
	            innerQuery = innerQuery.getJoin(modelToGet[key], getAll, gotModel);
	            if ((modelToGet[key] == null) || (modelToGet[key]._array !== false)) {
	              innerQuery = innerQuery.coerceTo("ARRAY");
	            }
	            innerQuery = innerQuery._query;

	            return r.branch(
	              doc.hasFields(joins[key].leftKey),
	              r.object(key, innerQuery),
	              {}
	            )
	          });
	          break;

	        case 'hasAndBelongsToMany':
	          self._query = self._query.merge(function(doc) {
	            if ((model.getTableName() === joins[key].model.getTableName()) && (joins[key].leftKey === joins[key].rightKey)) {
	              // In case the model is linked with itself on the same key

	              innerQuery = r.table(joins[key].link).getAll(doc(joins[key].leftKey), {index: joins[key].leftKey+"_"+joins[key].leftKey}).concatMap(function(link) {
	                return r.table(joins[key].model.getTableName()).getAll(
	                  r.branch(
	                    doc(joins[key].leftKey).eq(link(joins[key].leftKey+"_"+joins[key].leftKey).nth(0)),
	                    link(joins[key].leftKey+"_"+joins[key].leftKey).nth(1),
	                    link(joins[key].leftKey+"_"+joins[key].leftKey).nth(0)
	                  )
	                , {index: joins[key].rightKey})
	              });

	              if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {
	                innerQuery = modelToGet[key]._apply(innerQuery);
	              }

	              if ((modelToGet[key] == null) || (modelToGet[key]._array !== false)) {
	                innerQuery = innerQuery.coerceTo("ARRAY");
	              }

	              return r.branch(
	                doc.hasFields(joins[key].leftKey),
	                r.object(key, new Query(joins[key].model, innerQuery).getJoin(modelToGet[key], getAll, gotModel)._query),
	                {}
	              )
	            }
	            else {
	              innerQuery = r.table(joins[key].link).getAll(doc(joins[key].leftKey), {index: model.getTableName()+"_"+joins[key].leftKey}).concatMap(function(link) {
	                return r.table(joins[key].model.getTableName()).getAll(link(joins[key].model.getTableName()+"_"+joins[key].rightKey), {index: joins[key].rightKey})
	              });

	              if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {
	                innerQuery = modelToGet[key]._apply(innerQuery)
	              }

	              if ((modelToGet[key] == null) || (modelToGet[key]._array !== false)) {
	                innerQuery = innerQuery.coerceTo("ARRAY");
	              }

	              return r.branch(
	                doc.hasFields(joins[key].leftKey),
	                r.object(key,
	                  new Query(joins[key].model, innerQuery).getJoin(modelToGet[key], getAll, gotModel)._query),
	                {}
	              )
	            }
	          });
	          break;
	      }
	    }
	  });

	  return self;
	};


	/**
	 * Add a relation
	 * @param {string} field The field of the joined document(s)
	 * @param {Object} joinedDocument An object with the primary key defined or the related key
	 * @return {Promise}
	 *
	 * hasOne, primary key required
	 * User.get(1).addRelation("account", {id: 2, sold: 2132})
	 * The promise resolved the document on which addRelation is called
	 *
	 * hasMany, primary key required
	 * User.get(1).addRelation("accounts", {id: 2, sold: 2132})
	 * The promise resolved the updated joined document
	 *
	 * belongsTo, right joined key OR primary key required
	 * User.get(1).addRelation("account", {id: 2, sold: 2132})
	 * The promise resolved the document on which addRelation is called
	 *
	 * hasAndBelongsToMany, right joined key required
	 * User.get(1).addRelation("accounts", {id: 2, sold: 2132})
	 * The promise resolved with true
	 */

	Query.prototype.addRelation = function(field, joinedDocument) {
	  var self = this;
	  var model = self._model;
	  var joins = self._model._getModel()._joins;
	  var joinedModel = joins[field].model;
	  var r = self._model._thinky.r;

	  switch (joins[field].type) {
	    case 'hasOne':
	    case 'hasMany':
	      if (joinedDocument[joinedModel._pk] === undefined) {
	        return new Query(model, self, {},
	            new Error('Primary key for the joined document not found for a `hasOne/hasMany` relation.')
	        );
	      }
	      var updateValue = {};
	      updateValue[joins[field].rightKey] = self._query(joins[field].leftKey);
	      return joinedModel.get(joinedDocument[joinedModel._pk]).update(updateValue, {nonAtomic: true}).run()
	    case 'belongsTo':
	      var updateValue = {};
	      if (joinedDocument[joins[field].rightKey] === undefined) {
	        if (joinedDocument[joinedModel._pk] === undefined) {
	          return new Query(model, self, {},
	              new Error('The primary key or the joined key must be defined in the joined document for a `belongsTo` relation.')
	          );
	        }
	        updateValue[joins[field].leftKey] = joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey)._query;
	      }
	      else {
	        updateValue[joins[field].leftKey] = joinedDocument[joins[field].rightKey];
	      }
	      return self.update(updateValue, {nonAtomic: true}).run();
	    case 'hasAndBelongsToMany':
	      var linkModel = joins[field].linkModel;
	      var linkValue;
	      var link;
	      if (joinedDocument[joins[field].rightKey] === undefined) {
	        if (joinedDocument[joinedModel._pk] === undefined) {
	          return new Query(model, self, {},
	              new Error('The primary key or the joined key must be defined in the joined document for a `hasAndBelongsToMany` relation.')
	          );
	        }
	        link = joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey)._query
	      }
	      else {
	        link = r.expr(joinedDocument[joins[field].rightKey]);
	      }

	      if ((model.getTableName() === joinedModel.getTableName())
	          && (joins[field].leftKey === joins[field].rightKey)) {
	        linkValue = self._query(joins[field].leftKey).do(function(leftKey) {
	          return link.do(function(rightKey) {
	            return r.branch(
	                rightKey.lt(leftKey),
	                r.object(
	                  'id', rightKey.add('_').add(leftKey),
	                  joins[field].leftKey+"_"+joins[field].leftKey, [leftKey, rightKey]
	                ),
	                r.object(
	                  'id', leftKey.add('_').add(rightKey),
	                  joins[field].leftKey+"_"+joins[field].leftKey, [leftKey, rightKey]
	                )
	            )
	          });
	        });
	      }
	      else {
	        linkValue = self._query(joins[field].leftKey).do(function(leftKey) {
	          return link.do(function(rightKey) {
	            if (model.getTableName() < joinedModel.getTableName()) {
	              return r.object(
	                'id', leftKey.add('_').add(rightKey),
	                model.getTableName()+"_"+joins[field].leftKey, leftKey,
	                joinedModel.getTableName()+"_"+joins[field].rightKey,rightKey
	              )
	            }
	            else if (model.getTableName() > joinedModel.getTableName()) {
	              return r.object(
	                'id', rightKey.add('_').add(leftKey),
	                model.getTableName()+"_"+joins[field].leftKey, leftKey,
	                joinedModel.getTableName()+"_"+joins[field].rightKey,rightKey
	              )
	            }
	            else {
	              return r.branch(
	                rightKey.lt(leftKey),
	                r.object(
	                  'id', leftKey.add('_').add(rightKey),
	                  model.getTableName()+"_"+joins[field].leftKey, leftKey,
	                  joinedModel.getTableName()+"_"+joins[field].rightKey,rightKey
	                ),
	                r.object(
	                  'id', rightKey.add('_').add(leftKey),
	                  model.getTableName()+"_"+joins[field].leftKey, leftKey,
	                  joinedModel.getTableName()+"_"+joins[field].rightKey,rightKey
	                )
	              )
	            }
	          });
	        });
	      }

	      return linkModel.insert(linkValue, {conflict: "replace", returnChanges: 'always'}).do(function(result) {
	        return r.branch(
	            result('errors').eq(0),
	            true, // not relevant value
	            r.error(result('errors'))
	        )
	      }).execute()
	    default:
	      return new Query(model, self, {},
	          new Error('The provided field `'+field+'` does not store joined documents.')
	      );
	  }
	}

	/**
	 * Remove the provided relation
	 * @param {string} field The field of the joined document(s) to remove
	 * @param {Array} joinedDocument The document with who the relation should be removed
	 * @return {Promise}
	 */
	//TODO Support an array of joinedDocuments?
	Query.prototype.removeRelation = function(field, joinedDocument) {
	  var self = this;
	  var model = self._model;
	  var joins = self._model._getModel()._joins;
	  var joinedModel = joins[field].model;
	  var r = self._model._thinky.r;

	  var query;
	  switch (joins[field].type) {
	    case 'hasOne':
	      query = joinedModel.getAll(self._query(joins[field].leftKey), {index: joins[field].rightKey}).replace(function(row) {
	        return row.without(joins[field].rightKey)
	      });
	      query.setPostValidation();
	      query.setPointWrite();
	      return query;
	    case 'hasMany':
	      if (joinedDocument === undefined) {
	        query = joinedModel.getAll(self._query(joins[field].leftKey), {index: joins[field].rightKey}).replace(function(row) {
	          return row.without(joins[field].rightKey)
	        })
	      }
	      else {
	        query = joinedModel.getAll(r.expr(joinedDocument)(joinedModel._pk)).replace(function(row) {
	          return row.without(joins[field].rightKey)
	        })
	      }
	      query.setPostValidation();
	      return query;
	    case 'belongsTo':
	      query = self.replace(function(row) {
	        return row.without(joins[field].leftKey)
	      })
	      query.setPostValidation();
	      return query;
	    case 'hasAndBelongsToMany':
	      var linkModel = joins[field].linkModel;
	      if (joinedDocument === undefined) {
	        query = self._query(joins[field].leftKey).do(function(leftKey) {
	          // range are not supported at the moment, so keys is an object and we don't have to worry about empty sequences
	          if ((model.getTableName() === joinedModel.getTableName())
	              && (joins[field].leftKey === joins[field].rightKey)) {
	            return linkModel.getAll(leftKey, {index: joins[field].leftKey+'_'+joins[field].leftKey}).delete()._query
	          }
	          else {
	            return linkModel.getAll(leftKey, {index: model.getTableName()+'_'+joins[field].leftKey}).delete()._query
	          }
	        }).do(function(result) {
	          return r.branch(
	              result('errors').eq(0),
	              true, // not relevant value
	              r.error(result('errors'))
	           )
	        })
	      }
	      else {
	        if (joinedDocument[joins[field].rightKey] === undefined) {
	          if (joinedDocument[joinedModel._pk] === undefined) {
	            return new Query(model, self, {},
	                new Error('The primary key or the joined key must be defined in the joined document for a `hasAndBelongsToMany` relation.')
	            );
	          }

	          if ((model.getTableName() === joinedModel.getTableName())
	              && (joins[field].leftKey === joins[field].rightKey)) {
	            query = self._query(joins[field].leftKey).do(function(leftKey) {
	              return joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey).do(function(rightKey) {
	                if (model.getTableName() < joinedModel.getTableName()) {
	                  return linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query;
	                }
	                else if (model.getTableName() > joinedModel.getTableName()) {
	                  return linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query;
	                }
	                else {
	                  return r.branch(
	                    leftKey.lt(rightKey),
	                    linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query,
	                    linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query
	                  )
	                }
	              });
	            })
	          }
	          else {
	            query = self._query(joins[field].leftKey).do(function(leftKey) {
	              return joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey).do(function(rightKey) {
	                if (model.getTableName() < joinedModel.getTableName()) {
	                  return linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query
	                }
	                else if (model.getTableName() > joinedModel.getTableName()) {
	                  return linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query
	                }
	                else {
	                  return r.branch(
	                    leftKey.lt(rightKey),
	                    linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query,
	                    linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query
	                  )

	                }
	              });
	            })
	          }
	        }
	        else {
	          query = self._query(joins[field].leftKey).do(function(leftKey) {
	            var rightKey = r.expr(joinedDocument[joins[field].rightKey]);
	            if (model.getTableName() < joinedModel.getTableName()) {
	              return linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query
	            }
	            else if (model.getTableName() > joinedModel.getTableName()) {
	              return linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query
	            }
	            else {
	              return r.branch(
	                leftKey.lt(rightKey),
	                linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query,
	                linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query
	              )

	            }
	          })
	        }
	      }
	      return query;
	    default:
	      return new Query(model, self, {},
	          new Error('The provided field `'+field+'` does not store joined documents.')
	      );
	  }
	};

	/**
	 * Import all the methods from rethinkdbdash, expect the private one (the one
	 * starting with an underscore).
	 * Some method are slightly changed: `get`, `update`, `replace`.
	 */
	(function() {
	  var Term = __webpack_require__(1)({pool: false}).expr(1).__proto__;
	  util.loopKeys(Term, function(Term, key) {
	    if (key === 'run' || key[0] === '_') return;
	    // Note: We suppose that no method has an empty name
	    switch (key) {
	      case 'get':
	        // `get` in thinky returns an error if the document is not found.
	        // The driver currently just returns `null`.
	        (function(key) {
	          Query.prototype[key] = function() {
	            return new Query(this._model, this._query[key].apply(this._query, arguments)).default(this._r.error(new Errors.DocumentNotFound().message));
	          }
	        })(key);
	        // Copy it in `_get` without `default`.
	        (function(key) {
	          Query.prototype['_get'] = function() {
	            // Create a new query to let people fork it
	            return new Query(this._model, this._query[key].apply(this._query, arguments));
	          }
	        })(key);
	        break;
	      case 'update':
	      case 'replace':
	        // `update` and `replace` can be used. A partial validation is performed before
	        // sending the query, and a full validation is performed after the query. If the
	        // validation fails, the document(s) will be reverted.
	        (function(key) {
	          Query.prototype[key] = function(value, options) {
	            options = options || {};
	            options.returnChanges = 'always';
	            var error = null;
	            var self = this;
	            util.tryCatch(function() {
	              if (util.isPlainObject(value)) {
	                schemaUtil.validate(value, self._model._schema, '', {enforce_missing: false});
	              }
	            }, function(err) {
	              error = err;
	            });
	            return new Query(this._model, this._query[key].call(this._query, value, options), {postValidation: true}, error);
	          }
	        })(key);
	        break;

	      case 'changes':
	        (function(key) {
	          Query.prototype[key] = function() {
	            // In case of `get().changes()` we want to remove the default(r.errror(...))
	            // TODO: Do not hardcode this?
	            if ((typeof this._query === 'function') && (this._query._query[0] === 92)) {
	              this._query._query = this._query._query[1][0];
	            }
	            return new Query(this._model, this._query[key].apply(this._query, arguments));
	          }
	        })(key);
	        break;

	      case 'then':
	      case 'error':
	      case 'catch':
	      case 'finally':
	        (function(key) {
	          Query.prototype[key] = function() {
	            var promise = this.run();
	            return promise[key].apply(promise, arguments);
	          }
	        })(key);
	        break;

	      case 'ungroup':
	        (function(key) {
	          Query.prototype[key] = function() {
	            return new Query(this._model, this._query[key].apply(this._query, arguments), {ungroup: true});
	          }
	        })(key);
	        break;

	      default:
	        (function(key) {
	          Query.prototype[key] = function() {
	            // Create a new query to let people fork it
	            return new Query(this._model, this._query[key].apply(this._query, arguments));
	          }
	        })(key);
	        break;
	      }
	  });
	})();

	Query.prototype._isPointWrite = function() {
	  return this._pointWrite || (Array.isArray(this._query._query) &&
	      (this._query._query.length > 1) &&
	      Array.isArray(this._query._query[1]) &&
	      (this._query._query[1].length > 0) &&
	      Array.isArray(this._query._query[1][0]) &&
	      (this._query._query[1][0].length > 1) &&
	      Array.isArray(this._query._query[1][0][1]) &&
	      (this._query._query[1][0][1].length > 0) &&
	      Array.isArray(this._query._query[1][0][1][0]) &&
	      (this._query._query[1][0][1][0][0] === 16))
	}

	/**
	 * Convert the query to its string representation.
	 * @return {string}
	 */
	Query.prototype.toString = function() {
	  return this._query.toString();
	}

	module.exports = Query;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {var Promise = __webpack_require__(29);
	var EventEmitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(65);

	function Feed(feed, model) {
	  this.feed = feed;
	  this.model = model;
	  this._closed = false;

	  this.each = this._each;
	  this.next = this._next;
	}

	Feed.prototype.toString = function() {
	  return '[object Feed]'
	}


	Feed.prototype._next = function() {
	  var self = this;
	  return new Promise(function(resolve, reject) {
	    self.feed.next().then(function(data) {
	      util.tryCatch(function() {
	        if (data.new_val != null) {
	          self.model._parse(data.new_val).then(function(doc) {
	            doc._setOldValue(data.old_val);
	            resolve(doc);
	          }).error(reject);
	        }
	        else if (data.old_val != null) { // new_val is null
	          self.model._parse(data.old_val).then(function(doc) {
	            doc._setUnSaved();
	            resolve(doc);
	          }).error(reject);
	        }
	        //else we just drop the change as it's a state/initializing object
	      }, function(err) {
	        reject(err);
	      })
	    }).error(reject);
	  });
	}

	Feed.prototype.toArray = function() {
	  throw new Error("The `toArray` method is not available on feeds.");
	}

	Feed.prototype.close = function(callback) {
	  this._closed = true;
	  return this.feed.close(callback);
	}

	Feed.prototype._each = function(callback, onFinish) {
	  var self = this;
	  self.feed.each(function(err, data) {
	    if (err) {
	      if (self._closed === true) {
	        return;
	      }
	      return callback(err);
	    }
	    util.tryCatch(function() {
	      if (data.new_val != null) {
	        self.model._parse(data.new_val).then(function(doc) {
	          doc._setOldValue(data.old_val);
	          callback(null, doc);
	        }).error(function(err) {
	          callback(err);
	        });
	      }
	      else if (data.old_val != null) { // new_val is null
	        self.model._parse(data.old_val).then(function(doc) {
	          doc._setUnSaved();
	          callback(null, doc);
	        }).error(function(err) {
	          callback(err);
	        });
	      }
	      //else we just drop the change as it's a state/initializing object
	    }, function(err) {
	      callback(err);
	    })
	  }, onFinish);
	};

	Feed.prototype._makeEmitter = function() {
	  this.next = function() {
	    throw new Error("You cannot called `next` once you have bound listeners on the feed")
	  }
	  this.each = function() {
	    throw new Error("You cannot called `each` once you have bound listeners on the feed")
	  }
	  this.toArray = function() {
	    throw new Error("You cannot called `toArray` once you have bound listeners on the feed")
	  }
	  this._eventEmitter = new EventEmitter();
	}

	Feed.prototype._eachCb = function(err, data) {
	  var self = this;
	  if (err != null) {
	    if ((this._closed !== false) || (err.message !== "You cannot retrieve data from a cursor that is closed")) {
	      self._eventEmitter.emit('error', err);
	    }
	    return;
	  }

	  util.tryCatch(function() {
	    if (data.new_val !== null) {
	      self.model._parse(data.new_val).then(function(doc) {
	        doc._setOldValue(data.old_val);
	        self._eventEmitter.emit('data', doc);
	      }).error(function(err) {
	        self._eventEmitter.emit('error', err);
	      });
	    }
	    else if (data.old_val !== null) { // new_val is null
	      self.model._parse(data.old_val).then(function(doc) {
	        doc._setUnSaved();
	        self._eventEmitter.emit('data', doc);
	      }).error(function(err) {
	        self._eventEmitter.emit('error', err);
	      });
	    }
	  }, function(err) {
	    self._eventEmitter.emit('error', err);
	  })
	}

	var methods = [
	    'addListener',
	    'on',
	    'once',
	    'removeListener',
	    'removeAllListeners',
	    'setMaxListeners',
	    'listeners',
	    'emit'
	];

	for(var i=0; i<methods.length; i++) {
	  (function(n) {
	    var method = methods[n];
	    Feed.prototype[method] = function() {
	      var self = this;
	      if (self._eventEmitter == null) {
	        self._makeEmitter();
	        setImmediate(function() {
	          self.feed._each(self._eachCb.bind(self), function() {
	            self._eventEmitter.emit('end');
	          });
	        });
	      }
	      self._eventEmitter[method].apply(self._eventEmitter, util.toArray(arguments));
	    };
	  })(i);
	}

	module.exports = Feed;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))

/***/ }
/******/ ])
});
;
